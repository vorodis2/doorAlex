{"code":"!function(t){var r={};function n(e){if(r[e])return r[e].exports;var i=r[e]={i:e,l:!1,exports:{}};return t[e].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=t,n.c=r,n.d=function(t,r,e){n.o(t,r)||Object.defineProperty(t,r,{enumerable:!0,get:e})},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},n.t=function(t,r){if(1&r&&(t=n(t)),8&r)return t;if(4&r&&\"object\"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(n.r(e),Object.defineProperty(e,\"default\",{enumerable:!0,value:t}),2&r&&\"string\"!=typeof t)for(var i in t)n.d(e,i,function(r){return t[r]}.bind(null,i));return e},n.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(r,\"a\",r),r},n.o=function(t,r){return Object.prototype.hasOwnProperty.call(t,r)},n.p=\"build/\",n(n.s=8)}([function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return MVisi3D; });\\n/* harmony import */ var _MEffectArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\\n/* harmony import */ var _MPosition3d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\\n/* harmony import */ var _MEvent3DArr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);\\n/* harmony import */ var _MUtility_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);\\n\\r\\n\\r\\n\\r\\n\\r\\n/**/\\r\\n\\r\\nfunction MVisi3D (_contentHTML, _content2d, _devas, _directional, _efect, _event3DArr, _alpha) {\\r\\n\\tvar self = this;\\r\\n\\r\\n\\t_devas = _devas !== undefined ? _devas : false;\\r\\n\\t_directional = _directional !== undefined ? _directional : true;\\r\\n\\t_efect = _efect !== undefined ? _efect : true;\\r\\n\\t_event3DArr = _event3DArr !== undefined ? _event3DArr : true;\\r\\n\\t_alpha = _alpha !== undefined ? _alpha : false;\\r\\n\\tthis.intRend=0;\\r\\n\\tthis.devas = _devas;\\r\\n\\r\\n\\tthis.arrSetiScene = [];\\r\\n\\r\\n\\tthis._xVerh = 0;\\r\\n\\tthis._yVerh = 0;\\r\\n\\tthis._zVerh = 0;\\r\\n\\tthis._rotationX = 0;\\r\\n\\tthis._rotationZ = 0;\\r\\n\\tthis._zume = 1000;\\r\\n\\tthis._arrOut = [];\\r\\n\\tthis._x = 0;\\r\\n\\tthis._y = 0;\\r\\n\\tthis._height = 100;\\r\\n\\tthis._width = 100;\\r\\n\\tthis.yes3d = true;\\r\\n\\tthis.intRendOk = 1;\\r\\n\\tthis._visible = true;\\r\\n\\tthis._isDragPan = false;\\r\\n\\tthis._activMouse = true;\\r\\n\\tthis._staticShadow = false;\\r\\n\\r\\n\\tthis.alwaysRender = false;\\r\\n\\r\\n\\r\\n\\tthis.AMBIEN_COLOR = '#ffffff';// цвет амдеба\\r\\n\\tthis.AMBIEN_INTENSITY = 0.79;// интенсивность амдеба\\r\\n\\r\\n\\tthis.LIGHT_COLOR = '#ffffff';\\r\\n\\tthis.LIGHT_BIAS = 0.001;\\r\\n\\tthis.SHADOW_INTENSITY = 0.22;\\r\\n\\tthis.SHADOW_RADIUS = 1;\\r\\n\\tthis.SHADOW_WH = 4096;\\r\\n\\tthis.DISTANCE = 0;\\r\\n\\tthis.CUB_HEIGHT = 500;\\r\\n\\tthis.CUB_WIDTH = 500;\\r\\n\\r\\n\\r\\n\\tthis.FOV = 45;\\r\\n\\tthis.FAR = 45000;\\r\\n\\r\\n\\tthis.content = undefined;\\r\\n\\tthis.graphics = undefined;\\r\\n\\r\\n\\r\\n\\tif (_content2d != undefined) {\\r\\n\\t\\tthis.content = eval('new PIXI.Container()');\\r\\n\\t\\tthis.graphics = eval('new PIXI.Graphics()');\\r\\n\\t\\t_content2d.addChild(this.content);\\r\\n\\t\\tthis.content.addChild(this.graphics);\\r\\n\\t\\tthis.graphics.interactive = true;\\r\\n\\t}\\r\\n\\r\\n\\tthis.camera;\\r\\n\\tthis.scene = new THREE.Scene();\\r\\n\\r\\n\\tvar color = 0x79bccc;\\r\\n\\tthis.camera = new THREE.PerspectiveCamera(this.FOV, this._width / this._height, 1, this.FAR);\\r\\n\\tif (this.devas == true) {\\r\\n\\t\\tthis.renderer = new THREE.WebGLRenderer();\\r\\n\\t\\tthis.renderer.setSize(this._width, this._height);\\r\\n\\t\\tthis.renderer.setClearColor(color, 1);\\r\\n\\t} else {\\r\\n\\t\\tthis.renderer = new THREE.WebGLRenderer({antialias: true, alpha: _alpha});\\r\\n\\t\\tthis.renderer.shadowMap.enabled = true;\\r\\n\\t\\tthis.renderer.setSize(this._width, this._height);\\r\\n\\t\\tif (_alpha == true) this.renderer.setClearColor(color, 0);\\r\\n\\t\\telse this.renderer.setClearColor(color, 1);\\r\\n\\t}\\r\\n\\r\\n\\tthis.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\\r\\n\\tthis.efect;\\r\\n\\tif (_efect == true) {\\r\\n\\t\\tthis.efect = new _MEffectArray_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \\\"a\\\"](this, []);\\r\\n\\t\\tthis.efect.init();\\r\\n\\t}\\r\\n\\r\\n\\tthis.event3DArr;\\r\\n\\tif (_event3DArr == true) {\\r\\n\\t\\tthis.event3DArr = new _MEvent3DArr_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ \\\"a\\\"](this, this.camera, this.renderer.domElement);\\r\\n\\t\\tthis.scene.event3DArr = this.event3DArr;\\r\\n\\t\\tthis.event3DArr.addDragEvent(this.graphics);\\r\\n\\t\\tthis.event3DArr.activ = this._activMouse;\\r\\n\\t}\\r\\n\\r\\n\\tthis.camera.position.set(0, 0, -60);\\r\\n\\tthis.camera.rotation.set(Math.PI, 0, 0);\\r\\n\\r\\n\\t_contentHTML.appendChild(this.renderer.domElement);\\r\\n\\t//this.renderer.domElement.style.zIndex = -1;\\r\\n\\tthis.renderer.domElement.style.position = 'fixed';\\r\\n\\tthis.renderer.domElement.style.top = '0px';\\r\\n\\tthis.renderer.domElement.style.left = '0px';\\r\\n\\r\\n\\tthis.group = new THREE.Object3D();\\r\\n\\tthis.group.rotation.x = Math.PI / 2;\\r\\n\\tthis.scene.add(this.group);\\r\\n\\tthis.group1 = new THREE.Object3D();\\r\\n\\tthis.group.add(this.group1);\\r\\n\\tthis.group2 = new THREE.Object3D();\\r\\n\\tthis.group1.add(this.group2);\\r\\n\\tthis.groupObject = new THREE.Object3D();\\r\\n\\tthis.group2.add(this.groupObject);\\r\\n\\r\\n\\tthis.group3d = new THREE.Object3D();\\r\\n\\tthis.groupObject.add(this.group3d);\\r\\n\\r\\n\\tthis.gCGG = new THREE.Object3D();\\r\\n\\tthis.group.add(this.gCGG);\\r\\n\\tthis.gCAngel = new THREE.Object3D();\\r\\n\\tthis.gCGG.add(this.gCAngel);\\r\\n\\tthis.gCam1 = new THREE.Object3D();\\r\\n\\tthis.gCAngel.add(this.gCam1);\\r\\n\\tthis.gCam2 = new THREE.Object3D();\\r\\n\\tthis.gCam1.add(this.gCam2);\\r\\n\\tthis.ggCam = new THREE.Object3D();\\r\\n\\tthis.gCam2.add(this.ggCam);\\r\\n\\tthis.ggCam.add(this.camera);\\r\\n\\r\\n\\r\\n\\tthis.ggCam.position.z = -this._zume;\\r\\n\\tthis.camera.position.z = 0;\\r\\n\\r\\n\\tthis.axesHelper = new THREE.AxesHelper(100);\\r\\n\\tthis.scene.add(this.axesHelper);\\r\\n\\tthis.axesHelper.visible = false;\\r\\n\\r\\n\\tthis.arrPoint = [];\\r\\n\\tvar disLig = 4000;\\r\\n\\tvar powerLig = 0.4;\\r\\n\\tvar dis = 10000;\\r\\n\\r\\n\\tthis.sunLight;\\r\\n\\tthis.ambientLight = new THREE.AmbientLight(this.AMBIEN_COLOR, this.AMBIEN_INTENSITY);// 0.8);\\r\\n\\tthis.scene.add(this.ambientLight);\\r\\n\\tthis.ambientLight.castShadow = false;\\r\\n\\r\\n\\tif (_directional == true) {\\r\\n\\t\\tvar sunIntensity = this.SHADOW_INTENSITY;\\r\\n\\t\\tthis.sunLight = new THREE.DirectionalLight(this.LIGHT_COLOR, sunIntensity, 0, 0, 0.2);\\r\\n\\t\\t// this.sunLight.position.set(  4500, this.offsetD, -8000);\\r\\n\\t\\tthis.sunLight.position.set(0, (this.DISTANCE + this.CUB_HEIGHT * 2), 0);\\r\\n\\t\\tthis.sunLight.castShadow = true;\\r\\n\\t\\tthis.sunLight.shadow.camera.near = this.CUB_HEIGHT;// 7000\\r\\n\\t\\tthis.sunLight.shadow.camera.far = this.CUB_HEIGHT + this.CUB_HEIGHT * 2;// 20000\\r\\n\\r\\n\\t\\tthis.sunLight.shadow.camera.right = this.CUB_WIDTH;\\r\\n\\t\\tthis.sunLight.shadow.camera.left = -this.CUB_WIDTH;\\r\\n\\t\\tthis.sunLight.shadow.camera.top\\t= this.CUB_WIDTH;\\r\\n\\t\\tthis.sunLight.shadow.camera.bottom = -this.CUB_WIDTH;\\r\\n\\t\\tthis.sunLight.shadow.mapSize.width = this.SHADOW_WH;\\r\\n\\t\\tthis.sunLight.shadow.mapSize.height = this.SHADOW_WH;\\r\\n\\t\\tthis.sunLight.shadow.bias = this.LIGHT_BIAS;\\r\\n\\t\\tthis.sunLight.shadow.radius = this.SHADOW_RADIUS;\\r\\n\\t}\\r\\n\\r\\n\\tthis.initOut = function () {};\\r\\n\\r\\n\\tthis.position3d = new _MPosition3d_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ \\\"a\\\"](self, this.graphics);\\r\\n\\tthis.utility = new _MUtility_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ \\\"a\\\"](self);\\r\\n\\r\\n\\tthis.arrayDoRender = [];\\r\\n\\tthis.shadowNeedsUpdate = false;\\r\\n\\r\\n\\tthis.render = function () {\\r\\n\\t\\tif (this.yes3d == false) return;\\r\\n\\t\\tthis.utility.render();\\r\\n\\t\\tthis.intRend = 10;\\r\\n\\t\\tif (this.shadowNeedsUpdate) {\\r\\n\\t\\t\\tthis.shadowNeedsUpdate = false;\\r\\n\\t\\t\\tthis.renderer.shadowMap.needsUpdate = true;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (this.efect) {\\r\\n\\t\\t\\tif (this.efect.render() == false) this.renderer.render(this.scene, this.camera);\\r\\n\\t\\t} else this.renderer.render(this.scene, this.camera);\\r\\n\\r\\n\\r\\n\\t\\tif (this.arrayDoRender.length != 0) {\\r\\n\\t\\t\\tfor (var i = 0; i < this.arrayDoRender.length; i++) this.arrayDoRender[i]();\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\tthis.upDate = function () {\\r\\n\\t\\tif (this.alwaysRender || (this.intRend == this.intRendOk)) {\\r\\n\\t\\t\\tthis.render();\\r\\n\\t\\t}\\r\\n\\t\\tif (this.intRend < 10) this.intRend++;\\r\\n\\t};\\r\\n\\r\\n\\tthis.renderer.render(this.scene, this.camera);\\r\\n\\r\\n\\tthis.sizeWindow = function (_x, _y, _width, _height) {\\r\\n\\r\\n\\t\\tif (_x != undefined) this._x = _x;\\r\\n\\t\\tif (_y != undefined) this._y = _y;\\r\\n\\t\\tif (_height != undefined) this._height = _height;\\r\\n\\t\\tif (_width != undefined) this._width = _width;\\r\\n\\r\\n\\t\\tif (this.content != undefined) {\\r\\n\\t\\t\\tthis.content.x = this._x;\\r\\n\\t\\t\\tthis.content.y = this._y;\\r\\n\\t\\t\\tthis.graphics.clear();\\r\\n\\t\\t\\tthis.graphics.beginFill(0xff0000, 0.0);\\r\\n\\t\\t\\tthis.graphics.drawRect(0, 0, this._width, this._height);\\r\\n\\t\\t\\tthis.graphics.endFill();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.renderer.domElement.style.left = this._x + 'px';\\r\\n\\t\\tthis.renderer.domElement.style.top = this._y + 'px';\\r\\n\\r\\n\\t\\tthis.camera.aspect = this._width / this._height;\\r\\n\\t\\tthis.camera.updateProjectionMatrix();\\r\\n\\t\\tthis.renderer.setSize(this._width, this._height);\\r\\n\\t\\tthis.intRend = 1;\\r\\n\\r\\n\\t\\tif (this.event3DArr) {\\r\\n\\t\\t\\tthis.event3DArr.sizeWindow(this._width, this._height);\\r\\n\\t\\t\\tthis.event3DArr.setRect(this._x, this._y, this._width, this._height);\\r\\n\\t\\t}\\r\\n\\t\\tif (this.efect) this.efect.sizeWindow(this._width, this._height);\\r\\n\\t};\\r\\n\\r\\n\\tthis.render();\\r\\n\\tthis.sizeWindow();\\r\\n\\r\\n\\tvar bbbbbb;\\r\\n\\t// Набрасываем на объекты тени\\r\\n\\tthis.objShadow = function (obj, bol) {\\r\\n\\t\\tif (this.devas.devas == true) {\\r\\n\\t\\t\\tbol = false;\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tif (this.devas.webGL == false) {\\r\\n\\t\\t\\tbol = false;\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (bol == undefined) bol = true;\\r\\n\\r\\n\\r\\n\\t\\tbbbbbb = true;\\r\\n\\t\\tif (obj.material) {\\r\\n\\t\\t\\tif (obj.material.transparent == true && obj.material.opacity < 1) {\\r\\n\\t\\t\\t\\tbbbbbb = false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tif (bbbbbb == true) {\\r\\n\\t\\t\\tobj.castShadow = bol;\\r\\n\\t\\t\\tobj.receiveShadow = bol;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (obj.children != undefined) {\\r\\n\\t\\t\\tfor (var i = 0; i < obj.children.length; i++) {\\r\\n\\t\\t\\t\\tif (obj.children != undefined) {\\r\\n\\t\\t\\t\\t\\tthis.objShadow(obj.children[i], bol);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tbbbbbb = true;\\r\\n\\t\\t\\t\\t\\tif (obj.children[i].material) {\\r\\n\\t\\t\\t\\t\\t\\tif (obj.material.transparent == true && obj.material.opacity < 1) {\\r\\n\\t\\t\\t\\t\\t\\t\\tbbbbbb = false;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif (bbbbbb == true) {\\r\\n\\t\\t\\t\\t\\t\\tobj.children[i].castShadow = bol;\\r\\n\\t\\t\\t\\t\\t\\tobj.children[i].receiveShadow = bol;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.addEvent = function (str, fun) { if (this.event3DArr) this.event3DArr.eventSob.addEvent(str, fun); };\\r\\n\\tthis.removeEvent = function (str, fun) { if (this.event3DArr) this.event3DArr.eventSob.removeEvent(str, fun); };\\r\\n\\r\\n\\tthis.addChildMouse = function (child) { if (this.event3DArr) this.event3DArr.addChild(child); };\\r\\n\\tthis.removeChildMouse = function (child) { if (this.event3DArr) this.event3DArr.removeChild(child); };/**/\\r\\n}\\r\\n\\r\\nMVisi3D.prototype = {\\r\\n\\r\\n\\tset staticShadow (v) {\\r\\n\\t\\tthis.renderer.shadowMap.autoUpdate = !v;\\r\\n\\t\\tthis._staticShadow = v;\\r\\n\\t},\\r\\n\\tget staticShadow () {\\r\\n\\t\\treturn this._staticShadow;\\r\\n\\t},\\r\\n\\tset rotationX (v) {\\r\\n\\t\\tif (this._rotationX === v) return;\\r\\n\\t\\tthis._rotationX = v;\\r\\n\\t\\tthis.intRend = 1;\\r\\n\\t\\tthis.gCam2.rotation.x = v;\\r\\n\\t},\\r\\n\\tget rotationX () {\\r\\n\\t\\treturn this._rotationX;\\r\\n\\t},\\r\\n\\tset rotationZ (v) {\\r\\n\\t\\tif (this._rotationZ === v) return;\\r\\n\\t\\tthis._rotationZ = v;\\r\\n\\t\\tthis.gCam1.rotation.z = v;\\r\\n\\t\\tthis.intRend = 1;\\r\\n\\t},\\r\\n\\tget rotationZ () {\\r\\n\\t\\treturn this._rotationZ;\\r\\n\\t},\\r\\n\\tset zume (v) {\\r\\n\\t\\tif (this._zume === v) return;\\r\\n\\t\\tthis._zume = v;\\r\\n\\t\\tthis.ggCam.position.z = -v;\\r\\n\\t\\tthis.camera.position.z = 0;\\r\\n\\t\\tthis.intRend = 1;\\r\\n\\t},\\r\\n\\tget zume () {\\r\\n\\t\\treturn this._zume;\\r\\n\\t},\\r\\n\\tset yVerh (v) {\\r\\n\\t\\tthis._yVerh = v;\\r\\n\\t\\tthis.gCGG.position.z = v;\\r\\n\\t\\tthis.intRend = 1;\\r\\n\\t},\\r\\n\\tget yVerh () {\\r\\n\\t\\treturn this.gCGG.position.z;\\r\\n\\t},\\r\\n\\tset xVerh (v) {\\r\\n\\t\\tthis._xVerh = v;\\r\\n\\t\\tthis.gCGG.position.x = v;\\r\\n\\t\\tthis.intRend = 1;\\r\\n\\t},\\r\\n\\tget xVerh () {\\r\\n\\t\\treturn this.gCGG.position.x;\\r\\n\\t},\\r\\n\\tset zVerh (v) {\\r\\n\\t\\tthis._zVerh = v;\\r\\n\\t\\tthis.gCGG.position.y = v;\\r\\n\\t\\tthis.intRend = 1;\\r\\n\\t},\\r\\n\\tget zVerh () {\\r\\n\\t\\treturn this.gCGG.position.y;\\r\\n\\t},\\r\\n\\tset arrOut (v) {\\r\\n\\t\\tthis._arrOut = v;\\r\\n\\t\\tthis.efect.setValue('outline', null, this._arrOut);\\r\\n\\t\\tthis.intRend = 1;\\r\\n\\t},\\r\\n\\tget arrOut () {\\r\\n\\t\\treturn this._arrOut;\\r\\n\\t},\\r\\n\\tset x (v) {\\r\\n\\t\\tthis._x = v;\\r\\n\\t\\tthis.sizeWindow();\\r\\n\\t},\\r\\n\\tget x () {\\r\\n\\t\\treturn this._x;\\r\\n\\t},\\r\\n\\r\\n\\tset y (v) {\\r\\n\\t\\tthis._y = v;\\r\\n\\t\\tthis.sizeWindow();\\r\\n\\t},\\r\\n\\tget y () {\\r\\n\\t\\treturn this._y;\\r\\n\\t},\\r\\n\\r\\n\\tset height (v) {\\r\\n\\t\\tthis._height = v;\\r\\n\\t\\tthis.sizeWindow();\\r\\n\\t},\\r\\n\\tget height () {\\r\\n\\t\\treturn this._height;\\r\\n\\t},\\r\\n\\r\\n\\tset width (v) {\\r\\n\\t\\tthis._width = v;\\r\\n\\t\\tthis.sizeWindow();\\r\\n\\t},\\r\\n\\tget width () {\\r\\n\\t\\treturn this._width;\\r\\n\\t},\\r\\n\\tset visible (v) {\\r\\n\\t\\tthis._visible = v;\\r\\n\\t\\tthis.content.visible = v;\\r\\n\\t\\tthis.renderer.domElement.style.visibility = v ? 'visible' : 'hidden';\\r\\n\\t},\\r\\n\\tget visible () {\\r\\n\\t\\treturn this._visible;\\r\\n\\t},\\r\\n\\tset isDragPan (v) {\\r\\n\\t\\tthis._isDragPan = v;\\r\\n\\t\\tthis.position3d.isDragPan = v;\\r\\n\\t},\\r\\n\\tget isDragPan () {\\r\\n\\t\\treturn this._isDragPan;\\r\\n\\t},\\r\\n\\tset activMouse (v) {\\r\\n\\t\\tthis._activMouse = v;\\r\\n\\t\\tif (this.event3DArr) this.event3DArr.activ = this._activMouse;\\r\\n\\r\\n\\t},\\r\\n\\tget activMouse () {\\r\\n\\t\\treturn this._activMouse;\\r\\n\\t},\\r\\n\\tset minZum (v) {\\r\\n\\t\\tthis.position3d.minZum = v;\\r\\n\\t},\\r\\n\\tget minZum () {\\r\\n\\t\\treturn this.position3d.minZum;\\r\\n\\t},\\r\\n\\tset maxZum (v) {\\r\\n\\t\\tthis.position3d.maxZum = v;\\r\\n\\t},\\r\\n\\tget maxZum () {\\r\\n\\t\\treturn this.position3d.maxZum;\\r\\n\\t},\\r\\n\\tset maxRotationX (v) {\\r\\n\\t\\tthis.position3d.minMaxX.x = v;\\r\\n\\t},\\r\\n\\tget maxRotationX () {\\r\\n\\t\\treturn this.position3d.minMaxX.x;\\r\\n\\t},\\r\\n\\tset minRotationX (v) {\\r\\n\\t\\tif (v < this.rotationX) {\\r\\n\\t\\t\\tthis.rotationX = v;\\r\\n\\t\\t}\\r\\n\\t\\tthis.position3d.minMaxX.y = v;\\r\\n\\t},\\r\\n\\tget minRotationX () {\\r\\n\\t\\treturn this.position3d.minMaxX.y;\\r\\n\\t}\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./src/libMy/visi3D/MVisi3D.js?\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return MSky; });\\nfunction MSky (_parent) {\\r\\n\\tthis.parent = _parent;\\r\\n\\tvar self = this;\\r\\n\\tthis._active = false;\\r\\n\\r\\n\\r\\n\\tthis.RADIUS = 1000;\\r\\n\\r\\n\\tthis.POS_X = 0;\\r\\n\\tthis.POS_Y = 0;\\r\\n\\tthis.POS_Z = 0;\\r\\n\\r\\n\\tthis.LINK = 'null';\\r\\n\\tthis.COLOR = '0xffffff';\\r\\n\\r\\n\\tthis._radius = this.RADIUS;\\r\\n\\tthis._link = this.LINK;\\r\\n\\tthis._color = this.COLOR;\\r\\n\\tthis._shadRotZ = this.parent.ROTATION_Z;\\r\\n\\tthis._rotZ = 0;\\r\\n\\r\\n\\tthis._x = this.POS_X;\\r\\n\\tthis._y = this.POS_Y;\\r\\n\\tthis._z = this.POS_Z;\\r\\n\\r\\n\\tthis.mesh = undefined;\\r\\n\\r\\n\\tthis.cont3d = undefined;\\r\\n\\tthis.cont3d1 = undefined;\\r\\n\\tthis.textur = undefined;\\r\\n\\r\\n\\tthis.init = function () {\\r\\n\\t\\tif (this.mesh != undefined) return;\\r\\n\\t\\tthis.geometry = new THREE.SphereGeometry(1, 32, 32);\\r\\n\\t\\tthis.loader = new THREE.TextureLoader();\\r\\n\\t\\tthis.loaderHDR = new THREE.RGBELoader();\\r\\n\\r\\n\\t\\tthis.material = new THREE.MeshBasicMaterial({\\r\\n\\t\\t\\tside: THREE.BackSide,\\r\\n\\t\\t\\tcolor: 0xffffff\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\tthis.mesh = new THREE.Mesh(this.geometry, this.material);\\r\\n\\t\\tthis.mesh.scale.set(this._radius, this._radius, this._radius);\\r\\n\\r\\n\\t\\tthis.cont3d = new THREE.Object3D();\\r\\n\\t\\tthis.cont3d1 = new THREE.Object3D();\\r\\n\\t\\tthis.cont3d.add(this.cont3d1);\\r\\n\\t\\tthis.cont3d1.add(this.mesh);\\r\\n\\r\\n\\t\\tthis.cont3d1.rotation.y = this._shadRotZ;\\r\\n\\t\\tthis.mesh.rotation.y = this._rotZ;\\r\\n\\r\\n\\t\\tthis.cont3d.rotation.x = -Math.PI / 2;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.dergActiv = function () {\\r\\n\\t\\tif (this._active == true) {\\r\\n\\t\\t\\tif (this.cont3d.parent == null) this.parent.parent.groupObject.add(this.cont3d);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (this.cont3d.parent != null) this.parent.parent.groupObject.remove(this.cont3d);\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tvar tt;\\r\\n\\tthis.dergLink = function () {\\r\\n\\t\\tif (this._link == 'null') { // сносим мапу\\r\\n\\t\\t\\tif (this.material.map != null) {\\r\\n\\t\\t\\t\\tthis.material.map = null;\\r\\n\\t\\t\\t\\tthis.material.needsUpdate = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else { // грузим новую\\r\\n\\t\\t\\ttt = this.checkFormat(this._link);\\r\\n\\t\\t\\tif (tt == 0) { // щбычная\\r\\n\\t\\t\\t\\tthis.loader.load(this._link, function (textur) {\\r\\n\\t\\t\\t\\t\\tself.textur = textur;\\r\\n\\t\\t\\t\\t\\tself.material.map =\\ttextur;\\r\\n\\t\\t\\t\\t\\tself.material.needsUpdate = true;\\r\\n\\t\\t\\t\\t\\tself.parent.parent.intRend = 1;\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (tt == 1) { // hdr\\r\\n\\t\\t\\t\\tthis.loaderHDR.load(this._link, function (textur) {\\r\\n\\t\\t\\t\\t\\tself.textur = textur;\\r\\n\\r\\n\\t\\t\\t\\t\\tself.textur.encoding = THREE.RGBEEncoding;\\r\\n\\t\\t\\t\\t\\tself.textur.minFilter = THREE.NearestFilter;\\r\\n\\t\\t\\t\\t\\tself.textur.magFilter = THREE.NearestFilter;\\r\\n\\t\\t\\t\\t\\tself.textur.flipY = true;\\r\\n\\t\\t\\t\\t\\tself.material.map =\\ttextur;\\r\\n\\t\\t\\t\\t\\tself.material.needsUpdate = true;\\r\\n\\t\\t\\t\\t\\tself.parent.parent.intRend = 1;\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.checkFormat = function (link) {\\r\\n\\t\\tif (link.indexOf('.png') !== -1) return 0;\\r\\n\\t\\tif (link.indexOf('.jpeg') !== -1) return 0;\\r\\n\\t\\tif (link.indexOf('.jpg') !== -1) return 0;\\r\\n\\r\\n\\t\\tif (link.length > 150) { // это бейс 64 хз какой но не хдр наверно)))\\r\\n\\t\\t\\tif (link.indexOf('png') !== -1) return 0;\\r\\n\\t\\t\\tif (link.indexOf('jpeg') !== -1) return 0;\\r\\n\\t\\t\\tif (link.indexOf('jpg') !== -1) return 0;\\r\\n\\t\\t\\treturn 1;\\r\\n\\t\\t}\\r\\n\\t\\treturn 1;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.render = function () {\\r\\n\\t\\t/* if(this.mesh==undefined)return\\r\\n\\t\\tif(this._active == false)return\\r\\n\\r\\n\\t\\tif(this._rotationZ!=this.parent.parent.rotationZ){\\r\\n\\t\\t\\tthis._rotationZ=this.parent.parent.rotationZ\\r\\n\\t\\t\\t//this.cont3d1.rotation.y=this._rotationZ\\r\\n\\t\\t} */\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n}\\r\\nMSky.prototype = {\\r\\n\\tset x (v) {\\r\\n\\t\\tif (this._x === v) return;\\r\\n\\t\\tthis._x = v;\\r\\n\\t\\tthis.cont3d.position.x = v;\\r\\n\\t\\tthis.parent.parent.intRend = 1;\\r\\n\\t},\\r\\n\\tget x () {\\r\\n\\t\\treturn this._x;\\r\\n\\t},\\r\\n\\r\\n\\tset y (v) {\\r\\n\\t\\tif (this._y === v) return;\\r\\n\\t\\tthis._y = v;\\r\\n\\t\\tthis.cont3d.position.y = v;\\r\\n\\t\\tthis.parent.parent.intRend = 1;\\r\\n\\t},\\r\\n\\tget y () {\\r\\n\\t\\treturn this._y;\\r\\n\\t},\\r\\n\\r\\n\\tset z (v) {\\r\\n\\t\\tif (this._z === v) return;\\r\\n\\t\\tthis._z = v;\\r\\n\\t\\tthis.cont3d.position.z = v;\\r\\n\\t\\tthis.parent.parent.intRend = 1;\\r\\n\\t},\\r\\n\\tget z () {\\r\\n\\t\\treturn this._z;\\r\\n\\t},\\r\\n\\r\\n\\tset active (v) {\\r\\n\\t\\tif (this._active === v) return;\\r\\n\\t\\tthis._active = v;\\r\\n\\t\\tthis.init();\\r\\n\\t\\tthis.dergActiv();\\r\\n\\t},\\r\\n\\tget active () {\\r\\n\\t\\treturn this._active;\\r\\n\\t},\\r\\n\\r\\n\\tset radius (v) {\\r\\n\\t\\tif (this._radius === v) return;\\r\\n\\t\\tthis._radius = v;\\r\\n\\t\\tif (this.mesh != undefined) {\\r\\n\\t\\t\\tthis.mesh.scale.set(this._radius, this._radius, this._radius);\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\tget radius () {\\r\\n\\t\\treturn this._radius;\\r\\n\\t},\\r\\n\\r\\n\\tset link (v) {\\r\\n\\t\\tif (this._link === v) return;\\r\\n\\t\\tthis._link = v;\\r\\n\\t\\tthis.init();\\r\\n\\t\\tthis.dergLink();\\r\\n\\t\\t/* if(this._link==\\\"null\\\"){\\r\\n\\t\\t\\tthis.material\\r\\n\\t\\t} */\\r\\n\\r\\n\\t},\\r\\n\\tget link () {\\r\\n\\t\\treturn this._link;\\r\\n\\t},\\r\\n\\r\\n\\tset shadRotZ (v) {\\r\\n\\t\\tif (this._shadRotZ === v) return;\\r\\n\\t\\tthis._shadRotZ = v;\\r\\n\\t\\tif (this.mesh != undefined) {\\r\\n\\t\\t\\tthis.cont3d1.rotation.y = this._shadRotZ;\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\tget shadRotZ () {\\r\\n\\t\\treturn this._shadRotZ;\\r\\n\\t},\\r\\n\\r\\n\\tset rotZ (v) {\\r\\n\\t\\tif (this._rotZ === v) return;\\r\\n\\t\\tthis._rotZ = v;\\r\\n\\t\\tif (this.mesh != undefined) {\\r\\n\\t\\t\\tthis.mesh.rotation.y = this._rotZ;\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\tget rotZ () {\\r\\n\\t\\treturn this._rotZ;\\r\\n\\t},\\r\\n\\r\\n\\tset color (v) {\\r\\n\\t\\tif (this._color === v) return;\\r\\n\\t\\tthis._color = v;\\r\\n\\t\\tthis.init();\\r\\n\\t\\tvar c = this._color;\\r\\n\\t\\tif (typeof c === 'string') {\\r\\n\\t\\t\\tif (c.indexOf('x') != -1) {\\r\\n\\t\\t\\t\\tvar a = c.split('x');\\r\\n\\t\\t\\t\\tc = '#' + a[1];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tthis.material.color = new THREE.Color(c);\\r\\n\\r\\n\\t},\\r\\n\\tget color () {\\r\\n\\t\\treturn this._color;\\r\\n\\t}\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./src/libMy/visi3D/MSky.js?\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('\\n// EXTERNAL MODULE: ./src/libMy/visi3D/MVisi3D.js\\nvar MVisi3D = __webpack_require__(0);\\n\\n// CONCATENATED MODULE: ./src/larvij/menuDiv/MenuDiv.js\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass MenuDiv  {\\r\\n  \\tconstructor(glaf) {  \\t\\t\\r\\n  \\t\\tthis.type=\"MenuDiv\";\\r\\n  \\t\\tvar self=this;\\r\\n\\r\\n\\r\\n  \\t\\t\\r\\n        this.dCont=new DCont(glaf.dCont);\\r\\n        \\r\\n        this.verhH=50;\\r\\n        this.widthBig=glaf.widthBig;\\r\\n        this.otstup=glaf.otstup;\\r\\n\\r\\n\\r\\n        this._sahMenu=glaf._sahMenu;\\r\\n\\r\\n\\r\\n\\r\\n        this.panel = new DPanel(this.dCont,0,0);\\r\\n        this.panel.height=this.verhH;\\r\\n\\r\\n        this.array=[];\\r\\n\\r\\n        this.down=function(){\\r\\n            if(this.idArr==0){\\r\\n                document.location.href = \"https://www.google.com/\";\\r\\n                return;\\r\\n            }\\r\\n            if(this.idArr==1){\\r\\n                glaf.sahMenu=0;\\r\\n                return;\\r\\n            }\\r\\n            if(this.idArr==2){\\r\\n                glaf.sahMenu=1;\\r\\n                return;\\r\\n            }\\r\\n\\r\\n        }\\r\\n        var w=this.widthBig-this.otstup*2\\r\\n        for (var i = 0; i < 4; i++) {\\r\\n            this.array[i]=new DButton(this.panel, this.otstup+(w+this.otstup)*i,this.otstup,\" \",this.down)\\r\\n            this.array[i].width=w;\\r\\n            this.array[i].height=this.verhH-this.otstup*2;\\r\\n            this.array[i].idArr=i\\r\\n\\r\\n        }\\r\\n        this.array[0].loadImeg(\"resources/image/pic1.png\");\\r\\n        this.array[1].text=\"ПЛАН\";\\r\\n        this.array[2].text=\"ОБЬЕКТЫ\";\\r\\n        this.array[3].text=\"КУПИТЬ\";\\r\\n        this.array[1].alpha=0.7;        \\r\\n\\r\\n        \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n  \\t\\tthis.sizeWindow = function(w,h){    \\t\\t\\t\\r\\n  \\t\\t    this.panel.width=w;\\r\\n            this.array[3].x=w-this.otstup-this.array[3].width;\\r\\n  \\t\\t}  \\t\\t\\t\\r\\n  \\t}\\r\\n\\r\\n\\r\\n    set sahMenu(value) {\\r\\n        if(this._sahMenu!=value){\\r\\n            this._sahMenu = value;\\r\\n            if(this._sahMenu==0){\\r\\n                this.array[1].alpha=0.7;   \\r\\n                this.array[2].alpha=1;   \\r\\n            }else{\\r\\n                this.array[1].alpha=1; \\r\\n                this.array[2].alpha=0.7;   \\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    get sahMenu() { return  this._sahMenu;}\\r\\n\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/menuDiv/Galleres.js\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass Galleres  {\\r\\n  \\tconstructor(glaf) {  \\t\\t\\r\\n  \\t\\tthis.type=\"Galleres\";\\r\\n  \\t\\tvar self=this;\\r\\n\\r\\n\\r\\n  \\t\\tthis.dC=new DCont(glaf.dCont);\\r\\n        this.dCont=new DCont();\\r\\n\\r\\n\\r\\n        this._colorBool=false;\\r\\n\\r\\n\\r\\n         \\r\\n        this.verhH=50;\\r\\n        this.dC.y=this.verhH\\r\\n        this.widthBig=glaf.widthBig;\\r\\n        this.otstup=glaf.otstup;\\r\\n        this._sahMenu=glaf._sahMenu;\\r\\n\\r\\n        this._index = -1;\\r\\n        this.object=null;\\r\\n        this.objectBase=glaf.main.objectBase;\\r\\n       \\r\\n\\r\\n        this._width=100\\r\\n        this._height=100\\r\\n\\r\\n       // this.panel = new DPanel(this.dCont,0,0);\\r\\n        this.array=undefined\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        this.down=function(){            \\r\\n            if(this.idArr==0){\\r\\n                self.index=this.index;\\r\\n            }\\r\\n\\r\\n        }\\r\\n\\r\\n        this.wh0=40 \\r\\n\\r\\n        this.init=function(){\\r\\n            if(this.array!=undefined)return;\\r\\n            this.array=[]\\r\\n            for (var i = 0; i < 3; i++) {\\r\\n                this.array[i]=new GalleryXZ(this.dCont,0,0,this.down)\\r\\n                this.array[i].idArr=i;\\r\\n            }\\r\\n            //0 главная ветка\\r\\n            var a=this.objectBase.array[0].array;                        \\r\\n            this.array[0].start(a);\\r\\n            this.array[0].kolII=1;\\r\\n            this.array[0].widthPic=this.wh0;\\r\\n            this.array[0].heightPic=this.wh0;\\r\\n            this.array[0].width=this.otstup*2+this.wh0;\\r\\n            this.array[0].height=this.otstup+(this.wh0+this.otstup)*a.length;\\r\\n            this.array[0].panelBool = true;\\r\\n            this.array[0].x=this.otstup+this.widthBig\\r\\n            this.array[0].y=this.otstup;\\r\\n\\r\\n            //1 подветка\\r\\n            this.array[1].kolII=1;\\r\\n            this.array[1].widthPic=this.widthBig-this.otstup*3;\\r\\n            this.array[1].heightPic=this.widthBig-this.otstup*3;\\r\\n            this.array[1].width=this.widthBig-this.otstup;\\r\\n            this.array[1].height=this.widthBig;\\r\\n            this.array[1].panelBool = true;\\r\\n            this.array[1].x=this.otstup;\\r\\n            this.array[1].y=this.otstup+100;\\r\\n            this.array[1].boolPositScrol=false\\r\\n            this.array[1].scrollBarV.alpha=0.5\\r\\n\\r\\n            //2 цвет\\r\\n            var a=this.objectBase.array[1].array;                        \\r\\n            this.array[2].start(a);\\r\\n            this.array[2].kolII=2;\\r\\n            this.array[2].widthPic=64-this.otstup/2;\\r\\n            this.array[2].heightPic=64-this.otstup/2;\\r\\n            this.array[2].width=this.widthBig-this.otstup;\\r\\n            this.array[2].height=64+this.otstup*1.5;\\r\\n            this.array[2].panelBool = true;\\r\\n            this.array[2].x=this.otstup;\\r\\n            this.array[2].y=this.otstup;\\r\\n            this.index=0;\\r\\n        }\\r\\n\\r\\n        \\r\\n\\r\\n        this.reDrag = function(){  \\r\\n            if(this._colorBool==true){\\r\\n                this.array[2].visible=true;\\r\\n                this.array[1].y=this.array[2].y+this.array[2].height+this.otstup;\\r\\n            }else{\\r\\n                this.array[2].visible=false;\\r\\n                this.array[1].y=this.array[2].y;\\r\\n            }\\r\\n\\r\\n            var hh=this._height-this.verhH-this.array[1].y-this.otstup;\\r\\n            if(hh>this.array[1].scrollBarV.heightContent)hh=this.array[1].scrollBarV.heightContent\\r\\n            this.array[1].height=hh;\\r\\n        }\\r\\n\\r\\n  \\t\\tthis.sizeWindow = function(w,h){  \\r\\n         \\tthis._width=w;\\r\\n            this._height=h;\\t\\t\\r\\n  \\t\\t    if(this._sahMenu==0)return;\\r\\n            this.reDrag();\\r\\n\\t\\t}  \\t\\t\\t\\r\\n  \\t}\\r\\n\\r\\n\\r\\n    set colorBool(value) {\\r\\n        if(this._colorBool!=value){\\r\\n            this._colorBool = value;\\r\\n            this.reDrag();\\r\\n        }\\r\\n    }\\r\\n    get colorBool() { return  this._colorBool;}\\r\\n\\r\\n\\r\\n    set index(value) {\\r\\n        if(this._index!=value){\\r\\n            this._index = value;\\r\\n            //this._index = -1;\\r\\n            this.object=null;\\r\\n            for (var i = 0; i < this.objectBase.array[0].array.length; i++) {\\r\\n                if(i==this._index){\\r\\n                    this.object=this.objectBase.array[0].array[i]\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            this.array[0].index=this._index;\\r\\n            if(this.object==null){\\r\\n                this.array[1].visible=false;                \\r\\n            }else{\\r\\n                this.array[1].visible=true;  \\r\\n                this.array[1].start(this.object.array)\\r\\n                if(this.object.colorBool!=undefined){\\r\\n                    this._colorBool = this.object.colorBool;\\r\\n                }\\r\\n            }            \\r\\n            this.reDrag();\\r\\n        }\\r\\n    }\\r\\n    get index() { return  this._index;}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    set sahMenu(value) {\\r\\n        if(this._sahMenu!=value){\\r\\n            this._sahMenu = value;\\r\\n            if(this._sahMenu==1){\\r\\n                this.dC.add(this.dCont);\\r\\n                this.init();\\r\\n                this.sizeWindow(this._width, this._height)\\r\\n            }else{\\r\\n                this.dC.remove(this.dCont);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    get sahMenu() { return  this._sahMenu;}\\r\\n}\\r\\n\\r\\n\\r\\nclass GalleryXZ extends DGallery {\\r\\n    constructor(dCont, x, y, fun) { \\r\\n        super();         \\r\\n        this.type=\"GalleryXZ\";\\r\\n        if(dCont!=undefined)if(dCont.add!=undefined)dCont.add(this);\\r\\n        var self=this;\\r\\n        this.fun=fun\\r\\n        // Функция клика по иконке\\r\\n        this.downBtn = function () {\\r\\n            \\r\\n            self.index = this.idArr;\\r\\n            self.obj = self.array[this.idArr].object;\\r\\n            if (self.fun) self.fun();\\r\\n        };\\r\\n\\r\\n\\r\\n\\r\\n        this.createZamen=function(){            \\r\\n            var r=new BoxXZ(this.content, 0, 0, this.downBtn);            \\r\\n            return r\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/*export class BoxXZ extends DBox {\\r\\n    constructor(dCont, x, y, fun) { \\r\\n        super(); \\r\\n        trace(\"@@@4444\");        \\r\\n        this.type=\"BoxXZ\";\\r\\n\\r\\n        this.startLoad = function (_obj) {\\r\\n            this.object = _obj;\\r\\n\\r\\n            trace(_obj)\\r\\n            if (_obj.src) {\\r\\n                this.image.visible = true;\\r\\n\\r\\n                if (this.image.link == _obj.src) {\\r\\n                    if (self.funLoad) self.funLoad();\\r\\n                } else {\\r\\n                    this.image.width = 100;\\r\\n                    this.image.height = 100;\\r\\n                    this.image.link = _obj.src;\\r\\n                }\\r\\n            }else{\\r\\n                if (self.funLoad) self.funLoad();\\r\\n            }\\r\\n            this.draw();\\r\\n        };\\r\\n    }\\r\\n}*/\\r\\n\\r\\n\\r\\n\\r\\nfunction BoxXZ(_cont, _x, _y, _fun) {\\r\\n    DCont.call(this);\\r\\n    this.type = \\'BoxXZ\\';\\r\\n    var self = this;\\r\\n    _cont.add(this);\\r\\n\\r\\n    this.x = _x || 0;\\r\\n    this.y = _y || 0;\\r\\n    this.fun = _fun;\\r\\n\\r\\n\\r\\n    this._link = \\'\\';\\r\\n    this._title = \\'\\';\\r\\n    this._width = 100;\\r\\n    this._height = 100;\\r\\n    this._otstup = 2;\\r\\n    this.clearIndex = true;\\r\\n\\r\\n    this._object = null;\\r\\n\\r\\n\\r\\n    this._activ = false;\\r\\n\\r\\n    this.idArr = -1;\\r\\n    this.idArrKesh = -1;\\r\\n    this.id = -1;\\r\\n    this.funLoad;\\r\\n\\r\\n    this.postDraw;\\r\\n    this.funOver;\\r\\n    this.funOut;\\r\\n\\r\\n    this.content = new DCont();\\r\\n    this.add(this.content);\\r\\n\\r\\n    this.panel = new DPanel(this.content, 0, 0);\\r\\n\\r\\n\\r\\n    this.image = new DImage(this.content, 0, 0, undefined, function () {\\r\\n    \\r\\n        self.draw();\\r\\n        if (self.funLoad) self.funLoad();\\r\\n    });\\r\\n\\r\\n    this.label = new DLabel(this.content, 0, 0, \\'|\\');\\r\\n\\r\\n    //this.image._preloaderBool = true;\\r\\n    this.image.visible = false;\\r\\n    this.label.visible = false;\\r\\n\\r\\n\\r\\n\\r\\n    /*this.graphics = new PIXI.Graphics();\\r\\n    this.content.addChild(this.graphics);*/\\r\\n\\r\\n    this.object;\\r\\n    this._color = \"#ffffff\";\\r\\n    this._color1 = \"#ff0000\";\\r\\n    this._lineSize = 2;\\r\\n    this.boolOut = true;\\r\\n\\r\\n    var ss;\\r\\n    // Отрисовка и позиционирование иконки, обводки\\r\\n    this.draw = function () {\\r\\n        /*this.graphics.clear();\\r\\n        if (this.boolOut == true) this.graphics.beginFill(0xffffff, 0);\\r\\n        else this.graphics.beginFill(0xffffff, 0.2);\\r\\n        this.graphics.drawRect(0, 0, this._width, this._height);\\r\\n        this.graphics.endFill();\\r\\n        if (this._activ == true) {\\r\\n            this.graphics.lineStyle(this._lineSize, this._color, 1);\\r\\n            this.graphics.drawRect(this._lineSize / 2, this._lineSize / 2, this._width - this._lineSize, this._height - this._lineSize);\\r\\n            this.graphics.endFill();\\r\\n        }*/\\r\\n\\r\\n        ss = (this._width - this._otstup * 2) / this.image.picWidth;\\r\\n        if (ss > (this._height - this._otstup * 2) / this.image.picHeight)ss = (this._height - this._otstup * 2) / this.image.picHeight;\\r\\n        //this.image.scale = ss;\\r\\n        //this.image.scale = 0.1;\\r\\n        //this.image.scale.y = ss;\\r\\n        \\r\\n        this.image.x = 0;\\r\\n        this.image.width=this.image.picWidth*ss;\\r\\n        this.image.height=this.image.picHeight*ss;\\r\\n\\r\\n        this.image.x = (this._width - this.image.picWidth * ss) / 2;\\r\\n        this.image.y = (this._height - this.image.picHeight * ss) / 2;\\r\\n\\r\\n        this.label.x = (this._width - this.label.curW) / 2;\\r\\n        this.label.y = this._height - this.label.curH - this._otstup;\\r\\n        if (this.postDraw) this.postDraw();\\r\\n    };\\r\\n\\r\\n    this.isObj = function (_obj) {\\r\\n        if (this.object != undefined) {\\r\\n            if (_obj != undefined) {\\r\\n                if (_obj.link != undefined) {\\r\\n                    if (this.object.link != undefined) {\\r\\n                        if (this.object.link == _obj.link) {\\r\\n                            return true;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    };\\r\\n    this.doLink=\"resources/data/\"\\r\\n    var b;\\r\\n    // Добавление картинки и текста, пошаговая загрузка.\\r\\n    this.startLoad = function (_obj) {\\r\\n        this.object = _obj;\\r\\n        var link=this.doLink+_obj.id+\"/icon.png\"\\r\\n       \\r\\n      \\r\\n       \\r\\n        this.image.visible = true;\\r\\n        if (this.image.link == link) {\\r\\n            if (self.funLoad) self.funLoad();\\r\\n        } else {\\r\\n            this.image.width = 100;\\r\\n            this.image.height = 100;\\r\\n            this.image.link = link;\\r\\n        }\\r\\n       \\r\\n        this.draw();\\r\\n    };\\r\\n    // Очистка\\r\\n    this.clear = function () {\\r\\n        this.visible = false;\\r\\n        this.label.visible = false;\\r\\n        this.image.visible = false;\\r\\n        if (this.clearIndex) {\\r\\n            this.activ = false;\\r\\n        }\\r\\n\\r\\n    };\\r\\n    this.funOver;\\r\\n    this.funOut;\\r\\n    // События\\r\\n    this.mouseOver = function (e) {\\r\\n        self.boolOut = false;\\r\\n        if(self._activ==false)self.panel.color1=dcmParam.compToHexArray(dcmParam.hexDec(self._color1), -30);\\r\\n        else self.panel.color1=dcmParam.compToHexArray(dcmParam.hexDec(self._color), -30);\\r\\n        if (self.funOver) self.funOver(this);\\r\\n    };\\r\\n    this.mouseOut = function (e) {      \\r\\n        \\r\\n        if(self._activ==false)self.panel.color1=self._color1;\\r\\n        else self.panel.color1=self._color;\\r\\n        \\r\\n        if (self.funOut) self.funOut(this);\\r\\n    };\\r\\n    this.mouseDown = function (e) {     \\r\\n        if (self.fun) self.fun();\\r\\n    };\\r\\n    this.draw();\\r\\n\\r\\n\\r\\n    this.panel.div.addEventListener(\"mouseout\", this.mouseOut);\\r\\n    this.image.image.addEventListener(\"mouseout\", this.mouseOut);\\r\\n\\r\\n    this.panel.div.addEventListener(\"mouseover\", this.mouseOver);\\r\\n    this.image.image.addEventListener(\"mouseover\", this.mouseOver);\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    this.image.image.addEventListener(\"mousedown\", this.mouseDown)\\r\\n    this.panel.div.addEventListener(\"mousedown\", this.mouseDown)\\r\\n\\r\\n    /*\\r\\n\\r\\n    this.upBody=function(e){\\r\\n            document.removeEventListener(\"mousedown\", self.upBody)\\r\\n            self.openBool=false;\\r\\n            boolOp=false\\r\\n            setTimeout(function() {\\r\\n                boolOp=true\\r\\n            }, 100);\\r\\n        }\\r\\n\\r\\n        this.image.image.addEventListener(\"mouseout\", function(){\\r\\n            self.color=cOld;            \\r\\n        })\\r\\n\\r\\n        var _x,_xx, a, c, cOld\\r\\n        this.image.image.addEventListener(\"mousemove\", function(e){         \\r\\n            _x=Math.round((e.layerX/self.image.width)*dcmParam.bmp.width)\\r\\n            if(_x>dcmParam.bmp.width)_x=dcmParam.bmp.width;\\r\\n            _y=Math.round((e.layerY/self.image.height)*dcmParam.bmp.height)\\r\\n            if(_y>dcmParam.bmp.height)_y=dcmParam.bmp.height;\\r\\n            a= dcmParam.bmp.getPixel(_x, _y);\\r\\n            c= dcmParam.compToHexArray(a);          \\r\\n            self.color=c;\\r\\n            if(self.fun_mousemove){\\r\\n                self.fun_mousemove()\\r\\n            }\\r\\n        })\\r\\n        this.image.image.addEventListener(\"mousedown\", function(e){ \\r\\n\\r\\n\\r\\n\\r\\n    this.graphics.interactive = true;\\r\\n    this.graphics.buttonMode = true;\\r\\n    this.graphics.on(\\'mouseover\\', this.mouseOver);\\r\\n    this.graphics.on(\\'mouseout\\', this.mouseOut);\\r\\n    this.graphics.on(\\'mousedown\\', this.mouseDown);*/\\r\\n\\r\\n\\r\\n}\\r\\nBoxXZ.prototype = Object.create(DCont.prototype);\\r\\nBoxXZ.prototype.constructor = BoxXZ;\\r\\nObject.defineProperties(BoxXZ.prototype, {\\r\\n    activ: { // активный элемент\\r\\n        set: function (value) {\\r\\n            if (this._activ == value) return;\\r\\n            this._activ = value;\\r\\n            if(this._activ==false)this.panel.color1=this._color1;\\r\\n            else this.panel.color1=this._color;\\r\\n\\r\\n        },\\r\\n        get: function () {\\r\\n            return this._activ;\\r\\n        }\\r\\n    },\\r\\n    color: { // цвет обводки\\r\\n        set: function (value) {\\r\\n            if (this._color == value) return;\\r\\n            this._color = value;\\r\\n            this.draw();\\r\\n\\r\\n        },\\r\\n        get: function () {\\r\\n            return this._color;\\r\\n        }\\r\\n    },  \\r\\n    color1: { // цвет актива\\r\\n        set: function (value) {\\r\\n            if (this._color1 == value) return;\\r\\n            this._color1 = value;\\r\\n            \\r\\n        },\\r\\n        get: function () {\\r\\n            return this._color1;\\r\\n        }\\r\\n    },\\r\\n    lineSize: { // ширина обводки\\r\\n        set: function (value) {\\r\\n            if (this._lineSize == value) return;\\r\\n            this._lineSize = value;\\r\\n            this.draw();\\r\\n\\r\\n        },\\r\\n        get: function () {\\r\\n            return this._lineSize;\\r\\n        }\\r\\n    },\\r\\n    otstup: { // Отступ\\r\\n        set: function (value) {\\r\\n            if (this._otstup == value) return;\\r\\n            this._otstup = value;\\r\\n            this.draw();\\r\\n        },\\r\\n        get: function () {\\r\\n            return this._otstup;\\r\\n        }\\r\\n    },\\r\\n    width: { // ширина элемента\\r\\n        set: function (value) {\\r\\n            if (this._width == value) return;\\r\\n            this._width = value;\\r\\n            this.panel.width = this._width;\\r\\n            this.draw();\\r\\n        },\\r\\n        get: function () {\\r\\n            return this._width;\\r\\n        }\\r\\n    },\\r\\n    height: { // высота элемента\\r\\n        set: function (value) {\\r\\n            if (this._height == value) return;\\r\\n            this._height = value;\\r\\n            this.panel.height = this._height;\\r\\n            this.draw();\\r\\n        },\\r\\n        get: function () {\\r\\n            return this._height;\\r\\n        }\\r\\n    }\\r\\n});\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/scane2d/menu/MunuStart.js\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass MunuStart  {\\r\\n  \\tconstructor(scane2d, fun) {  \\t\\t\\r\\n  \\t\\tthis.type=\"MunuStart\";\\r\\n  \\t\\tvar self=this;\\r\\n        this.wh=32\\r\\n        this.scane2d=scane2d\\r\\n        this._active=false;\\r\\n  \\t\\tthis.content=new PIXI.Container();\\r\\n        this.content.visible=false\\r\\n  \\t\\tscane2d.content.addChild(this.content);        \\r\\n  \\t\\tthis.dCont=new DCont();\\r\\n\\r\\n        this._width=100;\\r\\n        this._height=100;\\r\\n        this.verhH=50;\\r\\n\\r\\n        this._sahMenu=0;\\r\\n\\r\\n        this.panel;\\r\\n        this.dC;\\r\\n        this.init=function(){\\r\\n            if(this.dC!=undefined)return\\r\\n            /*this.panel=new PLPanel(this.content, 0, this.verhH)\\r\\n            this.panel.color=0x79bccc;*/\\r\\n\\r\\n            \\r\\n\\r\\n            this.dC=new DCont(this.dCont);\\r\\n            this.dC.div.style.textAlign = \\'center\\';\\r\\n            this.label=new DLabel(this.dC, 0, 0,lMain.objectBase.arrText[0].ru);\\r\\n            this.label.colorText1=dcmParam.colorText\\r\\n\\r\\n            this.button=new DButton(this.dCont, 0, 0,\"Далее\", function(){\\r\\n                fun()\\r\\n            });\\r\\n\\r\\n        }\\r\\n       \\r\\n\\r\\n\\r\\n        this.dragSah=function(){\\r\\n            if(this._sahMenu==0){\\r\\n                this.active=true;                \\r\\n            }else{\\r\\n                this.active=false; \\r\\n            }\\r\\n        }\\r\\n\\r\\n        \\r\\n  \\t\\tthis.sizeWindow = function(w,h){  \\t\\t\\t\\r\\n            this._width=w;\\r\\n\\t\\t\\tthis._height=h;\\r\\n            if(this._active==false)return;            \\r\\n            //this.panel.width=this._width;\\r\\n           // this.panel.height=h-this.verhH;        \\r\\n            this.label.width=this._width;\\r\\n            this.dC.width=this._width;\\r\\n            this.button.x=(this._width-this.button.width)/2;\\r\\n            this.button.y=this._height-this.button.height-this.wh;\\r\\n            this.dC.y=this.button.y-this.label.div.clientHeight-this.wh;\\r\\n  \\t\\t}  \\t\\t\\t\\r\\n  \\t}\\r\\n\\r\\n\\r\\n    set active(value) {\\r\\n        if(this._active!=value){\\r\\n            this._active = value;\\r\\n            if(this._active==true){\\r\\n                this.init()\\r\\n                this.scane2d.dCont.add(this.dCont);\\r\\n                this.content.visible=true;\\r\\n                this.sizeWindow(this._width,this._height)\\r\\n            }else{\\r\\n                this.scane2d.dCont.remove(this.dCont);\\r\\n                this.content.visible=false;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    get active() { return  this._active;}\\r\\n\\r\\n    set sahMenu(value) {\\r\\n        if(this._sahMenu!=value){\\r\\n            this._sahMenu = value;\\r\\n            this.dragSah()\\r\\n        }\\r\\n    }\\r\\n    get sahMenu() { return  this._sahMenu;}\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/scane2d/Stens.js\\n\\r\\n\\r\\nclass Stens  {\\r\\n    constructor(scane2d, fun) {      \\r\\n        this.type=\"Stens\";\\r\\n        var self=this;\\r\\n        this.scane2d=scane2d\\r\\n        this._active=false;\\r\\n        this.content=new PIXI.Container();\\r\\n        this.content.visible=false;\\r\\n        scane2d.content.addChild(this.content);        \\r\\n        this.dCont=new DCont();\\r\\n\\r\\n        this._width=100;\\r\\n        this._height=100;\\r\\n        this._index=-1;\\r\\n        this._sahMenu=0;\\r\\n      \\r\\n        this.bl=false;\\r\\n\\r\\n        this.array=[]\\r\\n        this._wh=20\\r\\n        this.widthBig=scane2d.glaf.widthBig;\\r\\n        this.otstup=scane2d.glaf.otstup;\\r\\n\\r\\n        \\r\\n        this.rectangle=new Rectangle(0,0,500,500);\\r\\n        this.p=new PLPanel(this.content)\\r\\n        this.p.alpha=0.2\\r\\n\\r\\n\\r\\n        this.contS = new PIXI.Container();\\r\\n        this.content.addChild(this.contS)        \\r\\n        \\r\\n\\r\\n\\r\\n        \\r\\n        this.rulit=new Rulit(this, scane2d.glaf.scane3d.room.content3d,function(type, param){\\r\\n           \\r\\n            fun(type, param)\\r\\n        });\\r\\n        this.plusSten=new PlusSten(this);\\r\\n\\r\\n\\r\\n\\r\\n        this.sob=function(tip, param){            \\r\\n            self.index=param.idArr;                   \\r\\n            self.rulit.sob(tip, param);\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n        this.init=function(){\\r\\n            if(this.bl==true)return;\\r\\n            this.bl=true;\\r\\n            this.array=scane2d.glaf.scane3d.room.array;\\r\\n            this.rulit.content.addChild(this.array[0].content);\\r\\n            this.rulit.content.addChild(this.array[1].content);\\r\\n            this.rulit.content.addChild(this.array[2].content);\\r\\n           \\r\\n\\r\\n\\r\\n\\r\\n            this.array[0].rotation=-Math.PI/2;            \\r\\n            this.array[0].x=0//this.array[0].height;\\r\\n            this.array[0].y=this.array[0].width;\\r\\n\\r\\n            this.array[0].sA1=2;\\r\\n            this.array[0].active=false;\\r\\n\\r\\n            this.array[2].rotation=Math.PI/2;\\r\\n            this.array[2].x=this.array[2].width\\r\\n            this.array[2].sA=2;\\r\\n            this.array[2].active=false;\\r\\n\\r\\n\\r\\n            this.array[1].sA1=2;\\r\\n            this.array[1].sA=2;\\r\\n            this.array[1].x=0;\\r\\n            this.array[1].y=0;\\r\\n        }\\r\\n\\r\\n\\r\\n        this.redrag=function(t){\\r\\n            this.rulit.redrag(t);            \\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        \\r\\n        this.sizeWindow = function(w,h){        \\r\\n            this._width=w;\\r\\n            this._height=h;\\r\\n            if(this._active==false)return;\\r\\n\\r\\n            if(this._sahMenu==0){\\r\\n                this.rectangle.x=100;\\r\\n                this.rectangle.width=w-200;\\r\\n                this.rectangle.y=100;\\r\\n                this.rectangle.height=h-250;\\r\\n            }else{\\r\\n                var v=this.widthBig*2\\r\\n                this.rectangle.x=w-v-this.otstup-this.widthBig/2;\\r\\n                this.rectangle.width=v;\\r\\n                this.rectangle.y=h-v-this.otstup;\\r\\n                this.rectangle.height=v;\\r\\n            }\\r\\n            \\r\\n\\r\\n\\r\\n\\r\\n            this.contS.x=this.rectangle.x;\\r\\n            this.contS.y=this.rectangle.y;\\r\\n\\r\\n            this.p.x=this.rectangle.x;\\r\\n            this.p.y=this.rectangle.y;\\r\\n\\r\\n            this.p.width=this.rectangle.width;\\r\\n            this.p.height=this.rectangle.height;\\r\\n            this.redrag();\\r\\n        }       \\r\\n    }\\r\\n\\r\\n    set x(v) {this.content.x = v;} get x() { return  this.content.x;}\\r\\n    set y(v) {this.content.y = v;} get y() { return  this.content.y;}\\r\\n\\r\\n\\r\\n    set active(value) {\\r\\n        if(this._active!=value){\\r\\n            this._active = value;\\r\\n            if(this._active==true){\\r\\n                this.init()\\r\\n                this.scane2d.dCont.add(this.dCont);\\r\\n                this.content.visible=true;\\r\\n                this.sizeWindow(this._width,this._height);\\r\\n            }else{\\r\\n                this.scane2d.dCont.remove(this.dCont);\\r\\n                this.content.visible=false;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    get active() { return  this._active;}\\r\\n\\r\\n\\r\\n    set index(value) {\\r\\n        if(this._index!=value){\\r\\n            this._index = value;\\r\\n\\r\\n            for (var i = 0; i < this.array.length; i++) {\\r\\n                if(i==this._index)this.array[i].actBig=true;\\r\\n                else this.array[i].actBig=false;\\r\\n            }\\r\\n          \\r\\n        }\\r\\n    }\\r\\n    get index() { return  this._index;}\\r\\n\\r\\n    set sahMenu(value) {\\r\\n        if(this._sahMenu!=value){\\r\\n            this._sahMenu = value;\\r\\n            this.sizeWindow(this._width,this._height);\\r\\n        }\\r\\n    }\\r\\n    get sahMenu() { return  this._sahMenu;}\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nclass PlusSten{\\r\\n    constructor(par) { \\r\\n        this.type=\"PlusSten\";\\r\\n        var self=this;\\r\\n        this.content=new PIXI.Container();\\r\\n        par.contS.addChild(this.content);\\r\\n        this.dCont=new DCont();\\r\\n       \\r\\n        par.dCont.add(this.dCont)\\r\\n\\r\\n\\r\\n        this.wh=30;\\r\\n        this.whOtstup=70;\\r\\n\\r\\n        this._scale=1\\r\\n\\r\\n        this.abcd=[\\r\\n            new BoxABS(this.content,\"A\",0,0),\\r\\n            new BoxABS(this.content,\"B\",0,0),\\r\\n            new BoxABS(this.content,\"C\",0,0),\\r\\n            new BoxABS(this.content,\"D\",0,0)\\r\\n        ];\\r\\n        this.aPosition=[\\r\\n            new Position(),\\r\\n            new Position(),\\r\\n            new Position(),\\r\\n            new Position()\\r\\n        ];\\r\\n\\r\\n\\r\\n        this.onDownB=function(s,p){\\r\\n            trace(this.yy,this.xx)\\r\\n\\r\\n            \\r\\n            if(s==\"start\"){\\r\\n                par.array[0].savePozot();\\r\\n                par.array[2].savePozot();\\r\\n                xyGlob=par.rulit.content.toGlobal(pointNull); \\r\\n            }\\r\\n            if(s==\"drag\"){   \\r\\n                if(this.idArr==0){            \\r\\n                    par.array[0].width=par.array[0].pointOld.w+this.yy/self._scale//   par.array[0].x-par.array[1].x;\\r\\n                    par.array[0].y=par.array[0].width;\\r\\n                    self.aButt[0].y=xyGlob.y+par.array[0].y*self._scale-par.array[0].depth*self._scale;\\r\\n                }\\r\\n               if(this.idArr==2){            \\r\\n                    par.array[2].width=par.array[2].pointOld.w+this.yy/self._scale//   par.array[0].x-par.array[1].x;\\r\\n                    //par.array[0].y=par.array[0].width;\\r\\n                    self.aButt[2].y=xyGlob.y+par.array[2].width*self._scale-par.array[2].depth*self._scale;\\r\\n                }\\r\\n                self.redrahWH()\\r\\n            }\\r\\n            if(s==\"up\"){\\r\\n                par.rulit.redrag(500)\\r\\n            } \\r\\n            \\r\\n        }\\r\\n\\r\\n        this.aButt=[\\r\\n            new DBUtC(this.dCont,0,0,\" \",this.onDownB),\\r\\n            null,\\r\\n            new DBUtC(this.dCont,0,0,\" \",this.onDownB)\\r\\n        ];\\r\\n        this.aButt[0].idArr=0\\r\\n        this.aButt[2].idArr=2\\r\\n        this.aButt[0].alpha=0.5\\r\\n        this.aButt[2].alpha=0.5\\r\\n\\r\\n        this.arrBoxLabel=[];\\r\\n\\r\\n        var sah=0;\\r\\n        var xyGlob=new PIXI.Point()\\r\\n        var pointNull=new PIXI.Point(0,0)\\r\\n        this.redrahWH=function(){\\r\\n           \\r\\n            this.aPosition[0].x=par.rulit.content.x+par.array[0].x*this._scale;\\r\\n            this.aPosition[0].y=par.rulit.content.y+par.array[0].width*this._scale+par.array[1].y*this._scale;\\r\\n\\r\\n            this.aPosition[1].x=par.rulit.content.x+par.array[1].x*this._scale;\\r\\n            this.aPosition[1].y=par.rulit.content.y+par.array[1].y*this._scale;\\r\\n\\r\\n            this.aPosition[2].x=par.rulit.content.x+par.array[1].x*this._scale+par.array[1].width*this._scale;\\r\\n            this.aPosition[2].y=par.rulit.content.y+par.array[1].y*this._scale;\\r\\n\\r\\n            this.aPosition[3].x=par.rulit.content.x+par.array[0].x*this._scale+par.array[1].width*this._scale;\\r\\n            this.aPosition[3].y=par.rulit.content.y+par.array[2].width*this._scale+par.array[2].y*this._scale;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n            sah=0; \\r\\n            if(par.array[0].active==true){\\r\\n                this.abcd[0].x=this.aPosition[0].x;\\r\\n                this.abcd[0].y=this.aPosition[0].y;\\r\\n                this.abcd[0].xx=-this.wh;\\r\\n                this.abcd[0].yy=0;\\r\\n\\r\\n                this.abcd[1].x=this.aPosition[1].x;\\r\\n                this.abcd[1].y=this.aPosition[1].y;\\r\\n                this.abcd[1].xx=-this.wh;\\r\\n                this.abcd[1].yy=-this.wh;\\r\\n\\r\\n                this.abcd[2].x=this.aPosition[2].x;\\r\\n                this.abcd[2].y=this.aPosition[2].y;\\r\\n                this.abcd[2].content.visible=true;\\r\\n                this.abcd[2].xx=this.wh;\\r\\n                this.abcd[2].yy=-this.wh;\\r\\n\\r\\n                if(par.array[2].active){\\r\\n                    this.abcd[3].x=this.aPosition[3].x;\\r\\n                    this.abcd[3].y=this.aPosition[3].y;\\r\\n                    this.abcd[3].content.visible=true;\\r\\n                    this.abcd[3].xx=this.wh;\\r\\n                    this.abcd[3].yy=0;\\r\\n                }else{\\r\\n                    this.abcd[3].content.visible=false; \\r\\n                }\\r\\n            }else{\\r\\n                this.abcd[3].content.visible=false;\\r\\n\\r\\n                this.abcd[0].x=this.aPosition[1].x;\\r\\n                this.abcd[0].y=this.aPosition[1].y;\\r\\n                this.abcd[0].xx=-this.wh;\\r\\n                this.abcd[0].yy=-this.wh;\\r\\n\\r\\n                this.abcd[1].x=this.aPosition[2].x;\\r\\n                this.abcd[1].y=this.aPosition[2].y;          \\r\\n                this.abcd[1].xx=this.wh;\\r\\n                this.abcd[1].yy=-this.wh; \\r\\n\\r\\n                if(par.array[2].active){\\r\\n                    this.abcd[2].x=this.aPosition[3].x;\\r\\n                    this.abcd[2].y=this.aPosition[3].y;\\r\\n                    this.abcd[2].content.visible=true;\\r\\n                    this.abcd[2].xx=this.wh;\\r\\n                    this.abcd[2].yy=0;\\r\\n                }else{\\r\\n                    this.abcd[2].content.visible=false; \\r\\n                }\\r\\n            }\\r\\n           \\r\\n            xyGlob=par.rulit.content.toGlobal(pointNull); \\r\\n\\r\\n            \\r\\n            this.arrBoxLabel[0].active=par.array[0].active\\r\\n            this.aButt[0].visible=par.array[0].active\\r\\n            if(par.array[0].active==true){\\r\\n                this.arrBoxLabel[0].value=(par.array[0].width)\\r\\n                this.arrBoxLabel[0].x=xyGlob.x+par.array[1].x*this._scale-this.whOtstup;\\r\\n                this.arrBoxLabel[0].y=xyGlob.y+par.array[1].y*this._scale+(this.arrBoxLabel[0].value*this._scale)/2; \\r\\n                this.arrBoxLabel[0].actBig= par.array[0].actBig;  \\r\\n\\r\\n                this.aButt[0].x=xyGlob.x+par.array[0].x*this._scale-par.array[0].depth*this._scale;;\\r\\n                this.aButt[0].width=par.array[0].depth*this._scale;\\r\\n                this.aButt[0].y=xyGlob.y+par.array[0].y*this._scale-par.array[0].depth*this._scale;\\r\\n                this.aButt[0].height=par.array[0].depth*this._scale;\\r\\n            }\\r\\n           \\r\\n\\r\\n            this.arrBoxLabel[1].active=par.array[1].active\\r\\n            if(par.array[1].active==true){\\r\\n                this.arrBoxLabel[1].value=(par.array[1].width)\\r\\n                this.arrBoxLabel[1].x=xyGlob.x+par.array[1].x*this._scale+(this.arrBoxLabel[1].value*this._scale)/2; \\r\\n                this.arrBoxLabel[1].y=xyGlob.y+par.array[1].y*this._scale-this.wh*1.5;\\r\\n                this.arrBoxLabel[1].actBig= par.array[1].actBig;                            \\r\\n            }\\r\\n\\r\\n            this.arrBoxLabel[2].active=par.array[2].active\\r\\n            this.aButt[2].visible=par.array[2].active\\r\\n            if(par.array[2].active==true){\\r\\n                this.arrBoxLabel[2].value=(par.array[2].width)\\r\\n                this.arrBoxLabel[2].x=xyGlob.x+par.array[2].x*this._scale+this.whOtstup;\\r\\n                this.arrBoxLabel[2].y=xyGlob.y+par.array[2].y*this._scale+(this.arrBoxLabel[2].value*this._scale)/2; \\r\\n                this.arrBoxLabel[2].actBig= par.array[2].actBig;    \\r\\n\\r\\n\\r\\n                this.aButt[2].x=xyGlob.x+par.array[2].x*this._scale//-par.array[2].depth*this._scale;;\\r\\n                this.aButt[2].width=par.array[2].depth*this._scale;\\r\\n                this.aButt[2].y=xyGlob.y+par.array[2].y*this._scale+par.array[2].width*this._scale-par.array[2].depth*this._scale;\\r\\n                this.aButt[2].height=par.array[2].depth*this._scale;                        \\r\\n            } \\r\\n\\r\\n\\r\\n\\r\\n        }\\r\\n\\r\\n        this.redrahXY=function(s){\\r\\n            this._scale=s;\\r\\n            this.redrahWH();\\r\\n        }\\r\\n\\r\\n        this.chenge=function(){\\r\\n            par.array[this.idArr].width=this.value+self.wh;\\r\\n            par.rulit.redrag(500);\\r\\n        }\\r\\n\\r\\n        for (var i = 0; i < 3; i++) {\\r\\n            this.arrBoxLabel[i]=new BoxLabel(this.dCont, this.chenge);\\r\\n            this.arrBoxLabel[i].idArr=i;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nclass BoxLabel{\\r\\n    constructor(dCont, fun) { \\r\\n        var self=this;\\r\\n        this.fun=fun;\\r\\n        this.type=\"BoxLabel\";\\r\\n        this._width=70;\\r\\n        this._height=24;\\r\\n        this._active=false\\r\\n        this._actBig=false\\r\\n\\r\\n        this.dC=dCont;\\r\\n        this._value=100;\\r\\n\\r\\n        this.dCont=new DCont();\\r\\n       /* var p=new DPanel(this.dCont,0,0)\\r\\n        p.width=10;\\r\\n        p.height=10;*/ \\r\\n\\r\\n        this.input=new DInput(this.dCont,-this._width/2,-this._height/2,this._value+\"\",function(){\\r\\n            self.value  = this.value/10;\\r\\n            self.fun()     \\r\\n            \\r\\n        })\\r\\n        this.input.width=this._width;\\r\\n        this.input.height=this._height;\\r\\n        this.input.visible=false\\r\\n        this.lD=new DCont();\\r\\n        this.dCont.add(this.lD) \\r\\n        this.lD.div.style.textAlign = \\'center\\';\\r\\n        this.lD.x=-(this._width+20)/2;\\r\\n        this.lD.y=-(this._height)/2;\\r\\n\\r\\n\\r\\n\\r\\n        this.label= new DLabel(this.lD,0,0,\"qw\")\\r\\n        this.label.width=(this._width+20)\\r\\n    }\\r\\n\\r\\n    set x(v) {this.dCont.x = v;} get x() { return  this.dCont.x;}\\r\\n    set y(v) {this.dCont.y = v;} get y() { return  this.dCont.y;}\\r\\n\\r\\n    set value(v) {\\r\\n        if(this._value!=v){\\r\\n            this._value = Math.round(v);            \\r\\n            this.input.text=\"\"+this._value*10;\\r\\n            this.label.text=\"\"+this._value*10+\" мм\";\\r\\n        }       \\r\\n    }   \\r\\n    get value() { return  this._value;}\\r\\n\\r\\n    set active(v) {\\r\\n        if(this._active!=v){\\r\\n            this._active = v;            \\r\\n            if(this._active==true){\\r\\n                this.dC.add(this.dCont);\\r\\n            }else{\\r\\n                this.dC.remove(this.dCont);\\r\\n            }\\r\\n        }       \\r\\n    }   \\r\\n    get active() { return  this._active;}\\r\\n\\r\\n   set actBig(v) {\\r\\n        if(this._actBig!=v){\\r\\n            this._actBig = v;             \\r\\n            this.input.visible=v;\\r\\n            this.label.visible=!v;           \\r\\n        }       \\r\\n    }   \\r\\n    get actBig() { return  this._actBig;}\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nclass BoxABS{\\r\\n    constructor(cont, text,_xx,_yy) { \\r\\n\\r\\n        this._xx=_xx||0;\\r\\n        this._yy=_yy||0;\\r\\n\\r\\n        this.content=new PIXI.Container();\\r\\n        cont.addChild(this.content);\\r\\n       // var p=new PLPanel(this.content,0,0)\\r\\n      //  p.width=10;\\r\\n       // p.height=10;\\r\\n        this.label=new PLLabel(this.content,-5+this._xx,-10+this._yy, text);        \\r\\n               \\r\\n    }\\r\\n\\r\\n    set x(v) {this.content.x = v;} get x() { return  this.content.x;}\\r\\n    set y(v) {this.content.y = v;} get y() { return  this.content.y;}\\r\\n\\r\\n    set xx(v) {\\r\\n        if(this._xx != v){\\r\\n            this._xx = v;\\r\\n            this.label.x=-5+this._xx;\\r\\n        }\\r\\n        \\r\\n    } \\r\\n    get xx() { \\r\\n        return  this._xx;\\r\\n    }\\r\\n\\r\\n    set yy(v) {\\r\\n        if(this._yy != v){\\r\\n            this._yy = v;\\r\\n            this.label.y=-10+this._yy;\\r\\n        }        \\r\\n    } \\r\\n    get yy() { \\r\\n        return  this._yy;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass Rulit{\\r\\n    constructor(par, cont3d, fun) {    \\r\\n\\r\\n        var self=this\\r\\n        this.cont3d=cont3d\\r\\n        this.tween = new TWEEN.Tween(this);\\r\\n        this.content=new PIXI.Container();\\r\\n        par.contS.addChild(this.content);\\r\\n        this.fun=fun\\r\\n        this.rectangle=new Rectangle(0,0,200,200);\\r\\n        this.wh=20\\r\\n        this.p1=new PLPanel(this.content);\\r\\n        this.p1.alpha=0.2;\\r\\n        this._scale=1;\\r\\n\\r\\n        var _s,_x,_y;\\r\\n\\r\\n        this.redrag=function(t){\\r\\n            \\r\\n            this.rectangle.height=par.array[0].width\\r\\n            if(this.rectangle.height<par.array[2].width)this.rectangle.height=par.array[2].width;\\r\\n            this.rectangle.width=par.array[1].width;\\r\\n\\r\\n            this.p1.width=this.rectangle.width;\\r\\n            this.p1.height=this.rectangle.height;\\r\\n\\r\\n            _s=par.rectangle.width/(this.rectangle.width+this.wh*2);            \\r\\n            if(_s>par.rectangle.height/(this.rectangle.height+this.wh*2))_s=par.rectangle.height/(this.rectangle.height+this.wh*2);\\r\\n\\r\\n            if(_s>1)_s=1;\\r\\n\\r\\n            //this.content.scale.set(this._scale,this._scale);\\r\\n            _x=(par.rectangle.width-this.rectangle.width*_s)/2;\\r\\n            _y=(par.rectangle.height-this.rectangle.height*_s)/2;\\r\\n\\r\\n            if(t==undefined){\\r\\n                this.x= _x;\\r\\n                this.y= _y;\\r\\n                this.scale= _s;\\r\\n            }else{\\r\\n                this.tween.to({ x: _x, y: _y, scale: _s}, 500);\\r\\n                this.tween.start();\\r\\n            }\\r\\n            \\r\\n        }\\r\\n\\r\\n\\r\\n        this.sten\\r\\n        this.sobTip\\r\\n        this.sob=function(tip, param){ \\r\\n            self.sten=undefined; \\r\\n            if(tip==\"onDown\"){\\r\\n                this.sten = param;\\r\\n                this.sobTip=tip;\\r\\n                this.onDragStart()               \\r\\n            }            \\r\\n        }\\r\\n\\r\\n\\r\\n        this.onDragStart = function () {\\r\\n            ppp.x=9999999999;\\r\\n            for (var i = 0; i < par.array.length; i++) {\\r\\n                par.array[i].savePozot()\\r\\n            }\\r\\n            \\r\\n\\r\\n            if (pl102.isMouseEvents) {\\r\\n                pl102.stage.off(\\'mouseup\\', self.onDragEnd);\\r\\n                pl102.stage.off(\\'mousemove\\', self.onDragMove);\\r\\n                pl102.stage.on(\\'mouseup\\', self.onDragEnd);\\r\\n                pl102.stage.on(\\'mousemove\\', self.onDragMove);\\r\\n            }\\r\\n            if (pl102.isTouchEvents) {\\r\\n                pl102.stage.off(\\'touchend\\', self.onDragEnd);\\r\\n                pl102.stage.off(\\'touchmove\\', self.onDragMove);\\r\\n                pl102.stage.on(\\'touchend\\', self.onDragEnd);\\r\\n                pl102.stage.on(\\'touchmove\\', self.onDragMove);\\r\\n            }\\r\\n\\r\\n\\r\\n            this.onDragMove()\\r\\n            if (self.funDown) self.funDown();\\r\\n        };\\r\\n\\r\\n        var dist=0;\\r\\n        var bool=false;\\r\\n        var v, v1;       \\r\\n        var ppp = new PIXI.Point(9999999999, 0);\\r\\n        var pEnd = new PIXI.Point(0, 0);\\r\\n        var pp,pp1;\\r\\n        this.onDragMove = function (e) {\\r\\n            if(ppp.x==9999999999){\\r\\n                ppp.x=pl102.global.x;\\r\\n                ppp.y=pl102.global.y;\\r\\n                bool=false;               \\r\\n            }\\r\\n\\r\\n            dist =  calc.getDistance(ppp,pl102.global);\\r\\n            if(dist>5){\\r\\n                bool=true\\r\\n            }\\r\\n            if(bool==true){\\r\\n                if(self.sten!=undefined){\\r\\n                    if(self.sten.idArr==0){\\r\\n                        self.sten.x=self.sten.pointOld.x-(ppp.x-pl102.global.x)/self._scale;\\r\\n                        par.array[1].x=self.sten.x;\\r\\n                        par.array[1].width=par.array[2].x-par.array[1].x;\\r\\n                    }\\r\\n\\r\\n                    if(self.sten.idArr==1){\\r\\n                       \\r\\n                        self.sten.y=self.sten.pointOld.y-(ppp.y-pl102.global.y)/self._scale;\\r\\n                                          \\r\\n                        par.array[0].width=par.array[0].pointOld.w+(ppp.y-pl102.global.y)/self._scale;\\r\\n                        par.array[0].y=self.sten.y+par.array[0].width//par.array[0].pointOld.y+(ppp.y-pl102.global.y);\\r\\n\\r\\n                        par.array[2].width=par.array[2].pointOld.w+(ppp.y-pl102.global.y)/self._scale;\\r\\n                        par.array[2].y=par.array[2].pointOld.y-(ppp.y-pl102.global.y)/self._scale;    \\r\\n                    }\\r\\n\\r\\n\\r\\n                    if(self.sten.idArr==2){\\r\\n                        self.sten.x=self.sten.pointOld.x-(ppp.x-pl102.global.x)/self._scale;                       \\r\\n                        par.array[1].width=par.array[2].x-par.array[1].x;\\r\\n                    }\\r\\n                    self.redrahXY()\\r\\n                }\\r\\n            }          \\r\\n        };\\r\\n\\r\\n\\r\\n        this.onDragEnd = function (e) {\\r\\n            if(self.sobTip==\"onDown\"){\\r\\n                if(self.sten!=undefined){\\r\\n                    if(self.sten.idArr==0){\\r\\n                        var xx=self.sten.x\\r\\n                        self.x=(self.x+xx)*self._scale;                        \\r\\n                        for (var i = 0; i < par.array.length; i++) {\\r\\n                            par.array[i].x-=xx;\\r\\n                        }\\r\\n                    }\\r\\n                    if(self.sten.idArr==1){\\r\\n                        var yy=self.sten.y\\r\\n                        self.y=(self.y+yy)*self._scale;     \\r\\n\\r\\n\\r\\n                        for (var i = 0; i < par.array.length; i++) {\\r\\n                            par.array[i].y-=yy;\\r\\n                            \\r\\n                        }\\r\\n                    }\\r\\n                    self.redrag(500);\\r\\n                    self.redrahXY()\\r\\n                }\\r\\n\\r\\n                if(bool==false){\\r\\n                    self.sten.active=!self.sten.active;\\r\\n                }\\r\\n            }\\r\\n\\r\\n\\r\\n            if (pl102.isMouseEvents) {\\r\\n                pl102.stage.off(\\'mouseup\\', self.onDragEnd);\\r\\n                pl102.stage.off(\\'mousemove\\', self.onDragMove);\\r\\n            }\\r\\n            if (pl102.isTouchEvents) {\\r\\n                pl102.stage.off(\\'touchend\\', self.onDragEnd);\\r\\n                pl102.stage.off(\\'touchmove\\', self.onDragMove);\\r\\n            }\\r\\n            //if (self.funUp) self.funUp();\\r\\n        };\\r\\n\\r\\n        this.redrahXY=function(){\\r\\n            par.plusSten.redrahXY(this._scale)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    set x(v) {\\r\\n        this.content.x = v;\\r\\n        this.cont3d.position.x=-this.rectangle.width/2+v\\r\\n        this.redrahXY();\\r\\n        this.fun(\"visi3d\");\\r\\n    } \\r\\n    get x() { return  this.content.x;}\\r\\n\\r\\n    set y(v) {\\r\\n        this.content.y = v;\\r\\n        this.cont3d.position.y=-this.rectangle.height/2+v\\r\\n        this.redrahXY()\\r\\n        this.fun(\"visi3d\");\\r\\n    } \\r\\n    get y() { return  this.content.y;}\\r\\n\\r\\n    set width(v) {\\r\\n        if(this._width!=v){\\r\\n            this._width = v;         \\r\\n            \\r\\n        }       \\r\\n    }   \\r\\n    get width() { return  this._width;}\\r\\n\\r\\n\\r\\n    set height(v) {\\r\\n        if(this._height!=v){\\r\\n            this._height = v;            \\r\\n            \\r\\n        }       \\r\\n    }   \\r\\n    get height() { return  this._height;}   \\r\\n\\r\\n    set scale(v) {\\r\\n        if(this._scale!=v){\\r\\n            this._scale = v;            \\r\\n            this.content.scale.set(this._scale,this._scale);\\r\\n        }       \\r\\n    }   \\r\\n    get scale() { return  this._scale;} \\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass DBUtC extends DButton {\\r\\n    constructor(dCont, x, y, text,fun, link) { \\r\\n        super(dCont, x, y, text, fun, link);         \\r\\n        this.type=\"DBUtC\";\\r\\n        if(dCont!=undefined)if(dCont.add!=undefined)dCont.add(this);\\r\\n        var self=this;\\r\\n        this.fun=fun;\\r\\n\\r\\n        this._xx=0;\\r\\n        this._yy=0;\\r\\n\\r\\n        var sp=undefined;   \\r\\n\\r\\n        this.mouseup = function(e){\\r\\n            sp=undefined;\\r\\n            if(dcmParam.mobile==false){\\r\\n                document.removeEventListener(\"mousemove\", self.mousemove);\\r\\n                document.removeEventListener(\"mouseup\", self.mouseup);\\r\\n            }else{                  \\r\\n                document.removeEventListener(\"touchend\", self.mouseup);\\r\\n                document.removeEventListener(\"touchmove\", self.mousemove);\\r\\n            }\\r\\n            self.fun(\"up\") \\r\\n        }\\r\\n\\r\\n        this.mousemove = function(e){           \\r\\n            if(dcmParam.mobile==false){\\r\\n                if(sp==undefined){\\r\\n                    sp={\\r\\n                        x:e.clientX,\\r\\n                        y:e.clientY,\\r\\n                        x1:self.xx,\\r\\n                        y1:self.yy\\r\\n                    };\\r\\n                    self.fun(\"start\") \\r\\n                }\\r\\n                var ss=sp.x1+(e.clientX-sp.x)           \\r\\n                self.xx=ss\\r\\n                var ss=sp.y1+(e.clientY-sp.y)           \\r\\n                self.yy=ss\\r\\n                self.fun(\"drag\")\\r\\n            }else{\\r\\n                if(sp==undefined){\\r\\n                    sp={\\r\\n                        x:e.targetTouches[0].clientX,\\r\\n                        y:e.targetTouches[0].clientY,\\r\\n                        x1:self.x,\\r\\n                        y1:self.y\\r\\n                    };\\r\\n                }\\r\\n                var ss=sp.x1+(e.targetTouches[0].clientX-sp.x)              \\r\\n                self.xx=ss\\r\\n                var ss=sp.y1+(e.targetTouches[0].clientY-sp.y)              \\r\\n                self.yy=ss  \\r\\n                self.fun(\"drag\")            \\r\\n            }\\r\\n\\r\\n\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n        this.fun_mousedown = function(){  \\r\\n            self.xx=0;\\r\\n            self.yy=0;\\r\\n\\r\\n            if(dcmParam.mobile==false){\\r\\n                document.addEventListener(\"mousemove\", self.mousemove);\\r\\n                document.addEventListener(\"mouseup\", self.mouseup);\\r\\n            }else{\\r\\n                \\r\\n                document.addEventListener(\"touchend\", self.mouseup);\\r\\n                document.addEventListener(\"touchmove\", self.mousemove);\\r\\n            }\\r\\n            \\r\\n        }\\r\\n\\r\\n\\r\\n        \\r\\n    }\\r\\n\\r\\n    set xx(v) { this._xx = v; }  get xx() { return  this._xx;}\\r\\n    set yy(v) { this._yy = v; }  get yy() { return  this._yy;}\\r\\n}\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/scane2d/Scane2d.js\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass Scane2d_Scane2d  {\\r\\n  \\tconstructor(glaf, fun) {  \\t\\t\\r\\n  \\t\\tthis.type=\"Scane2d\";\\r\\n  \\t\\tvar self=this;\\r\\n  \\t\\tthis.content=new PIXI.Container();\\r\\n  \\t\\tglaf.content.addChild(this.content);\\r\\n        this.glaf=glaf\\r\\n  \\t\\tthis._width=100;\\r\\n\\t\\tthis._height=100;\\r\\n\\r\\n  \\t\\tthis.dCont=new DCont(glaf.dCont);\\r\\n\\r\\n        this._sahMenu=0;\\t\\t\\r\\n\\r\\n  \\t\\tthis.array=[]\\r\\n\\r\\n  \\t\\t\\r\\n\\r\\n\\r\\n        this.array[this.array.length] = this.munuStart=new MunuStart(this, function(){\\r\\n            glaf.sahMenu=1;\\r\\n        });\\r\\n        this.munuStart.active = true;\\r\\n\\r\\n\\r\\n\\r\\n  \\t\\tthis.array[this.array.length] = this.stens=new Stens(this, function(type, param){\\r\\n            fun(type, param)\\r\\n  \\t\\t});\\r\\n  \\t\\tthis.stens.active = true;\\r\\n\\r\\n        \\r\\n\\r\\n\\r\\n\\r\\n  \\r\\n\\r\\n\\r\\n        \\r\\n  \\t\\tthis.sizeWindow = function(w,h){ \\t\\t\\t\\t\\t\\r\\n  \\t\\t\\tself._width=w;\\r\\n\\t\\t\\tself._height=h;\\r\\n\\t\\t\\tfor (var i = 0; i < this.array.length; i++) {\\r\\n\\t\\t\\t\\tthis.array[i].sizeWindow(w,h)\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\r\\n\\r\\n  \\t\\t}  \\t\\t\\t\\r\\n  \\t}\\r\\n\\r\\n    set sahMenu(value) {\\r\\n        if(this._sahMenu!=value){\\r\\n            this._sahMenu = value;\\r\\n            this.munuStart.sahMenu = value;\\r\\n            this.stens.sahMenu = value;\\r\\n        }\\r\\n    }\\r\\n    get sahMenu() { return  this._sahMenu;}\\r\\n}\\r\\n/*\\r\\nexport class Debug {\\r\\n  \\tconstructor(scane2d) {  \\t\\t\\r\\n  \\t\\tthis.type=\"Debug\";\\r\\n  \\t\\tthis.dCont=new DCont(scane2d.dCont);\\r\\n\\r\\n  \\t\\tvar cc=new DCheckBox(this.dCont,2,2,\"0 active\",function(){\\r\\n  \\t\\t\\tscane2d.munuStart.active=this.value;\\r\\n  \\t\\t})\\r\\n  \\t\\tcc.value=scane2d.munuStart.active;\\r\\n\\r\\n  \\t\\tvar cc=new DCheckBox(this.dCont,2,40,\"stens active\",function(){\\r\\n  \\t\\t\\tscane2d.stens.active=this.value;\\r\\n  \\t\\t})\\r\\n  \\t\\tcc.value=scane2d.stens.active;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n  \\t\\t//this.pObject=new DParamObject(this.dCont,2,100);\\r\\n\\t\\t//this.pObject.addObject(scane2d.stens.array[1]);\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n  \\t\\tthis.sizeWindow = function(w,h){ \\r\\n  \\t\\t\\ttrace(\"wwwwww\",w) \\r\\n  \\t\\t\\tthis.dCont.x=w;\\r\\n  \\t\\t}\\r\\n\\r\\n   \\t}\\r\\n}*/\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/scane3d/room/GeometrySten.js\\n\\r\\nfunction GeometrySten () {\\r\\n//GeometrySten = function() {\\r\\n    THREE.BufferGeometry.call( this );\\r\\n    this.type = \\'GeometrySten\\';\\r\\n \\r\\n    // большая коробка / максимальные размеры для отображения\\r\\n    this._rect = {x:0, y:0, width:100, height:100};\\r\\n    this._arrBox = [ ];//{x:100, y:100, width:100, height:100}\\r\\n\\r\\n    this._textureWidth = 256;   // ширина текстуры / сегмента\\r\\n    this._textureHeight = 256;  // высота текстуры / сегмента\\r\\n    this._depth = 256;            // глубина боксов\\r\\n    this._z=0;\\r\\n \\r\\n    this._prossentWidth = 0;   \\r\\n    this._prossentHeight = 0; \\r\\n    this._isInside = false;      // true - врутри боксы/ false - снаружи, исключить боксы\\r\\n    this._isInverse = false;\\r\\n    this._okrog = 5;//  \\r\\n\\r\\n    var arrIndex\\r\\n    var arrUv=[];               // ув\\r\\n    var arrNormal;              // нормали\\r\\n    var arrPosition=[];         // позиции точек\\r\\n\\r\\n    var arrUvAttribut;          // ув            атрибут буфера\\r\\n    var arrNormalAttribut;      // нормали       атрибут буфера \\r\\n    var arrPositionAttribut     // позиции точек атрибут буфера\\r\\n\\r\\n    var setkaX=[];              // значения по х\\r\\n    var setkaY=[];              // значения по у\\r\\n    var offX=0;                 // индекс для setkaX\\r\\n    var offY=0;                 // индекс для setkaY\\r\\n\\r\\n    var setkaBigX=[];           // значения по х\\r\\n    var setkaBigY=[];           // значения по у\\r\\n\\r\\n    var arrXY = [];             // возможные ректы/позиции\\r\\n    var findXY=0;               // индекс для arrXY\\r\\n    var arrBool=[];\\r\\n\\r\\n\\r\\n    // позиции\\r\\n    var vectPos0 = new THREE.Vector3();\\r\\n    var vectPos1 = new THREE.Vector3();\\r\\n    var vectPos2 = new THREE.Vector3();\\r\\n    var vectPos3 = new THREE.Vector3();\\r\\n\\r\\n    // ув\\r\\n    var vectUv0 = new THREE.Vector2();\\r\\n    var vectUv1 = new THREE.Vector2();\\r\\n    var vectUv2 = new THREE.Vector2();\\r\\n    var vectUv3 = new THREE.Vector2();\\r\\n\\r\\n    var sah=0;          // шаг прямоугольника\\r\\n    var shahPoint = 6*3;// шаг для позиции\\r\\n    var shahUv = 6*2;   // шаг для ув\\r\\n\\r\\n    this.setRect = function(x, y, w, h) {\\r\\n        this._rect.x = x;\\r\\n        this._rect.y = y;\\r\\n        this._rect.width = w;\\r\\n        this._rect.height = h;\\r\\n        this.update();\\r\\n    }\\r\\n\\r\\n    var objDin;\\r\\n    this.startArrRect = function(){\\r\\n        \\r\\n        sah = 0;\\r\\n        // очищаем точки\\r\\n        \\r\\n        for (var i = 0; i < arrPosition.length; i++) {\\r\\n            arrPosition[i]=0;\\r\\n        };\\r\\n        for (var i = 0; i < arrUv.length; i++) {\\r\\n            arrUv[i]=0;\\r\\n        };    \\r\\n        \\r\\n        \\r\\n         \\r\\n        if (this._isInside) {// если нужно отображать коробки которые в нутри большой коробки\\r\\n            // заполняем\\r\\n            \\r\\n            for (var i = 0; i < this._arrBox.length; i++) {\\r\\n                //if(this._arrBox[i].boxGeom!=undefined)objDin=this._arrBox[i].boxGeom;                \\r\\n               //else \\r\\n               objDin=this._arrBox[i];\\r\\n               // if(this._arrBox[i].boxGeom!=null){\\r\\n                    this.fillPointFromBox(objDin.x,objDin.y,objDin.width,objDin.height)//, this._depth);\\r\\n              //  }\\r\\n            }\\r\\n        } else {// показывать большую коробку исключая маленькие коробки\\r\\n            \\r\\n            this.fillPointExcludeBox();\\r\\n        }\\r\\n        \\r\\n\\r\\n    } \\r\\n\\r\\n    // наполнение сетки исключая боксы\\r\\n    this.fillPointExcludeBox = function() {\\r\\n        offX = 0;\\r\\n        offY = 0;\\r\\n        var freeBigBox = false;// пустой ли болшой бокс?\\r\\n   \\r\\n        for (var i = 0; i < this._arrBox.length; i++) {// берем позиции коробки если они в нутри большой коробки\\r\\n           // if(this._arrBox[i].boxGeom!=undefined)objDin=this._arrBox[i].boxGeom;                \\r\\n           // else \\r\\n                objDin=this._arrBox[i];\\r\\n            //if(this._arrBox[i].boxGeom!=null){\\r\\n                if (this._rect.x < (objDin.x +  objDin.width) \\r\\n                    && this._rect.y < (objDin.y + objDin.height) \\r\\n                    && (this._rect.x + this._rect.width) > objDin.x \\r\\n                    && (this._rect.y + this._rect.height) > objDin.y) {\\r\\n                        if (this._rect.x <= objDin.x) {\\r\\n                            setkaBigX[offX++] = (objDin.x);\\r\\n                        }\\r\\n                        if ((this._rect.x + this._rect.width) >= (objDin.x + objDin.width) ) {\\r\\n                            setkaBigX[offX++] = (objDin.x + objDin.width);\\r\\n                        }\\r\\n                        if ((this._rect.y) <= (objDin.y) ) {\\r\\n                            setkaBigY[offY++] = (objDin.y);\\r\\n                        }\\r\\n                        if ((this._rect.y + this._rect.height) >= (objDin.y + objDin.height) ) {\\r\\n                            setkaBigY[offY++] = (objDin.y + objDin.height);\\r\\n                        }\\r\\n                }\\r\\n           // }\\r\\n        }\\r\\n\\r\\n        if (offX == 0 && offY == 0) {// большой бокс пустой\\r\\n            freeBigBox = true;\\r\\n        }\\r\\n\\r\\n        // сегменты  (размер текстуры)\\r\\n        for (var i = this._rect.x + this._textureWidth;  i < this._rect.x + this._rect.width; i += this._textureWidth)  {\\r\\n            setkaBigX[offX++] = i;\\r\\n        }\\r\\n        for (var i = this._rect.y + this._textureHeight; i < this._rect.y + this._rect.height;i += this._textureHeight) {\\r\\n            setkaBigY[offY++] = i;\\r\\n        }\\r\\n        \\r\\n        setkaBigX[offX++] = (this._rect.x );\\r\\n        setkaBigX[offX++] = (this._rect.x + this._rect.width);\\r\\n        setkaBigY[offY++] = (this._rect.y);\\r\\n        setkaBigY[offY++] = (this._rect.y + this._rect.height);\\r\\n\\r\\n        setkaBigY.length = offY;\\r\\n        setkaBigX.length = offX;\\r\\n\\r\\n        // сортируем\\r\\n        setkaBigY.sort(function( a, b) { return a - b});\\r\\n        setkaBigX.sort(function( a, b) { return a - b});\\r\\n\\r\\n        // убираем повторы\\r\\n        for (var i = 0; i < setkaBigX.length; i++) {\\r\\n            if (setkaBigX[i] == setkaBigX[i+1]) {\\r\\n                setkaBigX.splice(i+1, 1);\\r\\n                i--;\\r\\n            }\\r\\n        }\\r\\n        for (var i = 0; i < setkaBigY.length; i++) {\\r\\n            if (setkaBigY[i] == setkaBigY[i+1]) {\\r\\n                setkaBigY.splice(i+1, 1);\\r\\n                i--;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (var i = 0; i < setkaBigY.length; i++) {\\r\\n            if(arrBool[i]==undefined) arrBool[i]=[];\\r\\n            for (var j = 0; j < setkaBigX.length; j++) {\\r\\n                arrBool[i][j]=this.inBox(setkaBigX[j], setkaBigY[i], setkaBigX[j+1], setkaBigY[i+1]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n\\r\\n        if (freeBigBox) {// значит в большой коробки других коробок нет\\r\\n            this.fillPointFromBox(setkaBigX[0], setkaBigY[0],\\r\\n                Math.abs(setkaBigX[setkaBigX.length-1]-setkaBigX[0]), Math.abs(setkaBigY[setkaBigY.length-1]-setkaBigY[0]));\\r\\n        } else {\\r\\n            for (var i = 0; i < setkaBigY.length-1; i++) {\\r\\n                for (var j = 0; j < setkaBigX.length-1; j++) {\\r\\n                    if (arrBool[i][j]) continue;\\r\\n                    this.fillPointOptimiz(j, i);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n\\r\\n    }\\r\\n   \\r\\n    // наполнение сетки бокса\\r\\n    this.fillPointFromBox = function(_x, _y, _w, _h) {\\r\\n        if (this._rect) {   \\r\\n            if (_y+_h <=  this._rect.y ) return; // вверху далеко\\r\\n            if (_x+_w <=  this._rect.x) return;  // влева далеко\\r\\n            if (_y >= this._rect.y + this._rect.height) return;  // в низу далеко\\r\\n            if (_x >= this._rect.x + this._rect.width) return;   // справа далеко\\r\\n        }\\r\\n        offY = 0;\\r\\n        offX = 0;\\r\\n        // сегменты (размер текстуры)\\r\\n        for (var i = this._rect.x + this._textureWidth;  i < _x + _w; i += this._textureWidth)  {\\r\\n            if (i >= _x && i <= _x+_w ) setkaX[offX++] = i;\\r\\n        }\\r\\n        for (var i = this._rect.y + this._textureHeight; i < _y + _h;i += this._textureHeight) {\\r\\n            if (i >= _y && i <= _y+_h) setkaY[offY++] = i;\\r\\n        }\\r\\n\\r\\n        // границы бокса\\r\\n        if (_x >= this._rect.x ) setkaX[offX++] = _x;\\r\\n        else setkaX[offX++] = this._rect.x;\\r\\n        if (_x+_w <= this._rect.x + this._rect.width) setkaX[offX++] = _x+_w;\\r\\n        else setkaX[offX++] = this._rect.x + this._rect.width;\\r\\n        if (_y >= this._rect.y ) setkaY[offY++] = _y;\\r\\n        else setkaY[offY++] = this._rect.y;\\r\\n        if (_y+_h <= this._rect.y + this._rect.height) setkaY[offY++] = _y+_h;\\r\\n        else setkaY[offY++] = this._rect.y + this._rect.height;\\r\\n\\r\\n        setkaY.length = offY;\\r\\n        setkaX.length = offX;\\r\\n\\r\\n        // сортируем\\r\\n        setkaY.sort(function( a, b) { return a - b});\\r\\n        setkaX.sort(function( a, b) { return a - b});\\r\\n\\r\\n        // убираем повторы и обрезаем границы\\r\\n        for (var i = 0; i < setkaX.length; i++) {\\r\\n            if (setkaX[i] == setkaX[i+1] || setkaX[i+1] > this._rect.x + this._rect.width) {\\r\\n                setkaX.splice(i+1, 1);\\r\\n                i--;\\r\\n            }\\r\\n        }\\r\\n        for (var i = 0; i < setkaY.length; i++) {\\r\\n            if (setkaY[i] == setkaY[i+1] || setkaY[i+1] > this._rect.y + this._rect.height) {\\r\\n                setkaY.splice(i+1, 1);\\r\\n                i--;\\r\\n            }\\r\\n        }\\r\\n\\r\\n\\r\\n        this.fillPointSetka();\\r\\n\\r\\n    }\\r\\n\\r\\n    // рисуем квадрат\\r\\n    // isFront - сторона лицевая или задняя\\r\\n    this.pluspoli = function(isFront) {\\r\\n        if (this._isInverse) isFront = !isFront;\\r\\n        if (isFront) {\\r\\n\\r\\n            arrPosition[sah*shahPoint + 0] = vectPos0.x;\\r\\n            arrPosition[sah*shahPoint + 1] = vectPos0.y;\\r\\n            arrPosition[sah*shahPoint + 2] = vectPos0.z;\\r\\n\\r\\n            arrPosition[sah*shahPoint + 3] = vectPos1.x;\\r\\n            arrPosition[sah*shahPoint + 4] = vectPos1.y;\\r\\n            arrPosition[sah*shahPoint + 5] = vectPos1.z;\\r\\n\\r\\n            arrPosition[sah*shahPoint + 6] = vectPos2.x;\\r\\n            arrPosition[sah*shahPoint + 7] = vectPos2.y;\\r\\n            arrPosition[sah*shahPoint + 8] = vectPos2.z;\\r\\n\\r\\n            // второй треугольник\\r\\n            arrPosition[sah*shahPoint + 9] = vectPos0.x;\\r\\n            arrPosition[sah*shahPoint + 10] = vectPos0.y;\\r\\n            arrPosition[sah*shahPoint + 11] = vectPos0.z;\\r\\n\\r\\n            arrPosition[sah*shahPoint + 12] = vectPos2.x;\\r\\n            arrPosition[sah*shahPoint + 13] = vectPos2.y;\\r\\n            arrPosition[sah*shahPoint + 14] = vectPos2.z;\\r\\n\\r\\n            arrPosition[sah*shahPoint + 15] = vectPos3.x;\\r\\n            arrPosition[sah*shahPoint + 16] = vectPos3.y;\\r\\n            arrPosition[sah*shahPoint + 17] = vectPos3.z;\\r\\n\\r\\n\\r\\n            //uv\\r\\n            arrUv[sah*shahUv + 0] = vectUv0.x\\r\\n            arrUv[sah*shahUv + 1] = vectUv0.y\\r\\n\\r\\n            arrUv[sah*shahUv + 2] = vectUv1.x\\r\\n            arrUv[sah*shahUv + 3] = vectUv1.y\\r\\n\\r\\n            arrUv[sah*shahUv + 4] = vectUv2.x\\r\\n            arrUv[sah*shahUv + 5] = vectUv2.y\\r\\n            //-----\\r\\n            arrUv[sah*shahUv + 6] = vectUv0.x\\r\\n            arrUv[sah*shahUv + 7] = vectUv0.y\\r\\n\\r\\n            arrUv[sah*shahUv + 8] = vectUv2.x\\r\\n            arrUv[sah*shahUv + 9] = vectUv2.y\\r\\n\\r\\n            arrUv[sah*shahUv + 10] = vectUv3.x\\r\\n            arrUv[sah*shahUv + 11] = vectUv3.y\\r\\n\\r\\n        } else {\\r\\n\\r\\n            arrPosition[sah*shahPoint + 0] = vectPos0.x;\\r\\n            arrPosition[sah*shahPoint + 1] = vectPos0.y;\\r\\n            arrPosition[sah*shahPoint + 2] = vectPos0.z;\\r\\n\\r\\n            arrPosition[sah*shahPoint + 3] = vectPos2.x;\\r\\n            arrPosition[sah*shahPoint + 4] = vectPos2.y;\\r\\n            arrPosition[sah*shahPoint + 5] = vectPos2.z;\\r\\n\\r\\n            arrPosition[sah*shahPoint + 6] = vectPos1.x;\\r\\n            arrPosition[sah*shahPoint + 7] = vectPos1.y;\\r\\n            arrPosition[sah*shahPoint + 8] = vectPos1.z;\\r\\n\\r\\n            // второй треугольник\\r\\n            arrPosition[sah*shahPoint + 9] = vectPos0.x;\\r\\n            arrPosition[sah*shahPoint + 10] = vectPos0.y;\\r\\n            arrPosition[sah*shahPoint + 11] = vectPos0.z;\\r\\n\\r\\n            arrPosition[sah*shahPoint + 12] = vectPos3.x;\\r\\n            arrPosition[sah*shahPoint + 13] = vectPos3.y;\\r\\n            arrPosition[sah*shahPoint + 14] = vectPos3.z;\\r\\n\\r\\n            arrPosition[sah*shahPoint + 15] = vectPos2.x;\\r\\n            arrPosition[sah*shahPoint + 16] = vectPos2.y;\\r\\n            arrPosition[sah*shahPoint + 17] = vectPos2.z;\\r\\n\\r\\n\\r\\n            //uv\\r\\n            arrUv[sah*shahUv + 0] = vectUv0.x\\r\\n            arrUv[sah*shahUv + 1] = vectUv0.y\\r\\n\\r\\n            arrUv[sah*shahUv + 2] = vectUv2.x\\r\\n            arrUv[sah*shahUv + 3] = vectUv2.y\\r\\n\\r\\n            arrUv[sah*shahUv + 4] = vectUv1.x\\r\\n            arrUv[sah*shahUv + 5] = vectUv1.y\\r\\n            //-----\\r\\n            arrUv[sah*shahUv + 6] = vectUv0.x\\r\\n            arrUv[sah*shahUv + 7] = vectUv0.y\\r\\n\\r\\n            arrUv[sah*shahUv + 8] = vectUv3.x\\r\\n            arrUv[sah*shahUv + 9] = vectUv3.y\\r\\n\\r\\n            arrUv[sah*shahUv + 10] = vectUv2.x\\r\\n            arrUv[sah*shahUv + 11] = vectUv2.y\\r\\n\\r\\n        }\\r\\n\\r\\n        sah++;\\r\\n    }\\r\\n    \\r\\n    // проверяем находится ли позиции x, y, x1, y1 в нутри какогото бокса\\r\\n    this.inBox = function(x, y, x1, y1) {\\r\\n        for (var i = 0; i < this._arrBox.length; i++) {\\r\\n           // if(this._arrBox[i].boxGeom!=undefined)objDin=this._arrBox[i].boxGeom;                \\r\\n           // else \\r\\n                objDin=this._arrBox[i];\\r\\n           // if(this._arrBox[i].boxGeom!=null){\\r\\n                if (x >= objDin.x && x1 <= objDin.x + objDin.width && \\r\\n                    y >= objDin.y && y1 <= objDin.y + objDin.height){\\r\\n                    return true;\\r\\n                } \\r\\n           // }     \\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n \\r\\n    // заполняем \\r\\n    this.fillPointOptimiz = function(x, y) {\\r\\n        findX=0;\\r\\n        var lasy=y;\\r\\n        var pow=0, temp=0, ind=0;// pow -  максимальная мощь ректа, ind - индекс максимального ректа в масиве \\r\\n        for (var j = x+1; lasy < setkaBigY.length; j++) { \\r\\n            if ( Math.abs(((setkaBigY[lasy] - this._rect.y) / (this._textureHeight))%1) == 0 && lasy > y) {// если вышли ниже сегмента текстуры\\r\\n                break;\\r\\n            }\\r\\n            // если столкнулись |или дошли до конца по x|или до сегмента\\r\\n            if(arrBool[lasy][j] || j == setkaBigX.length-1 || Math.abs(((setkaBigX[j] - this._rect.x) / (this._textureWidth ))%1) == 0) {\\r\\n                temp = this.getBoolRectPow(x, y, j, ++lasy);// смотрим на мощь этого ркета\\r\\n                if ( temp != -1) {\\r\\n                    arrXY[findXY++] = ([j , lasy])\\r\\n                    if (pow < temp) {\\r\\n                        pow = temp;\\r\\n                        ind=findXY-1;\\r\\n                    }\\r\\n                }\\r\\n                j=x;\\r\\n                continue;\\r\\n            };\\r\\n        }\\r\\n\\r\\n        this.fillPointFromBox(setkaBigX[x], setkaBigY[y],Math.abs(setkaBigX[arrXY[ind][0]]-setkaBigX[x]), Math.abs(setkaBigY[arrXY[ind][1]]-setkaBigY[y]));\\r\\n        this.setBoolRect(x, y,arrXY[ind][0],arrXY[ind][1]);\\r\\n    }\\r\\n\\r\\n    // задаем рект в масив arrBool\\r\\n    this.setBoolRect = function(x, y, x1, y1) {// x = y; y = x\\r\\n        \\r\\n        for (var yy = y; yy < arrBool.length && yy < y1; yy++) {\\r\\n            for (var xx = x; xx < arrBool[yy].length  && xx < x1; xx++) {\\r\\n                arrBool[yy][xx] = true;\\r\\n            }\\r\\n        } \\r\\n    }\\r\\n\\r\\n    // получаем мощь по arrBool\\r\\n    this.getBoolRectPow = function(x, y, x1, y1) {// i = y; j = x\\r\\n        var pow=0;\\r\\n        for (var yy = y; yy < arrBool.length && yy < y1; yy++) {\\r\\n            for (var xx = x; xx < arrBool[yy].length  && xx < x1; xx++) {\\r\\n                if (arrBool[yy][xx]) return -1;   \\r\\n                else pow++;\\r\\n            }\\r\\n        }\\r\\n        return pow;\\r\\n    }\\r\\n\\r\\n\\r\\n    var x =0;\\r\\n    var x1=0;\\r\\n    var y =0;\\r\\n    var y1=0;\\r\\n    var px =0;\\r\\n    var px1=0;\\r\\n    var py =0;\\r\\n    var py1=0;\\r\\n    // наполнение позиций из сетки\\r\\n    this.fillPointSetka = function() {\\r\\n        var count=0;\\r\\n        for (var i = 0; i < setkaY.length-1; i++) {\\r\\n           \\r\\n\\r\\n            for (var j = 0; j < setkaX.length-1; j++) {\\r\\n                count++\\r\\n                x = setkaX[j];\\r\\n                y = setkaY[i];\\r\\n                x1 = setkaX[j+1];\\r\\n                y1 = setkaY[i+1];\\r\\n\\r\\n                px =  Math.abs(((x - (this._rect.x)) / (this._textureWidth ))%1)||0;\\r\\n                py =  Math.abs(((y - (this._rect.y)) / (this._textureHeight))%1)||0;\\r\\n                px1 = Math.abs(((x1 - (this._rect.x)) / (this._textureWidth ))%1)||1;\\r\\n                py1 = Math.abs(((y1 - (this._rect.y)) / (this._textureHeight))%1)||1;\\r\\n\\r\\n                vectPos0.set(x,  y,  this._z);\\r\\n                vectPos1.set(x1, y,  this._z);\\r\\n                vectPos2.set(x1, y1, this._z);\\r\\n                vectPos3.set(x,  y1, this._z);\\r\\n\\r\\n                vectUv0.set( px , py);\\r\\n                vectUv1.set( px1, py);\\r\\n                vectUv2.set( px1, py1);\\r\\n                vectUv3.set( px , py1);\\r\\n\\r\\n                this.pluspoli( );\\r\\n\\r\\n                if (this._depth) {\\r\\n                    vectPos0.set(x,  y,  this._z+this._depth);\\r\\n                    vectPos1.set(x1, y,  this._z+this._depth);\\r\\n                    vectPos2.set(x1, y1, this._z+this._depth);\\r\\n                    vectPos3.set(x,  y1, this._z+this._depth);\\r\\n\\r\\n                    vectUv0.set( px , py);\\r\\n                    vectUv1.set( px1, py);\\r\\n                    vectUv2.set( px1, py1);\\r\\n                    vectUv3.set( px , py1);\\r\\n\\r\\n                    this.pluspoli( true );\\r\\n\\r\\n                    // ставим грани\\r\\n                    this.fillPointEdge(i , j);\\r\\n\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        \\r\\n    }\\r\\n\\r\\n   \\r\\n    // наполнение грани\\r\\n    this.fillPointEdge = function(i, j, isFront) {\\r\\n        x = setkaX[j];\\r\\n        y = setkaY[i];\\r\\n        x1 = setkaX[j+1];\\r\\n        y1 = setkaY[i+1];\\r\\n\\r\\n        px =  Math.abs(((x - this._rect.x) / (this._textureWidth ))%1)||0;\\r\\n        py =  Math.abs(((y - this._rect.y) / (this._textureHeight))%1)||0;\\r\\n        px1 = Math.abs(((x1 - this._rect.x) / (this._textureWidth ))%1)||1;\\r\\n        py1 = Math.abs(((y1 - this._rect.y) / (this._textureHeight))%1)||1;\\r\\n\\r\\n        if (i == 0) {\\r\\n            vectPos0.set(x,  y, this._z);\\r\\n            vectPos1.set(x1, y, this._z);\\r\\n            vectPos2.set(x1, y, this._z+this._depth);\\r\\n            vectPos3.set(x,  y, this._z+this._depth);\\r\\n\\r\\n            vectUv0.set( px , 0);\\r\\n            vectUv1.set( px1, 0);\\r\\n            vectUv2.set( px1, 1);\\r\\n            vectUv3.set( px , 1);\\r\\n\\r\\n            this.pluspoli( !isFront );\\r\\n        }\\r\\n\\r\\n        if (i == setkaY.length-2) {\\r\\n            vectPos0.set(x,  y1, this._z);\\r\\n            vectPos1.set(x1, y1, this._z);\\r\\n            vectPos2.set(x1, y1, this._z+this._depth);\\r\\n            vectPos3.set(x,  y1, this._z+this._depth);\\r\\n\\r\\n            vectUv0.set( px , 0);\\r\\n            vectUv1.set( px1, 0);\\r\\n            vectUv2.set( px1, 1);\\r\\n            vectUv3.set( px , 1);\\r\\n\\r\\n            this.pluspoli(isFront);\\r\\n        }\\r\\n\\r\\n        if (j == 0) { \\r\\n            vectPos0.set(x,   y,  this._z);\\r\\n            vectPos1.set(x,   y,  this._z+this._depth);\\r\\n            vectPos2.set(x,   y1, this._z+this._depth);\\r\\n            vectPos3.set(x,   y1, this._z);\\r\\n\\r\\n            vectUv0.set( 0 , py);\\r\\n            vectUv1.set( 1,  py);\\r\\n            vectUv2.set( 1,  py1);\\r\\n            vectUv3.set( 0 , py1);\\r\\n            this.pluspoli( !isFront );\\r\\n        }\\r\\n\\r\\n        if (j == setkaX.length-2) {// \\r\\n            vectPos0.set(x1,   y,  this._z);\\r\\n            vectPos1.set(x1,   y,  this._z+this._depth);\\r\\n            vectPos2.set(x1,   y1, this._z+this._depth);\\r\\n            vectPos3.set(x1,   y1, this._z);\\r\\n\\r\\n            vectUv0.set( 0 , py);\\r\\n            vectUv1.set( 1,  py);\\r\\n            vectUv2.set( 1,  py1);\\r\\n            vectUv3.set( 0 , py1);\\r\\n            this.pluspoli(isFront);\\r\\n        }\\r\\n    }\\r\\n\\r\\n \\r\\n\\r\\n    this.createBuffer = function () {\\r\\n        if (!arrPositionAttribut || arrPositionAttribut.length < arrPosition.length*3) {\\r\\n            arrPositionAttribut = new Float32Array( arrPosition.length*3);\\r\\n            this.addAttribute( \\'position\\', new THREE.BufferAttribute( arrPositionAttribut, 3 ) );\\r\\n\\r\\n            arrUvAttribut = new Float32Array( arrPosition.length*2);\\r\\n            this.addAttribute( \\'uv\\', new THREE.BufferAttribute( arrUvAttribut, 2 ) );\\r\\n\\r\\n           // arrIndex = new Uint16Array(arrPosition.length);\\r\\n           //  this.addAttribute( \\'indexs\\', new THREE.BufferAttribute( arrIndex, 1 ) );\\r\\n\\r\\n            arrNormal = new Float32Array( arrPosition.length*3 );\\r\\n            this.addAttribute( \\'normal\\', new THREE.BufferAttribute( arrNormal, 3 ) );\\r\\n\\r\\n        }\\r\\n            \\r\\n        for (var i = 0; i < arrPositionAttribut.length; i++) {\\r\\n            arrPositionAttribut[i]=0;\\r\\n        };\\r\\n        \\r\\n\\r\\n        for (var i = 0; i < arrPosition.length; i++) {\\r\\n            this.attributes.position.array[i]= Math.round(arrPosition[i]*100)/100;// = arrPosition[i];\\r\\n        }\\r\\n        \\r\\n        for (var i = 0; i < arrUv.length; i++) {\\r\\n            arrUvAttribut[i] = arrUv[i];\\r\\n        }\\r\\n\\r\\n       \\r\\n        this.attributes.position.needsUpdate = true;\\r\\n        this.attributes.uv.needsUpdate = true;\\r\\n        this.computeVertexNormals();\\r\\n        this.attributes.normal.needsUpdate = true;\\r\\n        this.computeBoundingBox();\\r\\n        this.computeBoundingSphere();\\r\\n\\r\\n    }\\r\\n    \\r\\n    this.update = function() {\\r\\n        \\r\\n        this.startArrRect();\\r\\n       \\r\\n        this.createBuffer();\\r\\n        \\r\\n    }\\r\\n\\r\\n    // растягивает текстуру на большую коробку\\r\\n    this.full = function() {\\r\\n        this._textureHeight=this._rect.height;\\r\\n        this._textureWidth=this._rect.width;\\r\\n        this.update();\\r\\n    }\\r\\n    \\r\\n    this.update();\\r\\n\\r\\n\\r\\n    Object.defineProperty(this, \"textureWidth\", {\\r\\n        set : function(value){\\r\\n            if (this._textureWidth == value) return;\\r\\n            this._textureWidth = value > 0 ? value : 1;\\r\\n            this.update();\\r\\n        },\\r\\n        get : function() { return this._textureWidth; }\\r\\n    });\\r\\n    Object.defineProperty(this, \"textureHeight\", {\\r\\n        set : function(value){\\r\\n            if (this._textureHeight == value) return;\\r\\n            this._textureHeight = value > 0 ? value : 1;\\r\\n            this.update();\\r\\n        },\\r\\n        get : function() { return this._textureHeight; }\\r\\n    });\\r\\n\\r\\n    Object.defineProperty(this, \"rect\", {\\r\\n        set : function(value){\\r\\n            this._rect = value;\\r\\n            this.update();\\r\\n        },\\r\\n        get : function() { return this._rect; }\\r\\n    });\\r\\n\\r\\n    Object.defineProperty(this, \"arrBox\", {\\r\\n        set : function(value){\\r\\n            this._arrBox = value;\\r\\n            this.update();\\r\\n        },\\r\\n        get : function() { return this._arrBox; }\\r\\n    });  \\r\\n    Object.defineProperty(this, \"depth\", {\\r\\n        set : function(value){\\r\\n            if (this._depth == value) return;\\r\\n            this._depth = value;\\r\\n            this.update();\\r\\n        },\\r\\n        get : function() { return this._depth; }\\r\\n    });   \\r\\n    Object.defineProperty(this, \"isInside\", {\\r\\n        set : function(value){\\r\\n            if (this._isInside == value) return;\\r\\n            this._isInside = value;\\r\\n            this.update();\\r\\n        },\\r\\n        get : function() { return this._isInside; }\\r\\n    });\\r\\n    Object.defineProperty(this, \"okrog\", {\\r\\n        set : function(value){\\r\\n            if (this._okrog == value) return;\\r\\n            this._okrog = value;\\r\\n            this.update();\\r\\n        },\\r\\n        get : function() { return this._okrog; }\\r\\n    });\\r\\n       Object.defineProperty(this, \"prossentWidth\", {\\r\\n        set : function(value){\\r\\n            if (this._prossentWidth == value) return;\\r\\n            this._prossentWidth = value;\\r\\n            this.update();\\r\\n        },\\r\\n        get : function() { return this._prossentWidth; }\\r\\n    });\\r\\n    Object.defineProperty(this, \"prossentHeight\", {\\r\\n        set : function(value){\\r\\n            if (this._prossentHeight == value) return;\\r\\n            this._prossentHeight = value;\\r\\n            this.update();\\r\\n        },\\r\\n        get : function() { return this._prossentHeight; }\\r\\n    });\\r\\n\\r\\n};\\r\\nGeometrySten.prototype = Object.create( THREE.BufferGeometry.prototype );\\r\\nGeometrySten.prototype.constructor = GeometrySten;\\n// CONCATENATED MODULE: ./src/larvij/scane3d/room/collision/CollisionUtil.js\\n\\r\\n\\r\\n\\r\\n//-----------------------------------------------------------------------------------------------\\r\\n//-----------------------------------------------------------------------------------------------\\r\\n\\r\\n\\r\\nfunction CollisionUtil () {\\r\\n\\r\\n  var self = this;\\r\\n \\r\\n\\r\\n  // крайние точки бокса который прилипает\\r\\n  var p1 = new PIXI.Point(0, 0);\\r\\n  var p2 = new PIXI.Point(0, 0);\\r\\n  var p3 = new PIXI.Point(0, 0);\\r\\n  var p4 = new PIXI.Point(0, 0);\\r\\n  // крайние точки i-го бокса в мире \\r\\n  var pp1 = new PIXI.Point(0, 0);\\r\\n  var pp2 = new PIXI.Point(0, 0);\\r\\n  var pp3 = new PIXI.Point(0, 0);\\r\\n  var pp4 = new PIXI.Point(0, 0); \\r\\n\\r\\n\\r\\n\\r\\n  // прилипать(сдвигать) бокс box к arrBox на растоянии distance\\r\\n  this.stickBox = function(box, arrBox , distance) {\\r\\n   if (!box) return;\\r\\n   // крайние точки бокса который прилипает\\r\\n   p1.x = box.x;\\r\\n   p1.y = box.y;\\r\\n\\r\\n   p2.x = box.x + box.width;\\r\\n   p2.y = box.y;\\r\\n\\r\\n   p3.x = box.x + box.width;\\r\\n   p3.y = box.y + box.height;\\r\\n\\r\\n   p4.x = box.x;\\r\\n   p4.y = box.y + box.height;\\r\\n\\r\\n   var dis;\\r\\n   for (var i = 0; i < arrBox.length; i++) {\\r\\n\\t pp1.x = arrBox[i].x;\\r\\n\\t pp1.y = arrBox[i].y;\\r\\n\\t pp2.x = arrBox[i].x + arrBox[i].width;\\r\\n\\t pp2.y = arrBox[i].y;\\r\\n\\t pp3.x = arrBox[i].x + arrBox[i].width;\\r\\n\\t pp3.y = arrBox[i].y + arrBox[i].height;\\r\\n\\t pp4.x = arrBox[i].x;\\r\\n\\t pp4.y = arrBox[i].y + arrBox[i].height;\\r\\n\\r\\n\\t dis = this.getDistance(p1, pp4)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x;\\r\\n\\t  box.y = arrBox[i].y + arrBox[i].height;\\r\\n\\t }\\r\\n\\t \\r\\n\\t dis = this.getDistance(p1, pp3)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x + arrBox[i].width;\\r\\n\\t  box.y = arrBox[i].y + arrBox[i].height;\\r\\n\\t }   \\r\\n\\r\\n\\t dis = this.getDistance(p1, pp2)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x + arrBox[i].width;\\r\\n\\t  box.y = arrBox[i].y ;\\r\\n\\t }\\r\\n\\r\\n\\t dis = this.getDistance(p2, pp3)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x + arrBox[i].width - box.width;\\r\\n\\t  box.y = arrBox[i].y + arrBox[i].height;\\r\\n\\t }\\r\\n\\t \\r\\n\\t dis = this.getDistance(p2, pp4)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x - box.width;\\r\\n\\t  box.y = arrBox[i].y + arrBox[i].height;\\r\\n\\t }   \\r\\n\\r\\n\\t dis = this.getDistance(p2, pp1)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x - box.width;\\r\\n\\t  box.y = arrBox[i].y ;\\r\\n\\t }\\r\\n\\r\\n\\t dis = this.getDistance(p3, pp2)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x + arrBox[i].width - box.width;\\r\\n\\t  box.y = arrBox[i].y - box.height;\\r\\n\\t }\\r\\n\\t \\r\\n\\t dis = this.getDistance(p3, pp1)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x - box.width;\\r\\n\\t  box.y = arrBox[i].y - box.height;\\r\\n\\t }   \\r\\n\\r\\n\\t dis = this.getDistance(p3, pp4)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x - box.width;\\r\\n\\t  box.y = arrBox[i].y + arrBox[i].height - box.height ;\\r\\n\\t }\\r\\n\\r\\n\\t dis = this.getDistance(p4, pp1)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x;\\r\\n\\t  box.y = arrBox[i].y - box.height;\\r\\n\\t }\\r\\n\\t \\r\\n\\t dis = this.getDistance(p4, pp2)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x + arrBox[i].width;\\r\\n\\t  box.y = arrBox[i].y - box.height;\\r\\n\\t }   \\r\\n\\r\\n\\t dis = this.getDistance(p4, pp3)\\r\\n\\t if (dis <= distance) {\\r\\n\\t  box.x = arrBox[i].x + arrBox[i].width;\\r\\n\\t  box.y = arrBox[i].y + arrBox[i].height - box.height;\\r\\n\\t }\\r\\n   }\\r\\n\\r\\n  }\\r\\n\\r\\n\\r\\n\\r\\n  // ищем из arrPosit ближайшую позицию к pos \\r\\n  this.findMinPosition = function(arrPosit, pos) {\\r\\n   var minDis = 999;\\r\\n   var dis;\\r\\n   var res={x:0, y:0}\\r\\n   for (var i = 0; i < arrPosit.length; i++) {\\r\\n\\t dis = this.getDistance(arrPosit[i], pos)\\r\\n\\t if (minDis > dis) {\\r\\n\\t  minDis = dis;\\r\\n\\t  res.x = arrPosit[i].x;\\r\\n\\t  res.y = arrPosit[i].y;\\r\\n\\t }\\r\\n   }\\r\\n   return res;\\r\\n  }\\r\\n\\r\\n\\r\\n\\r\\n   //Получение угла между двумя точками градусы\\r\\n\\tthis.getAngle = function(a, b) {\\r\\n   \\t\\treturn 180*Math.atan2( b.y - a.y, b.x - a.x)/(Math.PI);\\r\\n  \\t}\\r\\n\\r\\n \\r\\n  \\t// поверяем находится ли вторый прямоугольник в первом \\r\\n  \\tthis.isPutIn = function(x1, y1, w1, h1, x2, y2, w2, h2) {\\r\\n   \\t// if ( (x1 < x2) && (x1+w1 > x2+w2) ) {}\\r\\n   \\t\\treturn ( (x1 <= x2) && (x1+w1 >= x2+w2) && (w1 >= w2) && (y1 <= y2) && (y1+h1 >= y2+h2) && (h1 >= h2)); \\r\\n  \\t}\\r\\n  \\r\\n  \\r\\n\\r\\n  \\t// проверка на пересечение прямоугольников\\r\\n  \\tthis.isCollisionRectangle = function(x1, y1, w1, h1, x2, y2, w2, h2) {\\r\\n   \\t\\treturn x1 < (x2 + w2) && y1 < (y2 + h2) && (x1 + w1) > x2 && (y1 + h1) > y2;\\r\\n  \\t}\\r\\n\\r\\n  \\t// получить дистанцию между точками\\r\\n  \\tthis.getDistance = function(p1, p2, p3) {\\r\\n   \\t\\tif (!p1 || !p2) return 0;\\r\\n   \\t\\treturn Math.sqrt(Math.pow((p1.x - p2.x), 2) + Math.pow(( p1.y - p2.y), 2))\\r\\n  \\t}\\r\\n\\r\\n  \\t// получить дистанцию между точками\\r\\n  \\tthis.getDistance3D = function(p1, p2, p3) {\\r\\n   \\t\\treturn Math.sqrt(Math.pow((p1.x - p2.x), 2) + Math.pow(( p1.y - p2.y), 2) + Math.pow(( p1.z - p2.z), 2))\\r\\n  \\t}\\r\\n  \\t//// \\r\\n  \\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/scane3d/room/collision/CollisionDetection.js\\n//-----------------------------------------------------------------------------------------------\\r\\n//-----------------------------------------------------------------------------------------------\\r\\n\\r\\n\\r\\nfunction CollisionDetection() {\\r\\n\\r\\n\\tvar self = this;\\r\\n\\tthis.collUtil = new CollisionUtil();\\r\\n\\tthis.activBox = {};                 // активный бокс\\r\\n\\tthis.arrBox = [];                 // все боксы(мир)\\r\\n\\tthis.collisionBox = [];           // боксы которые пересекаются\\r\\n\\tthis._isCollisionAvtive = false;  // пересекается ли активный бокс\\r\\n\\tthis.dragBox;                     // таскалка\\r\\n\\tthis.disStick = 15;               // дистанция прилипания/stick\\r\\n\\tthis.bigBox = {x: 0, y: 0, width: 100, height: 100};                 // большой бокс\\r\\n\\tthis.tempBox = {x: 0, y: 0, width: 100, height: 100};\\r\\n\\tthis.isStick = false;             // прилипать ли краями к краям?\\r\\n\\r\\n\\tthis.hideBox = [];      // скрытые боксы (линии)\\r\\n\\tthis.offsetHideBox = 0; // отступ скрытых боксы (линий)\\r\\n\\tthis.arrPointX = [];    // масив значений х, вертикали\\r\\n\\tthis.arrPointY = [];    // масив значений у, горизонтали\\r\\n\\r\\n\\tthis.fun = null;    // в updateWorld\\r\\n\\tthis.funErr = null; //\\r\\n\\tvar isCorrect = true;\\r\\n\\r\\n\\t// коректируем позицию\\r\\n\\t// b - true таскалки боксов(dragBox) , b - false активного бокса(activBox)\\r\\n\\tthis.correct = function (b) {\\r\\n\\t\\tisCorrect = true;\\r\\n\\t\\tthis.checkArrPoint();\\r\\n\\t\\tif (this.isStick)this.stick();// прилипалка\\r\\n\\t\\t// console.clear()\\r\\n\\r\\n\\t\\tif (this.bigBox) this.checkBigBox(); // если есть большая коробка проверяем и позиционируем с ней\\r\\n\\r\\n\\t\\t// this.activBox.coliziStop = this.getBox(100,70,150,150);\\r\\n\\t\\tthis.moveBoxFromCollStop();\\r\\n\\r\\n\\t\\tthis.collisionBox = this.getCollisionBox(this.activBox, this.arrBox, this.activBox);\\r\\n\\r\\n\\t\\tif (this.collisionBox.length == 0) { // пересечений нет\\r\\n\\t\\t\\tthis._isCollisionAvtive = false;\\r\\n\\t\\t\\tif (!this.isInBigBox(this.activBox)) {\\r\\n\\t\\t\\t\\tif (this.funErr) this.funErr(this.activBox);\\r\\n\\r\\n\\t\\t\\t\\tisCorrect = false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn isCorrect;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._isCollisionAvtive = true;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar pos = []; // возможные позиции\\r\\n\\r\\n\\t\\tthis.findPosition1(pos);\\r\\n\\t\\tthis.removePositFromHard(pos);\\r\\n\\r\\n\\t\\tif (pos.length == 0) {\\r\\n\\t\\t\\tthis.findPosition2(pos);\\r\\n\\t\\t\\t// this.removePositFromHard(pos);\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tif (pos.length == 0) {\\r\\n\\t\\t\\tif (this.funErr) this.funErr(this.activBox);\\r\\n\\t\\t\\tisCorrect = false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// ищем ближайщую позицию из возможных\\r\\n\\t\\tvar res = this.collUtil.findMinPosition(pos, this.activBox); // ищем ближайщую позицию к activBox\\r\\n\\r\\n\\t\\tif (b) {\\r\\n\\t\\t\\tthis.dragBox.x = res.x;\\r\\n\\t\\t\\tthis.dragBox.y = res.y;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.activBox.x = res.x;\\r\\n\\t\\t\\tthis.activBox.y = res.y;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn isCorrect;\\r\\n\\t\\t// if (!this.isInBigBox(this.activBox)) if (this.activBox.funErr) this.activBox.funErr();\\r\\n\\t\\t// console.clear()\\r\\n\\r\\n\\t\\t// if(this.isStick) this.stick();// прилипалка\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getCollStop = function (isx, isFirst) {\\r\\n\\t\\tif (this.activBox.coliziStop) {\\r\\n\\t\\t\\tif (isx) {\\r\\n\\t\\t\\t\\tif (isFirst) {\\r\\n\\t\\t\\t\\t\\treturn this.activBox.coliziStop.x;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\treturn this.activBox.coliziStop.x + this.activBox.coliziStop.width;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif (isFirst) {\\r\\n\\t\\t\\t\\t\\treturn this.activBox.coliziStop.y;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t// проверка соответствия правельных параметров стопера по высоте\\r\\n\\t\\t\\t\\t\\tvar h = Math.max(this.activBox.coliziStop.height, this.activBox.height);\\r\\n\\t\\t\\t\\t\\tif (this.activBox.coliziStop.height == 0) h = 0;\\r\\n\\t\\t\\t\\t\\treturn this.activBox.coliziStop.y + h;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn false;\\r\\n\\t};\\r\\n\\r\\n\\tthis.moveBoxFromCollStop = function () {\\r\\n\\t\\tvar x = this.getCollStop(true, true);\\r\\n\\t\\tif (x === false) return;\\r\\n\\t\\tvar x1 = this.getCollStop(true, false);\\r\\n\\t\\tvar y = this.getCollStop(false, true);\\r\\n\\t\\tvar y1 = this.getCollStop(false, false);\\r\\n\\r\\n\\t\\tif (this.activBox.x + this.activBox.width > x1) {\\r\\n\\t\\t\\tthis.activBox.x = x1 - this.activBox.width;\\r\\n\\t\\t}\\r\\n\\t\\tif (this.activBox.x < x) {\\r\\n\\t\\t\\tthis.activBox.x = x;\\r\\n\\t\\t}\\r\\n\\t\\tif (this.activBox.y + this.activBox.height > y1) {\\r\\n\\t\\t\\tthis.activBox.y = y1 - this.activBox.height;\\r\\n\\t\\t}\\r\\n\\t\\tif (this.activBox.y < y) {\\r\\n\\t\\t\\tthis.activBox.y = y;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\t// прилипать краями к краям\\r\\n\\tthis.stick = function () {\\r\\n\\t\\tthis.collUtil.stickBox(this.activBox, this.arrBox, this.disStick);\\r\\n\\t};\\r\\n\\r\\n\\t// позиционируем бокс с миром если он в позиции большой коробки\\r\\n\\tthis.redactBox = function (box) {\\r\\n\\t\\tthis.activBox = box;\\r\\n\\t\\tthis.arrBox.push(box);\\r\\n\\t\\tvar isCorrect = this.correct();\\r\\n\\t\\tthis.arrBox.pop();\\r\\n\\t\\t//this.removeBoxInArr(this.arrBox, box);\\r\\n\\t\\tthis.activBox = null;\\r\\n\\t\\treturn isCorrect;\\r\\n\\t};\\r\\n\\r\\n\\t// удаляем позиции если они не соответствуют жестким позициям\\r\\n\\tthis.removePositFromHard = function (pos) {\\r\\n\\t\\tvar x = this.getCollStop(true, true);\\r\\n\\t\\tif (x === false) return;\\r\\n\\t\\tvar x1 = this.getCollStop(true, false);\\r\\n\\t\\tvar y = this.getCollStop(false, true);\\r\\n\\t\\tvar y1 = this.getCollStop(false, false);\\r\\n\\t\\tfor (var i = 0; i < pos.length; i++) {\\r\\n\\t\\t\\tif (pos[i] && pos[i].y < y) {\\r\\n\\t\\t\\t\\tpos.splice(i--, 1);\\r\\n\\t\\t\\t} else if (pos[i] && pos[i].y > y1) {\\r\\n\\t\\t\\t\\tpos.splice(i--, 1);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (pos[i] && pos[i].x < x) {\\r\\n\\t\\t\\t\\tpos.splice(i--, 1);\\r\\n\\t\\t\\t} else if (pos[i] && pos[i].x > x1) {\\r\\n\\t\\t\\t\\tpos.splice(i--, 1);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (Math.abs(Math.abs(y1) - Math.abs(y)) > 0) {// если активный бокс не привязан жестко к высоте тоесть coliziStop.height > 0\\r\\n\\t\\t\\t\\tif (pos[i] && pos[i].y + pos[i].height > y1) {\\r\\n\\t\\t\\t\\t\\tpos.splice(i--, 1);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\t// ищем позиции вторым способом ( слева права низ верх поиском в глубину)\\r\\n\\tthis.findPosition2 = function (pos) {\\r\\n\\t\\tvar postemp = [];\\r\\n\\t\\tfor (var i = 0; i < this.collisionBox.length; i++) {\\r\\n\\t\\t\\tthis.seeArrBox = [];\\r\\n\\t\\t\\tthis.findLevel = 0;\\r\\n\\t\\t\\tpostemp = this.freePosition(this.activBox, this.collisionBox[i], this.arrBox);\\r\\n\\t\\t\\tfor (var j = 0; j < postemp.length; j++) {\\r\\n\\t\\t\\t\\tpos.push(postemp[j]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\t// ищем позиции первым способом ( вокруг активного бокса   )\\r\\n\\tthis.findPosition1 = function (pos) {\\r\\n\\t\\tvar b = {};\\r\\n\\t\\tb.x = this.activBox.x;\\r\\n\\t\\tb.y = this.activBox.y;\\r\\n\\t\\tb.width = this.activBox.width;\\r\\n\\t\\tb.height = this.activBox.height;\\r\\n\\t\\tb.offset = 0;\\r\\n\\t\\tif (this.activBox.offset)b.offset = this.activBox.offset;\\r\\n\\r\\n\\t\\tfor (var i = 0; i < this.collisionBox.length; i++) {\\r\\n\\t\\t\\tvar a = this.getAngleBox(b, this.collisionBox[i]);\\r\\n\\t\\t\\t// console.clear()\\r\\n\\t\\t\\tthis.moveBoxFromCollBox(b, this.collisionBox[i], a);\\r\\n\\t\\t\\tif (this.isInBigBox(b, 2)) {// если коробка внутри\\r\\n\\t\\t\\t\\tif (this.getCollisionBox(b, this.arrBox, this.activBox).length == 0) { // если колизий нету добавляем в возможные позиции\\r\\n\\t\\t\\t\\t\\tpos.push(b);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// двигаем бокс смотря какой угол\\r\\n\\tthis.moveBoxFromCollBox = function (box, boxCol, angle) {\\r\\n\\t\\tvar c1 = {};//\\r\\n\\t\\tvar c = {};//\\r\\n\\t\\tc.x = boxCol.x + boxCol.width / 2;\\r\\n\\t\\tc.y = boxCol.y + boxCol.height / 2;\\r\\n\\t\\tc1.x = boxCol.x - (boxCol.offset || 0);\\r\\n\\t\\tc1.y = boxCol.y - (boxCol.offset || 0);\\r\\n\\t\\tvar a1 = this.getAngle(c, c1);//-135\\r\\n\\t\\tc1.x = boxCol.x + boxCol.width + (boxCol.offset || 0);\\r\\n\\t\\tc1.y = boxCol.y + boxCol.height + (boxCol.offset || 0);\\r\\n\\t\\tvar a2 = this.getAngle(c, c1);//45\\r\\n\\t\\tc1.x = boxCol.x + boxCol.width + (boxCol.offset || 0);\\r\\n\\t\\tc1.y = boxCol.y - (boxCol.offset || 0);\\r\\n\\t\\tvar a3 = this.getAngle(c, c1);//-45\\r\\n\\t\\tc1.x = boxCol.x - (boxCol.offset || 0);\\r\\n\\t\\tc1.y = boxCol.y + boxCol.height + (boxCol.offset || 0);\\r\\n\\t\\tvar a4 = this.getAngle(c, c1);//135\\r\\n\\r\\n\\t\\tif (angle >= a3 && angle < a2) { // left\\r\\n\\t\\t\\tbox.x = (boxCol.x - box.width) - (box.offset || 0) - (boxCol.offset || 0); //(boxCol.x-(boxCol.offset||0)) - (box.width+(box.offset||0));\\r\\n\\t\\t}\\r\\n\\t\\tif (angle >= a2 && angle < a4) {// top\\r\\n\\t\\t\\tbox.y = (boxCol.y - box.height) - (box.offset || 0) - (boxCol.offset || 0);\\r\\n\\t\\t}\\r\\n\\t\\tif (angle >= a1 && angle < a3) { // bottom\\r\\n\\t\\t\\tbox.y = (boxCol.y + boxCol.height) + (box.offset || 0) + (boxCol.offset || 0);\\r\\n\\t\\t}\\r\\n\\t\\tif (angle >= a4 || angle < a1) { // right\\r\\n\\t\\t\\tbox.x = (boxCol.x + boxCol.width) + (box.offset || 0) + (boxCol.offset || 0);\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\t// достать угол между (центрами )боксами\\r\\n\\tthis.getAngleBox = function (box, box2) {\\r\\n\\t\\tvar c1 = {};//box центр\\r\\n\\t\\tvar c2 = {};//box2 центр\\r\\n\\t\\tc1.x = box.x + box.width / 2;\\r\\n\\t\\tc1.y = box.y + box.height / 2;\\r\\n\\t\\tc2.x = box2.x + box2.width / 2;\\r\\n\\t\\tc2.y = box2.y + box2.height / 2;\\r\\n\\t\\treturn this.getAngle(c1, c2);\\r\\n\\t};\\r\\n\\r\\n\\tthis.maxLevel = 1;\\r\\n\\tthis.findLevel = 0;\\r\\n\\tthis.seeArrBox = [];\\r\\n\\t// свободные позиции поиском в глубину(по колизиям)\\r\\n\\t//box - для нее ищем позиции\\r\\n\\t//boxCol - вокруг этой коробки\\r\\n\\t//arrBox - при поиске учитывать коробки\\r\\n\\tthis.freePosition = function (box, boxCol, arrBox) {\\r\\n\\t\\tthis.findLevel++;\\r\\n\\r\\n\\t\\tthis.seeArrBox.push(boxCol);\\r\\n\\t\\tvar arrPosit = this.getPositionBox(box, boxCol); // возможные позиции коробки\\r\\n\\t\\tvar freePos = []; // свободные позиции коробки\\r\\n\\t\\tvar arrBoxCol = [];\\r\\n\\t\\tvar tempCol = [];\\r\\n\\t\\tfor (var i = 0; i < arrPosit.length; i++) {\\r\\n\\t\\t\\tif (this.isInBigBox(arrPosit[i], 2)) {// если коробка внутри\\r\\n\\r\\n\\t\\t\\t\\ttempCol = this.getCollisionBox(arrPosit[i], arrBox, box);\\r\\n\\t\\t\\t\\tif (tempCol.length == 0) {  // колизий нету добавляем позицию\\r\\n\\t\\t\\t\\t\\tfreePos.push(arrPosit[i]);\\r\\n\\t\\t\\t\\t\\t// continue;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfor (var j = 0; j < tempCol.length; j++) {\\r\\n\\t\\t\\t\\t\\tif (arrBoxCol.indexOf(tempCol[j]) < 0) {\\r\\n\\t\\t\\t\\t\\t\\tarrBoxCol.push(tempCol[j]);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (this.activBox.coliziStop) {\\r\\n\\t\\t\\tthis.removePositFromHard(freePos);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (freePos.length == 0) {\\r\\n\\t\\t\\tif (this.findLevel > this.maxLevel) {\\r\\n\\t\\t\\t\\t// this.findLevel=0;\\r\\n\\t\\t\\t\\treturn freePos;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor (var i = 0; i < arrBoxCol.length; i++) {\\r\\n\\t\\t\\t\\tif (this.equalsBox(this.seeArrBox, arrBoxCol[i])) continue;// если смотрели коробку , пропускаем\\r\\n\\t\\t\\t\\tvar temp = this.freePosition(box, arrBoxCol[i], arrBox);\\r\\n\\t\\t\\t\\tfor (var j = 0; j < temp.length; j++) {\\r\\n\\t\\t\\t\\t\\tif (freePos.indexOf(temp[j]) < 0) {\\r\\n\\t\\t\\t\\t\\t\\tfreePos.push(temp[j]);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\t\\t// this.findLevel=0;\\r\\n\\t\\tthis.findLevel--;\\r\\n\\t\\treturn freePos;\\r\\n\\t};\\r\\n\\r\\n\\t// взять позиции вокруг boxCol\\r\\n\\tthis.getPositionBox = function (box, boxCol) {\\r\\n\\r\\n\\t\\treturn [\\r\\n\\t\\t\\t// left\\r\\n\\t\\t\\tthis.getBox((boxCol.x - box.width) - (box.offset || 0) - (boxCol.offset || 0),\\r\\n\\t\\t\\t\\tbox.y,\\r\\n\\t\\t\\t\\tbox.width, box.height, box.offset, box.offset, box.offset, box.offset),\\r\\n\\t\\t\\t// right\\r\\n\\t\\t\\tthis.getBox((boxCol.x + boxCol.width) + (box.offset || 0) + (boxCol.offset || 0),\\r\\n\\t\\t\\t\\tbox.y,\\r\\n\\t\\t\\t\\tbox.width, box.height, box.offset, box.offset, box.offset, box.offset),\\r\\n\\t\\t\\t// top\\r\\n\\t\\t\\tthis.getBox(box.x,\\r\\n\\t\\t\\t\\t(boxCol.y - box.height) - (box.offset || 0) - (boxCol.offset || 0),\\r\\n\\t\\t\\t\\tbox.width, box.height, box.offset, box.offset, box.offset, box.offset),\\r\\n\\t\\t\\t// bottom\\r\\n\\t\\t\\tthis.getBox(box.x,\\r\\n\\t\\t\\t\\t(boxCol.y + boxCol.height) + (box.offset || 0) + (boxCol.offset || 0),\\r\\n\\t\\t\\t\\tbox.width, box.height, box.offset, box.offset, box.offset, box.offset),\\r\\n\\t\\t\\t// left-top\\r\\n\\t\\t\\tthis.getBox((boxCol.x - box.width) - (box.offset || 0) - (boxCol.offset || 0),\\r\\n\\t\\t\\t\\t(boxCol.y - box.height) - (box.offset || 0) - (boxCol.offset || 0),\\r\\n\\t\\t\\t\\tbox.width, box.height, box.offset, box.offset, box.offset, box.offset),\\r\\n\\t\\t\\t// right-top\\r\\n\\t\\t\\tthis.getBox((boxCol.x + boxCol.width) + (box.offset || 0) + (boxCol.offset || 0),\\r\\n\\t\\t\\t\\t(boxCol.y - box.height) - (box.offset || 0) - (boxCol.offset || 0),\\r\\n\\t\\t\\t\\tbox.width, box.height, box.offset, box.offset, box.offset, box.offset),\\r\\n\\t\\t\\t// right-bottom\\r\\n\\t\\t\\tthis.getBox((boxCol.x + boxCol.width) + (box.offset || 0) + (boxCol.offset || 0),\\r\\n\\t\\t\\t\\t(boxCol.y + boxCol.height) + (box.offset || 0) + (boxCol.offset || 0),\\r\\n\\t\\t\\t\\tbox.width, box.height, box.offset, box.offset, box.offset, box.offset),\\r\\n\\t\\t\\t// left-bottom\\r\\n\\t\\t\\tthis.getBox((boxCol.x - box.width) - (box.offset || 0) - (boxCol.offset || 0),\\r\\n\\t\\t\\t\\t(boxCol.y + boxCol.height) + (box.offset || 0) + (boxCol.offset || 0),\\r\\n\\t\\t\\t\\tbox.width, box.height, box.offset, box.offset, box.offset, box.offset),\\r\\n\\t\\t]\\r\\n\\t};\\r\\n\\r\\n\\tthis.getBox = function (x, y, width, height, offset) {\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tx: x || 0, y: y || 0, width: width || 0, height: height || 0,\\r\\n\\t\\t\\toffset: offset || 0, offset: offset || 0, offset: offset || 0, offset: offset || 0\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\r\\n\\tthis.upData = function () {\\r\\n\\t\\tif (this.activBox == null) return;\\r\\n\\r\\n\\t\\tthis.collisionBox = this.getCollisionBox(this.activBox, this.arrBox, this.activBox);\\r\\n\\t\\tif (this.collisionBox.length > 0) {\\r\\n\\t\\t\\tthis._isCollisionAvtive = true;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis._isCollisionAvtive = false;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.updateWorld = function () {\\r\\n\\t\\tvar bool = false;\\r\\n\\t\\tfor (var i = 0; i < this.arrBox.length; i++) {\\r\\n\\t\\t\\tthis.activBox = this.arrBox[i];\\r\\n\\t\\t\\tbool = this.correct();\\r\\n\\t\\t\\tif (!bool && this.fun) {\\r\\n\\t\\t\\t\\tthis.fun(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\t// достаем пересеченые боксы\\r\\n\\t// не учитываем скрытые бокты и ofsetBox\\r\\n\\tthis.getCollisionBox = function (box, arrBox, ofsetBox) {\\r\\n\\t\\tif (arrBox == undefined)arrBox = this.arrBox;\\r\\n\\t\\tvar collisionBox = [];\\r\\n\\t\\tif (!box) return collisionBox;\\r\\n\\t\\tvar b;\\r\\n\\t\\tfor (var i = 0; i < arrBox.length; i++) {\\r\\n\\t\\t\\tb = arrBox[i];\\r\\n\\t\\t\\tif (box == b || ofsetBox == b) continue;\\r\\n\\t\\t\\tif (this.offsetBox && this.offsetBox == b) continue;\\r\\n\\t\\t\\tif (b.visible != undefined) {\\r\\n\\t\\t\\t\\tif (b.visible == false) {\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (this.collUtil.isCollisionRectangle(\\r\\n\\t\\t\\t\\t\\tbox.x - (box.offset || 0), box.y - (box.offset || 0),\\r\\n\\t\\t\\t\\t\\tbox.width + (box.offset || 0) + (box.offset || 0), box.height + (box.offset || 0) + (box.offset || 0),\\r\\n\\t\\t\\t\\t\\tb.x - (b.offset || 0), b.y - (b.offset || 0),\\r\\n\\t\\t\\t\\t\\tb.width + (b.offset || 0) + (b.offset || 0), b.height + (b.offset || 0) + (b.offset || 0))) {\\r\\n\\t\\t\\t\\tcollisionBox.push(b);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//----\\r\\n\\t\\tfor (var i = 0; i < this.hideBox.length; i++) {\\r\\n\\t\\t\\tb = this.hideBox[i];\\r\\n\\t\\t\\tif (box == b || ofsetBox == b) continue;\\r\\n\\t\\t\\tif (this.offsetBox && this.offsetBox == b) continue;\\r\\n\\t\\t\\tif (b.visible != undefined) {\\r\\n\\t\\t\\t\\tif (b.visible == false) {\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (this.collUtil.isCollisionRectangle(\\r\\n\\t\\t\\t\\t\\tbox.x - (box.offset || 0), box.y - (box.offset || 0),\\r\\n\\t\\t\\t\\t\\tbox.width + (box.offset || 0) + (box.offset || 0), box.height + (box.offset || 0) + (box.offset || 0),\\r\\n\\t\\t\\t\\t\\tb.x - (b.offset || 0), b.y - (b.offset || 0),\\r\\n\\t\\t\\t\\t\\tb.width + (b.offset || 0) + (b.offset || 0), b.height + (b.offset || 0) + (b.offset || 0))) {\\r\\n\\t\\t\\t\\tcollisionBox.push(b);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn collisionBox;\\r\\n\\t};\\r\\n\\r\\n\\t// добавление скрытых боксов из масива point x y\\r\\n\\tthis.checkArrPoint = function () {\\r\\n\\t\\t// this.hideBox = [];\\r\\n\\t\\t// for (var i = 0; i < this.arrPointX.length; i++) {\\r\\n\\t\\t//     this.hideBox.push(this.getBox(this.arrPointX[i], this.bigBox.y, 1, this.bigBox.height, this.offsetHideBox||0));\\r\\n\\t\\t// }\\r\\n\\t\\t// for (var i = 0; i < this.arrPointY.length; i++) {\\r\\n\\t\\t//     this.hideBox.push(this.getBox(this.bigBox.x, this.arrPointY[i], this.bigBox.width, 1, this.offsetHideBox||0));\\r\\n\\t\\t// }\\r\\n\\t}\\r\\n\\r\\n\\t// очистка точек вертикалей , горизонталей\\r\\n\\tthis.clearArrPoint = function () {\\r\\n\\t\\tthis.arrPointX = [];\\r\\n\\t\\tthis.arrPointY = [];\\r\\n\\t\\tthis.hideBox = [];\\r\\n\\t}\\r\\n\\r\\n\\t// проверка с большой коробкой\\r\\n\\tthis.checkBigBox = function () {\\r\\n\\t\\t// проверяем колизии с большым боксом\\r\\n\\t\\tvar arr = [];//коробки которые в нутри большой коробки\\r\\n\\t\\t// console.clear();\\r\\n\\t\\tfor (var i = 0; i < this.arrBox.length; i++) {\\r\\n\\t\\t\\t// лежит в коробке\\r\\n\\t\\t\\tif (this.isInBigBox(this.arrBox[i])) {\\r\\n\\r\\n\\r\\n\\t\\t\\t} else {// не лежит в большой коробке , проверяем пересечения что б потом поместить во внутрь\\r\\n\\t\\t\\t\\t// в колизии с большой коробкой\\r\\n\\t\\t\\t\\tif (this.isCollisionBigBox(this.arrBox[i])) {\\r\\n\\t\\t\\t\\t\\tif (this.arrBox[i].x - (this.arrBox[i].offset || 0) < this.bigBox.x) {\\r\\n\\t\\t\\t\\t\\t\\tthis.arrBox[i].x = this.bigBox.x + (this.arrBox[i].offset || 0);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif (this.arrBox[i].y - (this.arrBox[i].offset || 0) < this.bigBox.y) {\\r\\n\\t\\t\\t\\t\\t\\tthis.arrBox[i].y = this.bigBox.y + (this.arrBox[i].offset || 0);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif (this.arrBox[i].x + this.arrBox[i].width + (this.arrBox[i].offset || 0) > this.bigBox.x + this.bigBox.width) {\\r\\n\\t\\t\\t\\t\\t\\tthis.arrBox[i].x = this.bigBox.x + this.bigBox.width - (this.arrBox[i].width + (this.arrBox[i].offset || 0) );\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tif (this.arrBox[i].y + this.arrBox[i].height + (this.arrBox[i].offset || 0) > this.bigBox.y + this.bigBox.height) {\\r\\n\\t\\t\\t\\t\\t\\tthis.arrBox[i].y = this.bigBox.y + this.bigBox.height - (this.arrBox[i].height + (this.arrBox[i].offset || 0) );\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t// if (this.fun) {\\r\\n\\t\\t\\t\\t\\t//     // this.fun(i);\\r\\n\\t\\t\\t\\t\\t// }\\r\\n\\r\\n\\t\\t\\t\\t} else {// коробка далеко и не прикасается к большой коробке\\r\\n\\t\\t\\t\\t\\tif (this.activBox && this.activBox == this.arrBox[i]) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// if (this.fun) {\\r\\n\\t\\t\\t\\t\\t\\t//     this.fun(i);\\r\\n\\t\\t\\t\\t\\t\\t// }\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\t// лежит в большой коробке\\r\\n\\tthis.isInBigBox = function (box, see) {\\r\\n\\t\\tif (!box) return true;\\r\\n\\t\\treturn this.bigBox ? (this.collUtil.isPutIn(this.bigBox.x, this.bigBox.y, this.bigBox.width, this.bigBox.height,\\r\\n\\t\\t\\tbox.x - (box.offset || 0) + (see || 0), box.y - (box.offset || 0) + (see || 0), box.width + (box.offset || 0) + (box.offset || 0) - (see || 0), box.height + (box.offset || 0) + (box.offset || 0) - (see || 0))) : true;\\r\\n\\t};\\r\\n\\t// в колизии с большой коробке\\r\\n\\tthis.isCollisionBigBox = function (box) {\\r\\n\\t\\tif (!box) return false;\\r\\n\\t\\treturn this.bigBox ? (this.collUtil.isCollisionRectangle(this.bigBox.x, this.bigBox.y, this.bigBox.width, this.bigBox.height,\\r\\n\\t\\t\\tbox.x - (box.offset || 0), box.y - (box.offset || 0), box.width + (box.offset || 0) + (box.offset || 0), box.height + (box.offset || 0) + (box.offset || 0))) : false;\\r\\n\\t};\\r\\n\\r\\n\\tthis.equalsBox = function (arr, box) {\\r\\n\\t\\tfor (var i = 0; i < arr.length; i++) {\\r\\n\\t\\t\\tif (arr[i].x == box.x && arr[i].y == box.y && arr[i].width == box.width && arr[i].height == box.height) {\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t};\\r\\n\\r\\n\\t//Получение угла между двумя точками градусы\\r\\n\\tthis.getAngle = function (a, b) {\\r\\n\\t\\treturn 180 * Math.atan2(b.y - a.y, b.x - a.x) / (Math.PI);\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tthis.correctShahY = function (rect) {\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tthis.offsetRect = 0;\\r\\n\\t// растагиваем рект за края\\r\\n\\t// rect - ( x, y, width, heigth)\\r\\n\\t// curs     1_|_2\\r\\n\\t//          4¯|¯3\\r\\n\\t// jumpy - кратность(прыжок) по высоте и y\\r\\n\\tthis.checkRect = function (rect, curs, jumpy) {\\r\\n\\t\\tvar addedOffset = false;\\r\\n\\t\\tvar dis = 0;\\r\\n\\t\\tvar res = 0;\\r\\n\\t\\tvar startPoint = {};\\r\\n\\t\\tvar angel = 0;\\r\\n\\t\\tvar old = self.getBox(rect.x, rect.y, rect.width, rect.height);\\r\\n\\t\\tif (rect.offset == undefined) {\\r\\n\\t\\t\\taddedOffset = true;\\r\\n\\t\\t\\trect.offset = this.offsetRect || 0;// добавили отступ , в низу удалим\\r\\n\\t\\t}\\r\\n\\t\\tcurs = parseInt(curs)\\r\\n\\t\\tswitch (curs) {\\r\\n\\t\\t\\tcase 0 : {\\r\\n\\t\\t\\t\\tvar ac = this.activBox;\\r\\n\\t\\t\\t\\tthis.offsetBox = ac;\\r\\n\\t\\t\\t\\tthis.activBox = rect;\\r\\n\\t\\t\\t\\tthis.arrBox.push(rect);\\r\\n\\t\\t\\t\\tthis.correct();\\r\\n\\t\\t\\t\\tthis.arrBox.pop();\\r\\n\\t\\t\\t\\tthis.activBox = ac;\\r\\n\\t\\t\\t\\tthis.offsetBox = false;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 1: { // верх лево\\r\\n\\t\\t\\t\\tstartPoint = {x: rect.x + rect.width, y: rect.y + rect.height};\\r\\n\\t\\t\\t\\tres = this.findAllBoxVect(startPoint, curs, rect);\\r\\n\\t\\t\\t\\tif (res.y !== false) {\\r\\n\\t\\t\\t\\t\\tif (rect.y <= res.y) {\\r\\n\\t\\t\\t\\t\\t\\tdis = Math.abs(rect.y - res.y)\\r\\n\\t\\t\\t\\t\\t\\trect.y = res.y;\\r\\n\\t\\t\\t\\t\\t\\trect.height -= Math.abs(dis);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (res.x !== false) {\\r\\n\\t\\t\\t\\t\\tif (rect.x <= res.x) {\\r\\n\\t\\t\\t\\t\\t\\tdis = Math.abs(rect.x - res.x)\\r\\n\\t\\t\\t\\t\\t\\trect.x = res.x;\\r\\n\\t\\t\\t\\t\\t\\trect.width -= Math.abs(dis);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 2: { // вверх право\\r\\n\\t\\t\\t\\tstartPoint = {x: rect.x, y: rect.y + rect.height};\\r\\n\\t\\t\\t\\tres = this.findAllBoxVect(startPoint, curs, rect);\\r\\n\\t\\t\\t\\tif (res.y !== false && !isNaN(res.y)) {\\r\\n\\t\\t\\t\\t\\tif (rect.y <= res.y) {\\r\\n\\t\\t\\t\\t\\t\\tdis = Math.abs(rect.y - res.y)\\r\\n\\t\\t\\t\\t\\t\\trect.y = res.y;\\r\\n\\t\\t\\t\\t\\t\\trect.height -= Math.abs(dis);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (res.x !== false && !isNaN(res.x)) {\\r\\n\\t\\t\\t\\t\\tif (rect.x + rect.width >= res.x) {\\r\\n\\t\\t\\t\\t\\t\\tdis = Math.abs(rect.x + rect.width - res.x)\\r\\n\\t\\t\\t\\t\\t\\trect.width -= Math.abs(dis);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 3: {// низ право\\r\\n\\t\\t\\t\\tstartPoint = {x: rect.x, y: rect.y};\\r\\n\\t\\t\\t\\tres = this.findAllBoxVect(startPoint, curs, rect);\\r\\n\\r\\n\\t\\t\\t\\tif (res.y !== false && !isNaN(res.y)) {\\r\\n\\t\\t\\t\\t\\tif (rect.y + rect.height >= res.y) {\\r\\n\\t\\t\\t\\t\\t\\tdis = Math.abs(rect.y + rect.height - res.y)\\r\\n\\t\\t\\t\\t\\t\\trect.height -= Math.abs(dis);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (res.x !== false) {\\r\\n\\t\\t\\t\\t\\tif (rect.x + rect.width >= res.x) {\\r\\n\\t\\t\\t\\t\\t\\tdis = Math.abs(rect.x + rect.width - res.x)\\r\\n\\t\\t\\t\\t\\t\\trect.width -= Math.abs(dis);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 4: { // низ лево\\r\\n\\t\\t\\t\\tstartPoint = {x: rect.x + rect.width, y: rect.y};\\r\\n\\t\\t\\t\\tres = this.findAllBoxVect(startPoint, curs, rect);\\r\\n\\r\\n\\t\\t\\t\\tif (res.y !== false && !isNaN(res.y)) {\\r\\n\\t\\t\\t\\t\\tif (rect.y + rect.height >= res.y) {\\r\\n\\t\\t\\t\\t\\t\\tdis = Math.abs(rect.y + rect.height - res.y)\\r\\n\\t\\t\\t\\t\\t\\trect.height -= Math.abs(dis);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (res.x !== false && !isNaN(res.x)) {\\r\\n\\t\\t\\t\\t\\tif (rect.x <= res.x) {\\r\\n\\t\\t\\t\\t\\t\\tdis = Math.abs(rect.x - res.x)\\r\\n\\t\\t\\t\\t\\t\\trect.x = res.x;\\r\\n\\t\\t\\t\\t\\t\\trect.width -= Math.abs(dis);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdefault :\\r\\n\\t\\t\\t\\tconsole.warn(\\'curs не определен\\', curs)\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (jumpy) {\\r\\n\\t\\t\\tvar d = (rect.y + jumpy) % jumpy;\\r\\n\\t\\t\\trect.y = rect.y - d;\\r\\n\\t\\t\\tif (curs > 0) {\\r\\n\\t\\t\\t\\trect.height = rect.height - ( (-d) || (rect.height + jumpy) % jumpy)\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (addedOffset) {\\r\\n\\t\\t\\tdelete rect.offset;// удаляем отступ\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn parseInt(rect.x) === parseInt(old.x) /*&& parseInt(old.y) === parseInt(rect.y)*/ && parseInt(rect.width) === parseInt(old.width) /*&& parseInt(old.height) === parseInt(rect.height)*/;\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t// p - стартовая точка\\r\\n\\t// curs - направление\\r\\n\\tthis.findAllBoxVect = function (p, curs, rect) {\\r\\n\\t\\tvar arrBoxLuch = [];\\r\\n\\t\\tvar arrX = [];\\r\\n\\t\\tvar arrY = [];\\r\\n\\t\\t// находим боксы которые попадают в диапазон просмотра по направление curs\\r\\n\\t\\tfor (var i = 0; i < this.arrBox.length; i++) {\\r\\n\\t\\t\\tif (this.arrBox[i] == this.activBox) continue;\\r\\n\\t\\t\\tif (this.checkBoxCurs(p.x, p.y, this.arrBox[i], curs)) {\\r\\n\\t\\t\\t\\tarrBoxLuch.push(this.arrBox[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// определяем куда относятся боксы к x или y\\r\\n\\t\\tthis.sortBoxXY(arrX, arrY, arrBoxLuch, curs, rect);\\r\\n\\r\\n\\t\\tarrX.sort(function (b1, b2) {//сортируем по x\\r\\n\\t\\t\\treturn self.sortBoxCursor(b1, b2, curs, true);\\r\\n\\t\\t});\\r\\n\\t\\tarrY.sort(function (b1, b2) {//сортируем по y\\r\\n\\t\\t\\treturn self.sortBoxCursor(b1, b2, curs, false);\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\tvar res = {x: 0, y: 0};\\r\\n\\r\\n\\t\\tswitch (curs) {\\r\\n\\t\\t\\tcase 1: { // верх лево\\r\\n\\t\\t\\t\\tif (arrX[0]) {\\r\\n\\t\\t\\t\\t\\tres.x = arrX[0].x + arrX[0].width + (arrX[0].offset || 0) + (rect.offset || 0);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tres.x = self.bigBox.x + (rect.offset || 0)\\r\\n\\t\\t\\t\\t\\tvar sx = this.getCollStop(true, true);\\r\\n\\t\\t\\t\\t\\tif (sx != false) {\\r\\n\\t\\t\\t\\t\\t\\tres.x = sx;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (arrY[0]) {\\r\\n\\t\\t\\t\\t\\tres.y = arrY[0].y + arrY[0].height + (arrY[0].offset || 0) + (rect.offset || 0)\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tres.y = self.bigBox.y + (rect.offset || 0)\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn res;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 2: { // верх право\\r\\n\\r\\n\\t\\t\\t\\tif (arrX[0]) {\\r\\n\\t\\t\\t\\t\\tres.x = arrX[0].x - (arrX[0].offset || 0) - (rect.offset || 0);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tres.x = self.bigBox.x + self.bigBox.width - (rect.offset || 0)\\r\\n\\t\\t\\t\\t\\tvar sx = this.getCollStop(true, false);\\r\\n\\t\\t\\t\\t\\tif (sx != false) {\\r\\n\\t\\t\\t\\t\\t\\tres.x = sx;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (arrY[0]) {\\r\\n\\t\\t\\t\\t\\tres.y = arrY[0].y + arrY[0].height + (arrY[0].offset || 0) + (rect.offset || 0)\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tres.y = self.bigBox.y + (rect.offset || 0)\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn res;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 3: {// низ право\\r\\n\\r\\n\\t\\t\\t\\tif (arrX[0]) {\\r\\n\\t\\t\\t\\t\\tres.x = arrX[0].x - (arrX[0].offset || 0) - (rect.offset || 0);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tres.x = self.bigBox.x + self.bigBox.width - (rect.offset || 0)\\r\\n\\t\\t\\t\\t\\tvar sx = this.getCollStop(true, false);\\r\\n\\t\\t\\t\\t\\tif (sx != false) {\\r\\n\\t\\t\\t\\t\\t\\tres.x = sx;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (arrY[0]) {\\r\\n\\t\\t\\t\\t\\tres.y = arrY[0].y - (arrY[0].offset || 0) - (rect.offset || 0)\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tres.y = self.bigBox.y + self.bigBox.height - (rect.offset || 0)\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn res;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 4: { // низ лево\\r\\n\\r\\n\\t\\t\\t\\tif (arrX[0]) {\\r\\n\\t\\t\\t\\t\\tres.x = arrX[0].x + arrX[0].width + (arrX[0].offset || 0) + (rect.offset || 0);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tres.x = self.bigBox.x + (rect.offset || 0)\\r\\n\\t\\t\\t\\t\\tvar sx = this.getCollStop(true, true);\\r\\n\\t\\t\\t\\t\\tif (sx != false) {\\r\\n\\t\\t\\t\\t\\t\\tres.x = sx;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (arrY[0]) {\\r\\n\\t\\t\\t\\t\\tres.y = arrY[0].y - (arrY[0].offset || 0) - (rect.offset || 0)\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tres.y = self.bigBox.y + self.bigBox.height - (rect.offset || 0)\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\treturn res;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// определяем куда относятся боксы к x или y\\r\\n\\tthis.sortBoxXY = function (arrX, arrY, arrBoxLuch, curs, rect) {\\r\\n\\t\\tvar ax = 0;\\r\\n\\t\\tvar ay = 0;\\r\\n\\t\\tfor (var i = 0; i < arrBoxLuch.length; i++) {\\r\\n\\t\\t\\tif (curs == 1) {\\r\\n\\t\\t\\t\\tif (rect.x + rect.width + (rect.offset || 0) <= arrBoxLuch[i].x + arrBoxLuch[i].width + (arrBoxLuch[i].offset || 0)) {\\r\\n\\t\\t\\t\\t\\tax = 1;\\r\\n\\t\\t\\t\\t\\tay = 0;\\r\\n\\t\\t\\t\\t} else if (rect.y + rect.height + (rect.offset || 0) <= (arrBoxLuch[i].y + arrBoxLuch[i].height + (arrBoxLuch[i].offset || 0))) {\\r\\n\\t\\t\\t\\t\\tax = 0;\\r\\n\\t\\t\\t\\t\\tay = 1;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tay = ( rect.x - (rect.offset || 0)) - (arrBoxLuch[i].x + arrBoxLuch[i].width + (arrBoxLuch[i].offset || 0) );\\r\\n\\t\\t\\t\\t\\tax = ( rect.y - (rect.offset || 0)) - (arrBoxLuch[i].y + arrBoxLuch[i].height + (arrBoxLuch[i].offset || 0));\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (curs == 2) {\\r\\n\\t\\t\\t\\tif (rect.x - (rect.offset || 0) >= arrBoxLuch[i].x - (arrBoxLuch[i].offset || 0)) {\\r\\n\\t\\t\\t\\t\\tax = 1;\\r\\n\\t\\t\\t\\t\\tay = 0;\\r\\n\\t\\t\\t\\t} else if (rect.y + rect.height + (rect.offset || 0) <= (arrBoxLuch[i].y + arrBoxLuch[i].height + (arrBoxLuch[i].offset || 0))) {\\r\\n\\t\\t\\t\\t\\tax = 0;\\r\\n\\t\\t\\t\\t\\tay = 1;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tax = ( rect.x + rect.width + (rect.offset || 0)) - ( arrBoxLuch[i].x - (arrBoxLuch[i].offset || 0) );\\r\\n\\t\\t\\t\\t\\tay = (arrBoxLuch[i].y + arrBoxLuch[i].height + ((arrBoxLuch[i].offset || 0)) - ( rect.y - (rect.offset || 0)));\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (curs == 3) {\\r\\n\\t\\t\\t\\tif (rect.x - (rect.offset || 0) >= arrBoxLuch[i].x - (arrBoxLuch[i].offset || 0)) {\\r\\n\\t\\t\\t\\t\\tax = 1;\\r\\n\\t\\t\\t\\t\\tay = 0;\\r\\n\\t\\t\\t\\t} else if (rect.y - (rect.offset || 0) >= arrBoxLuch[i].y - (arrBoxLuch[i].offset || 0)) {\\r\\n\\t\\t\\t\\t\\tax = 0;\\r\\n\\t\\t\\t\\t\\tay = 1;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tax = ( rect.x + rect.width + (rect.offset || 0)) - arrBoxLuch[i].x - (arrBoxLuch[i].offset || 0);\\r\\n\\t\\t\\t\\t\\tay = ( rect.y + rect.height + (rect.offset || 0)) - arrBoxLuch[i].y - (arrBoxLuch[i].offset || 0);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (curs == 4) {\\r\\n\\t\\t\\t\\tif (rect.x + rect.width + (rect.offset || 0) <= arrBoxLuch[i].x + arrBoxLuch[i].width + (arrBoxLuch[i].offset || 0)) {\\r\\n\\t\\t\\t\\t\\tax = 1;\\r\\n\\t\\t\\t\\t\\tay = 0;\\r\\n\\t\\t\\t\\t} else if (rect.y - (rect.offset || 0) >= arrBoxLuch[i].y - (arrBoxLuch[i].offset || 0)) {\\r\\n\\t\\t\\t\\t\\tax = 0;\\r\\n\\t\\t\\t\\t\\tay = 1;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tax = (arrBoxLuch[i].x + arrBoxLuch[i].width + (arrBoxLuch[i].offset || 0)) - ( rect.x - (rect.offset || 0));\\r\\n\\t\\t\\t\\t\\tay = ( rect.y + rect.height + (rect.offset || 0)) - arrBoxLuch[i].y - (arrBoxLuch[i].offset || 0);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (ax < ay) {\\r\\n\\t\\t\\t\\tarrX.push(arrBoxLuch[i]);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tarrY.push(arrBoxLuch[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// определяем кто ближе из b1, b2 по направлению curs,\\r\\n\\t// isx - смотрим по x\\r\\n\\tthis.sortBoxCursor = function (b1, b2, curs, isx) {\\r\\n\\t\\tswitch (curs) {\\r\\n\\t\\t\\tcase 1: { // верх лево\\r\\n\\t\\t\\t\\tif (isx) {\\r\\n\\t\\t\\t\\t\\tif (b1.x + b1.width + (b1.offset || 0) > b2.x + b2.width + (b2.offset || 0)) return -1;\\r\\n\\t\\t\\t\\t\\tif (b1.x + b1.width + (b1.offset || 0) < b2.x + b2.width + (b2.offset || 0)) return 1;\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tif (b1.y + b1.height + (b1.offset || 0) > b2.y + b2.height + (b2.offset || 0)) return -1;\\r\\n\\t\\t\\t\\t\\tif (b1.y + b1.height + (b1.offset || 0) < b2.y + b2.height + (b2.offset || 0)) return 1;\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 2: { // вверх право\\r\\n\\t\\t\\t\\tif (isx) {\\r\\n\\t\\t\\t\\t\\tif (b1.x - (b1.offset || 0) < b2.x - (b2.offset || 0)) return -1;\\r\\n\\t\\t\\t\\t\\tif (b1.x - (b1.offset || 0) > b2.x - (b2.offset || 0)) return 1;\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tif (b1.y + b1.height + (b1.offset || 0) > b2.y + b2.height + (b2.offset || 0)) return -1;\\r\\n\\t\\t\\t\\t\\tif (b1.y + b1.height + (b1.offset || 0) < b2.y + b2.height + (b2.offset || 0)) return 1;\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 3: {// низ право\\r\\n\\t\\t\\t\\tif (isx) {\\r\\n\\t\\t\\t\\t\\tif (b1.x - (b1.offset || 0) < b2.x - (b2.offset || 0)) return -1;\\r\\n\\t\\t\\t\\t\\tif (b1.x - (b1.offset || 0) > b2.x - (b2.offset || 0)) return 1;\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tif (b1.y - (b1.offset || 0) < b2.y - (b2.offset || 0)) return -1;\\r\\n\\t\\t\\t\\t\\tif (b1.y - (b1.offset || 0) > b2.y - (b2.offset || 0)) return 1;\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 4: { // низ лево\\r\\n\\t\\t\\t\\tif (isx) {\\r\\n\\t\\t\\t\\t\\tif (b1.x + b1.width + (b1.offset || 0) > b2.x + b2.width + (b2.offset || 0)) return -1;\\r\\n\\t\\t\\t\\t\\tif (b1.x + b1.width + (b1.offset || 0) < b2.x + b2.width + (b2.offset || 0)) return 1;\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tif (b1.y - (b1.offset || 0) < b2.y - (b2.offset || 0)) return -1;\\r\\n\\t\\t\\t\\t\\tif (b1.y - (b1.offset || 0) > b2.y - (b2.offset || 0)) return 1;\\r\\n\\t\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// попадает ли бокс в диапазон\\r\\n\\tthis.checkBoxCurs = function (x, y, b, curs) {\\r\\n\\t\\tswitch (curs) {\\r\\n\\t\\t\\tcase 1: { // верх лево\\r\\n\\t\\t\\t\\tif (b.x >= x) return false;// далеко с права\\r\\n\\t\\t\\t\\tif (b.y >= y - 1) return false;// с низу далеко\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 2: { // вверх право\\r\\n\\t\\t\\t\\tif (b.x + b.width <= x) return false;// с лева далеко\\r\\n\\t\\t\\t\\tif (b.y >= y) return false;// с низу далеко\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 3: {// низ право\\r\\n\\t\\t\\t\\tif (b.x + b.width <= x) return false;// с лева далеко\\r\\n\\t\\t\\t\\tif (b.y + b.height <= y) return false;// далеко с верху\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 4: { // низ лево\\r\\n\\t\\t\\t\\tif (b.x >= x) return false;// далеко с права\\r\\n\\t\\t\\t\\tif (b.y + b.height <= y) return false;// далеко с верху\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\nCollisionDetection.prototype = {\\r\\n\\r\\n\\tset isCollisionAvtive(v) {\\r\\n\\t\\tthis._isCollisionAvtive = v;\\r\\n\\t},\\r\\n\\r\\n\\tget isCollisionAvtive() {\\r\\n\\t\\tthis.upData();\\r\\n\\t\\treturn this._isCollisionAvtive;\\r\\n\\t},\\r\\n\\r\\n\\r\\n}; \\n// CONCATENATED MODULE: ./src/larvij/scane3d/room/collision/CollisionRect.js\\n//-----------------------------------------------------------------------------------------------\\r\\n//-----------------------------------------------------------------------------------------------\\r\\n\\r\\n\\r\\nvar debugId = 0\\r\\n\\r\\nvar calcColis;\\r\\nfunction CollisionRect(id) {\\r\\n    var self = this;\\r\\n\\r\\n    var c = new PIXI.Container()\\r\\n    var w = new PLWindow(c, 50, debugId*30, \\'CollisionRect\\'+(++debugId||\\'\\'));\\r\\n    w.width = 200;\\r\\n    w.height = 10;\\r\\n    w.hasMinimizeButton = true;\\r\\n    w.minimize = true;\\r\\n    var g = new PIXI.Graphics();\\r\\n    //debugMenu.content.addChild(c);\\r\\n    w.content.addChild(g);\\r\\n    this.debug = true;\\r\\n\\r\\n\\r\\n    this.world=new RectCollis(0,0,400,300);\\r\\n    //if(calcColis==undefined)new CalcColis();\\r\\n    if(calcColis==undefined)new CalcColis();\\r\\n\\r\\n    this.colozi=new CollisionDetection();\\r\\n    this.colozi.maxLevel = 10;\\r\\n    this.colozi.bigBox=this.world;\\r\\n    this.colozi.funErr = function (b) {\\r\\n        // if(b.funErr) b.funErr();\\r\\n    }\\r\\n\\r\\n    var arrRect=[];\\r\\n    this.arrRect = arrRect\\r\\n\\r\\n    var p;\\r\\n    this.addRect=function(r, isNotRemove){\\r\\n        p=9999999;\\r\\n        for (var i = 0; i < arrRect.length; i++) {\\r\\n            if(arrRect[i].idRandom==r.idRandom){\\r\\n                p=i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(p==9999999){\\r\\n            r.rectartID();\\r\\n            arrRect.push(r);\\r\\n            this.colozi.arrBox.push(r.rectCollisMeshdy);\\r\\n            this.colozi.activBox=r.rectCollisMeshdy;\\r\\n            var b = this.colozi.correct();\\r\\n            if (!isNotRemove && !b) {\\r\\n                self.removeRect(r);\\r\\n            }\\r\\n            drawDegug()\\r\\n            return b;\\r\\n        }\\r\\n        drawDegug()\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    this.removeRect=function(r, bool){\\r\\n        p=9999999;\\r\\n        for (var i = 0; i < arrRect.length; i++) {\\r\\n            if(arrRect[i].idRandom==r.idRandom){\\r\\n                p=i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if(p!=9999999){\\r\\n            this.colozi.arrBox.splice(p,1);            \\r\\n            p=arrRect.splice(p,1);\\r\\n            //this.update();\\r\\n            if(bool==undefined)this.removeRect(p, true);\\r\\n        }\\r\\n        drawDegug()\\r\\n    };\\r\\n\\r\\n    this.addRectStatic = function(blok) {\\r\\n        for (var i = 0; i < this.colozi.hideBox.length; i++) {\\r\\n            if (this.colozi.hideBox[i] == blok) {\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        this.colozi.hideBox.push(blok);\\r\\n        drawDegug()\\r\\n    };\\r\\n    this.removeRectStatic = function(blok) {\\r\\n        for (var i = 0; i < this.colozi.hideBox.length; i++) {\\r\\n            if (this.colozi.hideBox[i] == blok) {\\r\\n                this.colozi.hideBox.splice(i,1);\\r\\n                drawDegug()\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n\\r\\n    this.clearNa=function(){\\r\\n        \\r\\n        if(arrRect.length!=0){\\r\\n            \\r\\n            for (var i = 0; i < arrRect.length; i++) {\\r\\n                calcColis.isState(this.world, arrRect[i]); \\r\\n                calcColis.isState( arrRect[i],this.world); \\r\\n            };\\r\\n        }\\r\\n    }\\r\\n\\r\\n    this.update=function(){\\r\\n        this.colozi.updateWorld();\\r\\n        drawDegug()\\r\\n    }\\r\\n\\r\\n    this.testRect=function(r){\\r\\n       \\r\\n        this.colozi.redactBox(r.rectCollisMeshdy);\\r\\n        drawDegug()\\r\\n    }\\r\\n    this.isCollisionBigBox = function (r) {\\r\\n        \\r\\n        return this.colozi.isCollisionBigBox(r.rectCollisMeshdy);\\r\\n    }\\r\\n\\r\\n    var arrText = [];\\r\\n    var contentText = new PIXI.Container();\\r\\n    g.addChild(contentText)\\r\\n\\r\\n    function okrug(num, num1) {\\r\\n        num1 = num1 || 100;\\r\\n        return parseInt(num * num1) / num1;\\r\\n    }\\r\\n    function drawDegug() {\\r\\n        g.clear();\\r\\n        if (!g.visible || !self.debug) return;\\r\\n\\r\\n        g.position.set(-self.world.x, -self.world.y)\\r\\n        arrText.forEach(function (t) {\\r\\n            t.destroy()\\r\\n        });\\r\\n        arrText.length = 0;\\r\\n\\r\\n\\r\\n        g.lineStyle(1, 0x000000, 0.7);\\r\\n        g.drawRect(self.colozi.bigBox.x, self.colozi.bigBox.y, self.colozi.bigBox.width, self.colozi.bigBox.height);\\r\\n        g.lineStyle(1, 0x00ff00, 0.7);\\r\\n        for (var i in self.colozi.arrBox) {\\r\\n            var r = self.colozi.arrBox[i];\\r\\n            g.lineStyle(1, 0x00ff00, 0.7);\\r\\n            g.drawRect(r.x, r.y, r.width, r.height);\\r\\n\\r\\n            var text = new PIXI.Text(i + \\'->\\\\n\\' + okrug(r.x) + \\'-\\' + okrug(r.y), {\\r\\n                fontFamily: \\'Arial\\',\\r\\n                fontSize: 10,\\r\\n                fill: 0xff1010,\\r\\n                textBaseline: \\'Middle\\'\\r\\n            });\\r\\n            text.position.set((r.x + (r.width) / 2) - 20, (r.y + (r.height) / 2) - 5)\\r\\n            contentText.addChild(text)\\r\\n            arrText.push(text)\\r\\n\\r\\n            if (r.coliziStop) {\\r\\n                g.lineStyle(1, 0xf0ff0f, 0.7);\\r\\n                g.drawRect(r.coliziStop.x, r.coliziStop.y, r.coliziStop.width, r.coliziStop.height);\\r\\n            }\\r\\n\\r\\n            // g.drawRect(r.position.x, r.position.y, 2, 2);\\r\\n        }\\r\\n        // if (box) {\\r\\n        //     g.lineStyle(0.7, 0x0000ff, 1);\\r\\n        //     var r = box.boxColizi.rectCollisMeshdy;\\r\\n        //     g.drawRect(r.x, r.y, r.width, r.height)\\r\\n        // }\\r\\n    \\r\\n    }\\r\\n}\\r\\n\\r\\nCollisionRect.prototype = {\\r\\n    set width (v) {      \\r\\n        \\r\\n        //this._width=v;\\r\\n        this.world.width=v;\\r\\n        this.clearNa();\\r\\n    },\\r\\n    get width () {\\r\\n        return this.world.width;\\r\\n    },\\r\\n   /* set y (v) {      \\r\\n        this._y=v;   \\r\\n        if(this.fun) this.fun()    \\r\\n    },\\r\\n    get y () {\\r\\n        return this._y;\\r\\n    },*/\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nfunction RectCollisMeshdy(_x,_y,_width,_height, fun) {\\r\\n    this._x=_x||0;\\r\\n    this._y=_y||0;\\r\\n\\r\\n    this.width=_width||100;\\r\\n    this.height=_height||100;\\r\\n    this.fun=fun;\\r\\n}\\r\\nRectCollisMeshdy.prototype = {\\r\\n    set x (v) {      \\r\\n        this._x=v; \\r\\n        if(this.fun) this.fun()\\r\\n    },\\r\\n    get x () {\\r\\n        return this._x;\\r\\n    },\\r\\n    set y (v) {      \\r\\n        this._y=v; \\r\\n        if(this.fun) this.fun()      \\r\\n    },\\r\\n    get y () {\\r\\n        return this._y;\\r\\n    },\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nfunction RectCollis(_x,_y,_width,_height, fun) {\\r\\n    var self=this;\\r\\n    this.fun=fun;\\r\\n\\r\\n    this.x=_x||0;\\r\\n    this.y=_y||0;\\r\\n\\r\\n    this.sx=_x||0;\\r\\n    this.sy=_y||0;\\r\\n\\r\\n    this.width=_width||100;\\r\\n    this.height=_height||100;\\r\\n    this.position=new PositionCollis(0,0,function(){\\r\\n        \\r\\n        self.rectCollisMeshdy.x=this.x+self.sx;\\r\\n        self.rectCollisMeshdy.y=this.y+self.sy;\\r\\n        self.rectCollisMeshdy.width = self.width;\\r\\n        self.rectCollisMeshdy.height = self.height;\\r\\n    });\\r\\n    \\r\\n    this.__x=_x||0;\\r\\n    this.__y=_y||0;\\r\\n\\r\\n\\r\\n    this.rectCollisMeshdy=new RectCollisMeshdy(this.x,this.y,this.width, this.height, function(){\\r\\n\\r\\n       \\r\\n\\r\\n        self.__x=self.rectCollisMeshdy.x-self.sx;\\r\\n        self.__y=self.rectCollisMeshdy.y-self.sy;\\r\\n        if(self.fun)self.fun();\\r\\n /**/       \\r\\n       /* if(self.parent){\\r\\n            self.parent.x=self.__x;\\r\\n            self.parent.y=-self.__y;\\r\\n\\r\\n        }*/\\r\\n    });\\r\\n\\r\\n\\r\\n    this.arrKri=[0,0,0,0];\\r\\n    this.kolPoint=0;\\r\\n    this.peresek=false;\\r\\n\\r\\n    this.idRandom=Math.random();\\r\\n    this.rectartID=function(){this.idRandom=Math.round(Math.random()*10000000000000000)/10000000000000000;}\\r\\n    this.parent;\\r\\n\\r\\n    this.set=function(r){\\r\\n        this.x=r.x;\\r\\n        this.y=-200//r.y;\\r\\n        this.sx=r.x;\\r\\n        this.sy=r.y;\\r\\n\\r\\n        this.width=r.width;\\r\\n        this.height=r.height; \\r\\n\\r\\n        this.position.x=r.position.x;\\r\\n        this.position.y=r.position.y; \\r\\n        this.idRandom =r.idRandom; \\r\\n\\r\\n        //if(self.fun)self.fun();\\r\\n        \\r\\n    }\\r\\n\\r\\n\\r\\n    var p=new PositionCollis();\\r\\n    this.getPoint=function(num){\\r\\n        if(num==0)p.set((this.__x), this.y+this.position.y);\\r\\n        if(num==1)p.set((this.__x+this.width), this.y+this.position.y);\\r\\n        if(num==2)p.set((this.__x+this.width), this.y+this.position.y+this.height);\\r\\n        if(num==3)p.set((this.__x), this.y+this.position.y+this.height);\\r\\n\\r\\n        if(num==4)p.set((this.__x), this.y+this.position.y);\\r\\n        return p;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\nfunction PositionCollis(_x,_y,fun) {\\r\\n    this._x=_x||0;\\r\\n    this._y=_y||0;\\r\\n    this.fun=fun;\\r\\n    this.set=function(_x,_y){\\r\\n        this.x=_x;\\r\\n        this.y=_y;\\r\\n    }\\r\\n}\\r\\nPositionCollis.prototype = {\\r\\n    set x (v) {      \\r\\n        this._x=v;\\r\\n        if(this.fun) this.fun()\\r\\n    },\\r\\n    get x () {\\r\\n        return this._x;\\r\\n    },\\r\\n    set y (v) {      \\r\\n        this._y=v;   \\r\\n        if(this.fun) this.fun()    \\r\\n    },\\r\\n    get y () {\\r\\n        return this._y;\\r\\n    },\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nvar calcColis;\\r\\nfunction CalcColis() { \\r\\n    calcColis=this;\\r\\n    //Получение угла между двумя точками градусы\\r\\n    this.getAngle = function(a, b) {\\r\\n        return Math.atan2(b.y - a.y, b.x - a.x);\\r\\n    }\\r\\n\\r\\n    // получить дистанцию между точками\\r\\n    this.getDistance = function(p1, p2) {\\r\\n        if (!p1 || !p2) return 0;\\r\\n        return Math.sqrt(Math.pow((p1.x - p2.x), 2) + Math.pow(( p1.y - p2.y), 2))\\r\\n    }\\r\\n\\r\\n    this.getVector = function(length, angle){\\r\\n        var point=new THREE.Vector2(0,0);\\r\\n        point.x = Math.abs(length) * Math.cos(angle);\\r\\n        point.y = Math.abs(length) * Math.sin(angle);   \\r\\n        return point;   \\r\\n    }\\r\\n\\r\\n \\r\\n    // поверяем находится ли вторый прямоугольник в первом \\r\\n    this.isPutIn = function(r1,r2) {\\r\\n        \\r\\n        if( (r1.x+r1.position.x<=r2.x+r2.position.x)&&(r1.x+r1.position.x+r1.width>=r2.x+r2.position.x+r2.width)){\\r\\n            if( (r1.y+r1.position.y<=r2.x+r2.position.y)&&\\r\\n                (r1.y+r1.position.y+r1.height>=r2.y+r2.position.y+r2.height)\\r\\n                ){\\r\\n                return true;\\r\\n            }            \\r\\n        }\\r\\n        return false;\\r\\n       // return ( (r1.x <= r2.x) && (r1.x+r1.width >= x2+w2) && (w1 >= w2) && (y1 <= y2) && (y1+h1 >= y2+h2) && (h1 >= h2)); \\r\\n    }\\r\\n\\r\\n\\r\\n    var sah,ii;\\r\\n  \\r\\n    //находиться ли точка в ректе\\r\\n    this.isPointInRect = function(p,r) {        \\r\\n        if( (p.x>r.x+r.position.x)&&(p.x<r.x+r.position.x+r.width)){\\r\\n            if( (p.y>r.y+r.position.y)&&(p.y<r.y+r.position.y+r.height)){\\r\\n                return 1;\\r\\n            }            \\r\\n        }\\r\\n        return 0;       \\r\\n    }\\r\\n\\r\\n    //во внутрь смещение второго треугольника относительно первого \\r\\n    this.rectInRect = function(r1,r2) {        \\r\\n        sah=0;\\r\\n        for (ii = 0; ii < 4; ii++) {\\r\\n            if(r2.arrKri[ii]==1)sah++;\\r\\n        }\\r\\n        if(r1.width<r2.width)return false;\\r\\n        if(r1.height<r2.height)return false;\\r\\n        if((sah==1)||(sah==2)){ } else return false;\\r\\n\\r\\n        if(sah==1){//то в углы           \\r\\n            if((r2.arrKri[0]==1)){\\r\\n                r2.position.x=r1.x-r1.position.x-r2.x+r1.width-r2.width;\\r\\n                r2.position.y=r1.y-r1.position.y-r2.y+r1.height-r2.height;                \\r\\n            }\\r\\n            if((r2.arrKri[1]==1)){\\r\\n                r2.position.x=r1.x-r1.position.x-r2.x//+r1.width-r2.width;\\r\\n                r2.position.y=r1.y-r1.position.y-r2.y+r1.height-r2.height;\\r\\n            }\\r\\n            if((r2.arrKri[2]==1)){\\r\\n                r2.position.x=r1.x-r1.position.x-r2.x//+r1.width-r2.width;\\r\\n                r2.position.y=r1.y-r1.position.y-r2.y//+r1.height-r2.height;\\r\\n            }\\r\\n            if((r2.arrKri[3]==1)){\\r\\n                r2.position.x=r1.x-r1.position.x-r2.x+r1.width-r2.width;\\r\\n                r2.position.y=r1.y-r1.position.y-r2.y//+r1.height-r2.height;\\r\\n            }\\r\\n           \\r\\n        }\\r\\n        if(sah==2){//то в стороны            \\r\\n            if((r2.arrKri[0]==1)&&(r2.arrKri[1]==1)){                    \\r\\n                r2.position.y=r1.y-r1.position.y-r2.y+r1.height-r2.height;\\r\\n            }\\r\\n           if((r2.arrKri[1]==1)&&(r2.arrKri[2]==1)){ \\r\\n                r2.position.x=r1.x-r1.position.x-r2.x;                \\r\\n            }\\r\\n\\r\\n            if((r2.arrKri[2]==1)&&(r2.arrKri[3]==1)){ \\r\\n                r2.position.y=r1.y-r1.position.y-r2.y;             \\r\\n            }\\r\\n            if((r2.arrKri[3]==1)&&(r2.arrKri[0]==1)){ \\r\\n                r2.position.x=r1.x-r1.position.x-r2.x+r1.width-r2.width;         \\r\\n            }            \\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    var v=new PositionCollis();\\r\\n    var v1=new PositionCollis();\\r\\n    var v2=new PositionCollis();\\r\\n    var v3=new PositionCollis();    \\r\\n    this.isLineRect = function(r1,r2) {\\r\\n        var i,j,pp;\\r\\n        for (i = 0; i < 4; i++) {\\r\\n            \\r\\n            v.x=r1.getPoint(i).x;\\r\\n            v.y=r1.getPoint(i).y;\\r\\n            v1.x=r1.getPoint(i+1).x;\\r\\n            v1.y=r1.getPoint(i+1).y;\\r\\n           // tC.clear();\\r\\n            //tC.debagLine(v,v1);\\r\\n            for (j = 0; j < 4; j++) {\\r\\n                v2.x=r2.getPoint(j).x;\\r\\n                v2.y=r2.getPoint(j).y;\\r\\n                v3.x=r2.getPoint(j+1).x;\\r\\n                v3.y=r2.getPoint(j+1).y;\\r\\n\\r\\n                pp=this.getPointOfIntersection(v,v1,v2,v3);\\r\\n               \\r\\n                \\r\\n                \\r\\n                \\r\\n                //tC.debagLine(v,v1);\\r\\n\\r\\n                if(pp!=null){\\r\\n                    if(this.testRadom(r1,r2)==false){\\r\\n                        return true;\\r\\n                    }\\r\\n                   // tC.debagPoint(pp);\\r\\n                    \\r\\n                }\\r\\n            }\\r\\n\\r\\n\\r\\n        };\\r\\n\\r\\n        // tC.clear();\\r\\n\\r\\n        return false;\\r\\n\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    this.testRadom = function(r1,r2) {\\r\\n        if(r1.getPoint(0).x>r2.getPoint(0).x){            \\r\\n            if(this.numOkr(r1.getPoint(0).x)==this.numOkr(r2.getPoint(1).x)){                \\r\\n                return true\\r\\n            }\\r\\n        }\\r\\n        if(r1.getPoint(1).y>r2.getPoint(1).y){            \\r\\n            if(this.numOkr(r1.getPoint(0).y)==this.numOkr(r2.getPoint(2).y)){                \\r\\n                return true\\r\\n            }\\r\\n        }\\r\\n\\r\\n        \\r\\n            \\r\\n        if(this.numOkr(r1.getPoint(1).x)==this.numOkr(r2.getPoint(0).x)){                  \\r\\n            return true\\r\\n        }\\r\\n        \\r\\n        if(this.numOkr(r1.getPoint(2).y)==this.numOkr(r2.getPoint(0).y)){                   \\r\\n            return true\\r\\n        }\\r\\n        return false\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    //проверяем пересечений\\r\\n    var d,da,db,ta,tb,dx,dy,distans,angel;\\r\\n    var rez=new PositionCollis(0,0);\\r\\n    this.getPointOfIntersection = function(p1, p2, p3, p4){\\r\\n        d = (p1.x - p2.x) * (p4.y - p3.y) - (p1.y - p2.y) * (p4.x - p3.x);\\r\\n        da = (p1.x - p3.x) * (p4.y - p3.y) - (p1.y - p3.y) * (p4.x - p3.x);\\r\\n        db = (p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x);\\r\\n     \\r\\n        ta = da / d;\\r\\n        tb = db / d;     \\r\\n        if (ta >= 0 && ta <= 1 && tb >= 0 && tb <= 1){\\r\\n            dx = p1.x + ta * (p2.x - p1.x);\\r\\n            dy = p1.y + ta * (p2.y - p1.y); \\r\\n            rez.x= dx;\\r\\n            rez.y= dy;\\r\\n            return rez; // точка пересечения            \\r\\n        }    \\r\\n        return null;\\r\\n    }\\r\\n    \\r\\n    this.isState = function(r1,r2) {\\r\\n        var rez=0;\\r\\n        r2.kolPoint=0;        \\r\\n        for (var i = 0; i < 4; i++) {           \\r\\n            r2.arrKri[i]=this.isPointInRect(r2.getPoint(i),r1);            \\r\\n            if(r2.arrKri[i]==1)r2.kolPoint++;\\r\\n        }\\r\\n\\r\\n        if(r2.kolPoint!=0)rez=1;\\r\\n        if(r2.kolPoint==4)rez=2; \\r\\n\\r\\n        return rez;\\r\\n    }\\r\\n\\r\\n\\r\\n    this.numOkr = function(n) {\\r\\n        return Math.round(n*1)/1;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/scane3d/room/Sten.js\\n\\r\\n\\r\\n\\r\\n\\r\\nclass Sten_Sten  {\\r\\n    constructor(cont3d, fun) {         \\r\\n        this.type=\"Sten\";\\r\\n        var self=this;\\r\\n        this.fun=fun;\\r\\n        this.idArr=-1;\\r\\n\\r\\n        this.pointOld=new Position()\\r\\n        this._width=200;\\r\\n        this._height=20;\\r\\n\\r\\n        this._color = 0xffffff;\\r\\n        this._colorBig = 0xeeeeee;\\r\\n        this._colorLine =0xdddddd;\\r\\n\\r\\n        this._active=true;\\r\\n        this._actBig = false;\\r\\n\\r\\n        this._sA=1;\\r\\n        this._sA1=1;\\r\\n        this.arrayPoint=[new Position(),new Position(),new Position(),new Position()];\\r\\n        \\r\\n\\r\\n        this._width = 300;// длина\\r\\n        this._height = 275;// высота\\r\\n        this._depth = 20;// толшина\\r\\n\\r\\n\\r\\n        //3d init-------------------------------------------------------\\r\\n        \\r\\n        \\r\\n        this.contPoz3d = new THREE.Object3D();        \\r\\n        cont3d.add(this.contPoz3d);\\r\\n\\r\\n        this.content3d = new THREE.Object3D();    \\r\\n        this.contPoz3d.add(this.content3d);\\r\\n        this.content3d.rotation.x=-Math.PI/2;\\r\\n\\r\\n\\r\\n\\r\\n        this.collision = new CollisionRect();\\r\\n        this.collision.colozi.disStick = 15;\\r\\n        this.collision.colozi.isStick = true;\\r\\n\\r\\n        this.geometry = new GeometrySten();\\r\\n        this.geometry1 = new GeometrySten();       \\r\\n        \\r\\n        this.geometry.depth = 0;\\r\\n        this.geometry1.depth = this._depth;\\r\\n\\r\\n        this.material=new THREE.MeshPhongMaterial({\\r\\n            color: 0xffffff,\\r\\n            transparent: true,\\r\\n            side: THREE.DoubleSide,\\r\\n        })\\r\\n\\r\\n        this.mesh = new THREE.Mesh(this.geometry, this.material);\\r\\n        this.mesh.castShadow = true;\\r\\n        this.mesh.receiveShadow = true;\\r\\n\\r\\n        this.mesh1 = new THREE.Mesh(this.geometry1, this.material);\\r\\n\\r\\n        this.content3d.add(this.mesh);\\r\\n        this.content3d.add(this.mesh1); \\r\\n\\r\\n\\r\\n        var mesh;\\r\\n        var g=new THREE.BoxBufferGeometry(1,1,1)\\r\\n        var s=2;\\r\\n        var s1=20;\\r\\n        for (var i = 0; i < 300; i++) {\\r\\n            mesh=new THREE.Mesh(g, new THREE.MeshPhongMaterial({color: 0xffffff*Math.random()} ))\\r\\n            //mesh.position.set(Math.random()*this._width,s1-Math.random()*2*s1,s1-Math.random()*2*s1)\\r\\n            mesh.scale.set(s+Math.random()*s,s+Math.random()*s,s+Math.random()*s)\\r\\n            mesh.rotation.set(Math.random()*6,Math.random()*6,Math.random()*6)\\r\\n            this.content3d.add(mesh);\\r\\n        } \\r\\n\\r\\n\\r\\n        this.drag=function(){\\r\\n            for (var i = 0; i < this.content3d.children.length; i++) {\\r\\n                this.content3d.children[i].position.set(Math.random()*this._width,Math.random()*this._height,0)\\r\\n            }\\r\\n\\r\\n            this.geometry.setRect(0, 0, this._width, this._height);\\r\\n            this.mesh.position.set(0, 0, 0);\\r\\n\\r\\n            this.geometry1.setRect(0, 0, this._width, this._height);\\r\\n            this.mesh1.position.set(0, 0, -this._depth);\\r\\n        }\\r\\n\\r\\n        //-------------------------------------------------------\\r\\n        \\r\\n        //2d init-------------------------------------------------------\\r\\n        this.content=new PIXI.Container();\\r\\n        this.graphics = new PIXI.Graphics();// Для дебаг отрисовки\\r\\n        this.content.addChild(this.graphics);\\r\\n\\r\\n        this.redrag=function(){\\r\\n            this.graphics.clear();           \\r\\n\\r\\n            if(this._actBig==false)this.graphics.beginFill(this._color);\\r\\n            else this.graphics.beginFill(this._colorBig);\\r\\n\\r\\n            this.graphics.lineStyle(1, this._colorLine, 1);\\r\\n\\r\\n            this.redragPosit();\\r\\n            this.graphics.moveTo(this.arrayPoint[0].x, this.arrayPoint[0].y);\\r\\n            this.graphics.lineTo(this.arrayPoint[1].x, this.arrayPoint[1].y);\\r\\n            this.graphics.lineTo(this.arrayPoint[2].x, this.arrayPoint[2].y);\\r\\n            this.graphics.lineTo(this.arrayPoint[3].x, this.arrayPoint[3].y);\\r\\n            this.graphics.lineTo(this.arrayPoint[0].x, this.arrayPoint[0].y);\\r\\n\\r\\n            this.graphics.lineStyle(2, 0xff0000, 1);\\r\\n            this.graphics.moveTo(0, 0);\\r\\n            this.graphics.lineTo(this._width, 0);\\r\\n            this.drag();\\r\\n            self.fun(\"intRend\")\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n        this.redragPosit=function(){\\r\\n            this.arrayPoint[2].y=this.arrayPoint[3].y=-this._depth;\\r\\n            this.arrayPoint[0].x=this.arrayPoint[3].x=0;            \\r\\n            this.arrayPoint[1].x=this.arrayPoint[2].x=this._width;            \\r\\n            if(this._sA==0){\\r\\n                this.arrayPoint[0].x=-this._depth;\\r\\n            }\\r\\n            if(this._sA==2){\\r\\n                this.arrayPoint[3].x=-this._depth;\\r\\n            }\\r\\n            if(this._sA1==0){\\r\\n                this.arrayPoint[1].x=this._width+this._depth;\\r\\n            }\\r\\n            if(this._sA1==2){\\r\\n                this.arrayPoint[2].x=this._width+this._depth;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        this.savePozot=function(){\\r\\n            this.pointOld.x=this.x;\\r\\n            this.pointOld.y=this.y;\\r\\n            this.pointOld.w=this.width;\\r\\n        }\\r\\n\\r\\n        this.mouseOut = function (e) {\\r\\n            \\r\\n        };\\r\\n\\r\\n        this.mouseOver = function (e) {\\r\\n            \\r\\n        };\\r\\n\\r\\n        this.onDown = function (e) {\\r\\n            fun(\"onDown\",self)\\r\\n        };\\r\\n\\r\\n        this.graphics.interactive = true;\\r\\n        this.graphics.buttonMode = true;\\r\\n        \\r\\n\\r\\n        if (pl102.isMouseEvents) {\\r\\n            this.graphics.on(\\'mousedown\\', this.onDown);\\r\\n            this.graphics.on(\\'mouseout\\', this.mouseOut);\\r\\n            this.graphics.on(\\'mouseover\\', this.mouseOver);\\r\\n        }\\r\\n        if (pl102.isTouchEvents) {\\r\\n            this.graphics.on(\\'touchstart\\', this.onDown);\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n        //-------------------------------------------------------\\r\\n\\r\\n\\r\\n\\r\\n        \\r\\n    }\\r\\n\\r\\n    set rotation(v) {\\r\\n        if(this._rotation != v){\\r\\n            this._rotation = v;\\r\\n            this.content.rotation = v;\\r\\n            this.contPoz3d.rotation.z=v;\\r\\n        }\\r\\n        \\r\\n    } \\r\\n    get rotation() { return  this._rotation;}\\r\\n\\r\\n    set x(v) {\\r\\n        this.contPoz3d.position.x=v;\\r\\n        this.content.x = v;\\r\\n    } \\r\\n    get x() { return  this.content.x;}\\r\\n\\r\\n\\r\\n    set y(v) {\\r\\n        this.contPoz3d.position.y=v;\\r\\n        this.content.y = v;\\r\\n    } \\r\\n    get y() { return  this.content.y;}\\r\\n\\r\\n    set width(v) {\\r\\n        if(this._width!=v){\\r\\n            this._width = v;         \\r\\n            this.redrag()\\r\\n        }       \\r\\n    }   \\r\\n    get width() { return  this._width;}\\r\\n\\r\\n\\r\\n    set height(v) {\\r\\n        if(this._height!=v){\\r\\n            this._height = v;            \\r\\n            this.redrag()\\r\\n        }       \\r\\n    }   \\r\\n    get height() { return  this._height;}\\r\\n\\r\\n    set depth(v) {\\r\\n        if(this._depth!=v){\\r\\n            this._depth = v;\\r\\n            this.geometry1.depth = this._depth;            \\r\\n            this.redrag();\\r\\n        }       \\r\\n    }   \\r\\n    get depth() { return  this._depth;}\\r\\n\\r\\n    set active(v) {\\r\\n        if(this._active!=v){\\r\\n            this._active = v;            \\r\\n            if(this._active==true){\\r\\n                this.contPoz3d.visible=true\\r\\n                this.graphics.alpha=1\\r\\n            }else{\\r\\n                this.contPoz3d.visible=false\\r\\n                this.graphics.alpha=0.5\\r\\n            }\\r\\n        }       \\r\\n    }   \\r\\n    get active() { return  this._active;}\\r\\n\\r\\n    set actBig(v) {\\r\\n        if(this._actBig!=v){\\r\\n            this._actBig = v;            \\r\\n            this.redrag();\\r\\n        }       \\r\\n    }   \\r\\n    get actBig() { return  this._actBig;}    \\r\\n\\r\\n\\r\\n    set sA(v) {\\r\\n        if(this._sA!=v){\\r\\n            this._sA = v;            \\r\\n            this.redrag();\\r\\n        }       \\r\\n    }   \\r\\n    get sA() { return  this._sA;}\\r\\n\\r\\n    set sA1(v) {\\r\\n        if(this._sA1!=v){\\r\\n            this._sA1 = v;            \\r\\n            this.redrag();\\r\\n        }       \\r\\n    }   \\r\\n    get sA1() { return  this._sA1;}\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/scane3d/room/Room.js\\n\\r\\n\\r\\n\\r\\nclass Room_Room  {\\r\\n    constructor(scane3d, fun) {         \\r\\n        this.type=\"Room\";\\r\\n        var self=this;\\r\\n        this._sahMenu=0\\r\\n        this.par=scane3d;\\r\\n       \\r\\n\\r\\n        this._height=275;\\r\\n        this._depth = 20;// толшина\\r\\n\\r\\n\\r\\n        this.content3d = new THREE.Object3D();        \\r\\n        this.par.content3d.add(this.content3d)\\r\\n        this.content3d.position.z=this._height/2\\r\\n\\r\\n        this.sob=function(type, param){                    \\r\\n            fun(type, param)\\r\\n        }\\r\\n\\r\\n\\r\\n        this.array=[];\\r\\n        for (var i = 0; i < 3; i++) {\\r\\n            this.array[i]=new Sten_Sten(this.content3d,this.sob)\\r\\n            this.array[i].idArr=i;\\r\\n        }\\r\\n\\r\\n        this.menedsher=new Menedsher(this, function(type, param){            \\r\\n            fun(type, param)\\r\\n        });\\r\\n\\r\\n\\r\\n       \\r\\n        this.pObject=new DParamObject(scane3d.par.dCont,802,100);\\r\\n        this.pObject.addObject(this);\\r\\n    }\\r\\n\\r\\n    set height(v) {\\r\\n        if(this._height!=v){\\r\\n            this._height = v;            \\r\\n            this.content3d.position.z=this._height/2;\\r\\n            for (var i = 0; i < this.array.length; i++) {\\r\\n                this.array[i].height = v;\\r\\n            }\\r\\n        }       \\r\\n    }   \\r\\n    get height() { return  this._height;}\\r\\n\\r\\n    set depth(v) {\\r\\n        if(this._depth!=v){\\r\\n            this._depth= v;            \\r\\n            for (var i = 0; i < this.array.length; i++) {\\r\\n                this.array[i].depth = v;\\r\\n            }\\r\\n        }       \\r\\n    }   \\r\\n    get depth() { return  this._depth;}\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n//\\r\\nclass Menedsher  {\\r\\n    constructor(room, fun) {         \\r\\n        this.type=\"Menedsher\";\\r\\n        var self=this;\\r\\n        this.par=room;\\r\\n        this.content3d = new THREE.Object3D();\\r\\n        room.content3d.add(this.content3d);\\r\\n\\r\\n        this.menedsherObject = new MenedsherObject(this);\\r\\n\\r\\n    }\\r\\n}\\r\\n\\r\\nclass MenedsherObject  {\\r\\n    constructor(penedsher, fun) {\\r\\n        this.type=\"MenedsherObject\";\\r\\n        var self=this;\\r\\n        this.par=penedsher;\\r\\n        this.visi3D=penedsher.par.par.par.visi3D;\\r\\n        trace(\"this.visi3D  \",this.visi3D)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/*\\r\\n\\r\\n        this.visi3D.addEvent(\"out\", this.out);\\r\\n        this.visi3D.addEvent(\"over\", this.over);\\r\\n        this.visi3D.addEvent(\"down\", this.down);*/\\r\\n       /* eventSob.addEvent(\"out\", this.out);\\r\\n        eventSob.addEvent(\"over\", this.over);\\r\\n        eventSob.addEvent(\"down\", this.down); */\\r\\n    }\\r\\n}\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/scane3d/Scane3d.js\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass Scane3d_Scane3d  {\\r\\n  \\tconstructor(glaf,fun) {  \\t\\t\\r\\n  \\t\\tthis.type=\"Scane3d\";\\r\\n  \\t\\tvar self=this;\\r\\n        this.par=glaf\\r\\n  \\t\\tthis._sahMenu=0\\r\\n        this.visi3D=glaf.visi3D\\r\\n  \\t\\tthis.content3d = new THREE.Object3D();\\r\\n        this.content3d.visible=false\\r\\n  \\t\\tglaf.content3d.add(this.content3d)\\r\\n  \\t\\t\\r\\n\\r\\n        \\r\\n        this.room=new Room_Room(this, function(type, param){            \\r\\n            fun(type, param)\\r\\n        })\\r\\n\\r\\n \\r\\n\\r\\n\\r\\n\\r\\n/*\\r\\n        var mesh;\\r\\n  \\t\\tvar g=new THREE.BoxBufferGeometry(1,1,1)\\r\\n  \\t\\tvar s=20;\\r\\n  \\t\\tvar s1=220;\\r\\n  \\t\\tfor (var i = 0; i < 20; i++) {\\r\\n  \\t\\t\\tmesh=new THREE.Mesh(g, new THREE.MeshPhongMaterial({color: 0xffffff*Math.random()} ))\\r\\n  \\t\\t\\tmesh.position.set(s1-Math.random()*2*s1,s1-Math.random()*2*s1,s1-Math.random()*2*s1)\\r\\n  \\t\\t\\tmesh.scale.set(s+Math.random()*s,s+Math.random()*s,s+Math.random()*s)\\r\\n  \\t\\t\\tmesh.rotation.set(Math.random()*6,Math.random()*6,Math.random()*6)\\r\\n  \\t\\t\\tthis.content3d.add(mesh)\\r\\n  \\t\\t}\\r\\n*/\\r\\n  \\t\\t\\r\\n        \\r\\n  \\t\\tthis.sizeWindow = function(w,h){    \\t\\t\\t\\r\\n  \\t\\t\\r\\n  \\t\\t\\t\\t\\t\\r\\n  \\t\\t}  \\t\\r\\n\\r\\n\\r\\n\\r\\n  \\t}\\r\\n    set sahMenu(value) {\\r\\n        if(this._sahMenu!=value){\\r\\n            this._sahMenu = value;\\r\\n            if(this._sahMenu==0){\\r\\n                this.content3d.visible=false\\r\\n            }\\r\\n            if(this._sahMenu==1){\\r\\n                this.content3d.visible=true\\r\\n            }\\r\\n            this.visi3D.intRend=1;            \\r\\n        }\\r\\n    }\\r\\n    get sahMenu() { return  this._sahMenu;}\\r\\n\\r\\n}\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/Glaf.js\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass Glaf_Glaf  {\\r\\n  \\tconstructor(main) {  \\t\\t\\r\\n  \\t\\tthis.type=\"Glaf\";\\r\\n  \\t\\tvar self=this;\\r\\n  \\t\\tthis.content3d = new THREE.Object3D();\\r\\n\\t\\tthis.content=new PIXI.Container();\\r\\n\\t\\tthis.dCont=undefined;\\r\\n        this.main=main\\r\\n        this.otstup=2;\\r\\n        this.widthBig=64*2+this.otstup*3\\r\\n\\r\\n        this._sahMenu=0;\\r\\n\\r\\n\\r\\n\\t\\tnew Calc();\\r\\n\\r\\n\\t\\tthis.visi3D = new MVisi3D[\"a\" /* MVisi3D */](main.contentHTML, main.content2d, false, true, true, true, false);\\t\\t\\r\\n\\t\\tthis.visi3D.yes3d = true;       \\t\\r\\n\\t\\tthis.visi3D.groupObject.add(this.content3d);\\r\\n\\r\\n\\r\\n\\r\\n  \\t\\tmain.contentHTML.appendChild(main.renderer.view);  \\t\\t\\r\\n  \\t\\tmain.content2d.addChild(this.content);\\r\\n  \\t\\tthis.dCont=new DCont(main.contentHTML);\\r\\n\\r\\n\\r\\n\\r\\n  \\t\\tthis.scane3d = new Scane3d_Scane3d(this, function(type, param){\\r\\n            if(type==\"visi3d\"||type==\"intRend\"){\\r\\n                self.visi3D.intRend=1;\\r\\n                return\\r\\n            }\\r\\n\\r\\n            if(type==\"onDown\")self.scane2d.stens.sob(type, param)\\r\\n                        \\r\\n        })\\r\\n  \\t\\tthis.scane2d = new Scane2d_Scane2d(this, function(type, param){\\r\\n\\r\\n            if(type==\"visi3d\"||type==\"intRend\"){\\r\\n                self.visi3D.intRend=1;\\r\\n                return\\r\\n            }\\r\\n        })  \\t\\t\\r\\n        this.menuDiv = new MenuDiv(this);\\r\\n        this.galleres = new Galleres(this);\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n  \\t\\t\\r\\n\\t\\tthis.update = function () {\\r\\n\\t\\t\\tthis.visi3D.upDate()\\t\\t\\r\\n\\t\\t}\\r\\n\\r\\n  \\t\\tthis.sizeWindow = function(w,h){    \\t\\t\\t\\r\\n  \\t\\t\\t\\r\\n  \\t\\t\\tthis.menuDiv.sizeWindow(w,h);\\r\\n  \\t\\t\\tthis.scane2d.sizeWindow(w,h);\\r\\n  \\t\\t\\tthis.scane3d.sizeWindow(w,h);\\r\\n            this.galleres.sizeWindow(w,h);\\r\\n  \\t\\t\\tthis.visi3D.sizeWindow(0,0,w,h);\\t\\t\\t\\r\\n  \\t\\t}\\r\\n\\r\\n  \\t\\tthis.sahMenu=1;\\t\\r\\n  \\t}\\r\\n\\r\\n    set sahMenu(value) {\\r\\n        if(this._sahMenu!=value){\\r\\n            this._sahMenu = value;\\r\\n            this.menuDiv.sahMenu = value;\\r\\n            this.scane2d.sahMenu = value;\\r\\n            this.scane3d.sahMenu = value;\\r\\n            this.galleres.sahMenu = value;\\r\\n        }\\r\\n    }\\r\\n    get sahMenu() { return  this._sahMenu;}\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/admin/AGlaf.js\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass AGlaf_AGlaf  {\\r\\n  \\tconstructor(main) {  \\t\\t\\r\\n  \\t\\tthis.type=\"AGlaf\";\\r\\n  \\t\\tvar self=this;\\r\\n  \\t\\tthis.content3d = new THREE.Object3D();\\r\\n\\t\\tthis.content=new PIXI.Container();\\r\\n\\t\\tthis.dCont=undefined;\\r\\n        this.par=main\\r\\n        this.otstup=2;\\r\\n        this.wh=64\\r\\n        this.whv=32+this.otstup*2\\r\\n        this.widthBig=this.wh*3+this.otstup*3;\\r\\n        this.objectBase=undefined;//this.par.objectBase;\\r\\n        this._sahMenu=0;\\r\\n\\r\\n\\r\\n\\t\\tnew Calc();\\r\\n        this.php=new Php();\\r\\n\\r\\n\\t\\tthis.visi3D = new MVisi3D[\"a\" /* MVisi3D */](main.contentHTML, main.content2d, false, true, true, true, false);\\t\\t\\r\\n\\t\\tthis.visi3D.yes3d = true;       \\t\\r\\n\\t\\tthis.visi3D.groupObject.add(this.content3d);\\r\\n\\r\\n\\r\\n\\r\\n  \\t\\tmain.contentHTML.appendChild(main.renderer.view);  \\t\\t\\r\\n  \\t\\tmain.content2d.addChild(this.content);\\r\\n  \\t\\tthis.dCont=new DCont(main.contentHTML);\\r\\n\\r\\n        this.save=function(){\\r\\n            this.s.saveTime()\\r\\n        }\\r\\n\\r\\n        this.init=function(){\\r\\n            this.s=new Save(this);\\r\\n            this.menu=new Menu(this);            \\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n        if(this.objectBase==undefined){\\r\\n            this.objectBase={}\\r\\n            this.objectBase.array=[];\\r\\n            this.objectBase.bd=[];\\r\\n            this.init();\\r\\n            this.save();\\r\\n            \\r\\n        }\\r\\n\\r\\n      \\r\\n\\r\\n  \\t\\t\\r\\n        \\r\\n\\r\\n\\t\\tthis.update = function () {\\r\\n\\t\\t\\tthis.visi3D.upDate()\\t\\t\\r\\n\\t\\t}\\r\\n\\r\\n  \\t\\tthis.sizeWindow = function(w,h){  \\r\\n            var xx=\\tthis.widthBig*2+this.otstup*3;\\t\\t\\r\\n  \\t\\t\\tthis.visi3D.sizeWindow(xx,this.whv,w-xx,h-this.whv);\\r\\n            this.menu.sizeWindow(w,h);\\t\\t\\t\\r\\n  \\t\\t} \\r\\n  \\t}    \\r\\n}\\r\\n\\r\\nclass Save  {\\r\\n    constructor(aGlaf) { \\r\\n        var self=this;        \\r\\n        this.type=\"Save\";\\r\\n        this.par=aGlaf;\\r\\n        this.objectBase=this.par.objectBase;\\r\\n        \\r\\n        this.save=function(){\\r\\n            aGlaf.php.load({tip:\"saveJSON\", link:\"xz.json\", text:\"sdfgdsfg\"},function(e){\\r\\n                trace(e)\\r\\n            })\\r\\n           \\r\\n        }\\r\\n\\r\\n        this.sah=0\\r\\n        this.saveTime=function(){\\r\\n            this.sah++;\\r\\n            var s=this.sah;\\r\\n            setTimeout(function() {\\r\\n                if(self.sah==s)self.save()\\r\\n            }, 100);\\r\\n        }       \\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass Menu  {\\r\\n    constructor(aGlaf) {         \\r\\n        this.type=\"Menu\";\\r\\n        this.par=aGlaf;\\r\\n        this.array=[]\\r\\n        this.array[0]=new MenuVerh(this);\\r\\n        this.objectBase=this.par.objectBase;\\r\\n       \\r\\n        for (var i = 0; i < 22; i++) {\\r\\n            this.par.save();\\r\\n        }\\r\\n\\r\\n\\r\\n        this.sizeWindow = function(w,h){  \\r\\n            for (var i = 0; i < this.array.length; i++) {\\r\\n                this.array[i].sizeWindow(w,h)\\r\\n            }        \\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass MenuVerh  {\\r\\n    constructor(menu) {         \\r\\n        this.type=\"Menu\";\\r\\n        this.par=menu;\\r\\n        this.whv=this.par.par.whv;\\r\\n        this.otstup=this.par.par.otstup;\\r\\n        this.dCont=new DCont(this.par.par.dCont);\\r\\n        this.panel=new DPanel(this.dCont, 0, 0)\\r\\n        this.panel.height=this.whv-this.otstup;\\r\\n        //this.panel.color=0x79bccc;\\r\\n        \\r\\n        this.button=new DButton(this.dCont, this.otstup, this.otstup,\"load xls?\", function(){\\r\\n            trace(\"ищем ключ 384576\")\\r\\n        });\\r\\n        this.button.height=this.panel.height-this.otstup*2\\r\\n\\r\\n        this.sizeWindow = function(w,h){  \\r\\n            this.panel.width=w;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/localStorage/LocalStorage.js\\n\\r\\nfunction LocalStorage(fun,_key) {\\r\\n\\tthis.fun = fun;\\r\\n\\tvar self = this;\\r\\n\\tthis.object;\\r\\n\\tthis.key = _key||\\'shirt\\';\\r\\n\\tthis.object; // тут храняться все данные с localStorage\\r\\n\\tvar b;\\r\\n\\t// инициализация localStorage\\r\\n\\tthis.initLoad=function() {\\r\\n\\t\\tb=true;\\r\\n\\t\\tthis.object = window.localStorage[this.key];\\r\\n\\t\\tif(this.object == \"undefined\")b=false;\\r\\n\\t\\tif(this.object == undefined)b=false;\\r\\n\\t\\t\\r\\n\\t\\t// проверка пуст ли  localStorage\\r\\n\\t\\tif(b == false) {\\r\\n\\t\\t\\tthis.object = this.getStartObj(); // если localStorage пуст, записываем обьект с функции getStartObj\\r\\n\\t\\t}else {\\r\\n\\t\\t\\tthis.object = jQuery.parseJSON(this.object); // если localStorage не пуст записываем содержимое предварительно\\r\\n\\t\\t}\\r\\n\\t\\ttrace(\"dfghdsfgsdfg\")\\r\\n\\t\\tself.fun();\\r\\n\\t}\\r\\n\\t\\r\\n\\t// если localStorage пуст, записываем обьект\\r\\n\\tthis.getStartObj = function() {\\r\\n\\t\\tvar obj = {\\r\\n\\t\\t\\tactiv:false,\\r\\n\\t\\t\\tmenu:{},\\r\\n\\t\\t\\txz:{}\\r\\n\\t\\t};\\r\\n\\t\\treturn obj;\\r\\n\\t}\\r\\n\\r\\n\\t// сохраняем в localStorage данные\\r\\n\\tthis.save = function() {\\t\\t\\r\\n\\t\\twindow.localStorage[this.key] = JSON.stringify(self.object);\\r\\n\\t}\\r\\n\\r\\n\\t// сохраняем в localStorage данные\\r\\n\\tthis.clear = function() {\\r\\n\\t\\twindow.localStorage[this.key] = undefined;\\r\\n\\t}\\r\\n\\tsetTimeout(function() {self.initLoad();}, 1);\\r\\n\\t\\t\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\n// CONCATENATED MODULE: ./src/larvij/LMain.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return LMain_LMain; });\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nclass LMain_LMain  {\\r\\n  \\tconstructor(fun) {  \\t\\t\\r\\n  \\t\\tthis.type=\"LMain\";\\r\\n\\r\\n  \\t\\tvar self=this;\\r\\n\\r\\n  \\t\\tthis.stage = null;\\r\\n  \\t\\tthis.content2d = null;\\r\\n\\t\\tthis.renderer = null;\\r\\n\\t\\tthis.glaf=null;\\r\\n\\t\\tthis._width=100;\\r\\n\\t\\tthis._height=100;\\r\\n\\t\\tself.resolution=1\\r\\n\\t\\tself.objectBase=null\\r\\n        this.localStorage\\r\\n\\r\\n\\r\\n\\t\\tthis.contentHTML= document.createElement(\\'div\\');\\r\\n\\t\\tthis.contentHTML.style.position = \\'fixed\\';\\r\\n\\t\\tthis.contentHTML.style.top = \\'0px\\';\\r\\n\\t\\tthis.contentHTML.style.left = \\'0px\\';\\r\\n\\t\\tdocument.body.appendChild(this.contentHTML);\\r\\n\\r\\n  \\t\\t\\r\\n\\r\\n\\r\\n  \\t\\tthis.start = function () {\\r\\n  \\t\\t\\tthis.plusJSON(self.objectBase)\\r\\n  \\t\\t\\tthis.start1()\\r\\n  \\t\\t}\\r\\n        \\r\\n  \\t\\tthis.start1 = function () {\\t\\r\\n\\t\\t\\tthis.stage = new PIXI.Container();\\r\\n\\t\\t\\tthis.renderer = new PIXI.autoDetectRenderer(this._width, this._height, {antialias: true, transparent: true, preserveDrawingBuffer: true });\\r\\n\\t\\t\\tthis.renderer.view.style.position = \\'fixed\\';\\r\\n\\t\\t\\t//this.contentHTML.appendChild(this.renderer.view);\\r\\n\\t\\t\\tthis.content2d = new PIXI.Container();\\r\\n\\t\\t\\tself.stage.addChild(this.content2d);\\r\\n\\t\\t\\tvar t = new PIXI.ticker.Ticker();\\r\\n\\t\\t\\tt.minFPS = 50;\\r\\n\\t\\t\\tt.add(this.tick, this);\\r\\n\\t\\t\\tt.start();\\r\\n\\r\\n            this.localStorage = new LocalStorage(this.fina, \"larvijXZ\");\\r\\n\\t\\t\\ttrace(this.localStorage)\\r\\n\\t\\t};\\r\\n\\r\\n        this.fina = function () { \\r\\n            trace(self.localStorage)\\r\\n            self.init2();     \\r\\n            /*if(locStorage.object.activ==true){\\r\\n                self.finalComplete();           \\r\\n                return\\r\\n            }*/\\r\\n\\r\\n            //locStorage.save()\\r\\n            var ss=0;\\r\\n            function moveRect(e){                \\r\\n                if(e.key==\"q\"||e.key==\"й\"){\\r\\n                    ss++;     \\r\\n                    trace(ss)               \\r\\n                    if(ss==10){\\r\\n                        self.localStorage.object.activ=!self.localStorage.object.activ;                        \\r\\n                        self.sizeWindow(200,200);\\r\\n                        self.localStorage.save()\\r\\n                        self.finalComplete();\\r\\n                        document.removeEventListener(\"keydown\", moveRect);\\r\\n                    }\\r\\n                   \\r\\n                }\\r\\n            }\\r\\n            document.addEventListener(\"keydown\", moveRect);\\r\\n            trace(\"MMM111MMMM\") \\r\\n        }\\r\\n\\r\\n\\r\\n        trace(\"MMMMMMMMMMMM444444444MMMMM\") \\r\\n\\r\\n\\t\\tthis.init2 = function () {\\r\\n\\t\\t\\tnew StylePL102(this.stage, this.renderer, this.contentHTML);// document.body);\\r\\n            trace(self.localStorage)\\r\\n\\t\\t\\tif(self.localStorage.object.activ==false)self.glaf=new Glaf_Glaf(this)\\r\\n            else{\\r\\n                self.glaf=new AGlaf_AGlaf(this)\\r\\n            }    \\r\\n\\t\\t\\tfun(\"init\");\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\r\\n\\t\\tthis.tick = function () {\\r\\n\\t\\t\\tself.renderer.resolution = window.devicePixelRatio * self.resolution;// ставим разрешение рендера (соотношение пикселей)\\r\\n\\t\\t\\tself.renderer.render(self.stage);\\r\\n\\t\\t\\tTWEEN.update();\\t\\r\\n\\t\\t\\tif (self.glaf) {\\r\\n\\t\\t\\t\\tself.glaf.update();\\r\\n\\t\\t\\t}\\t\\t\\t\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n  \\t\\tthis.sizeWindow = function(w,h){    \\t\\t\\t\\r\\n  \\t\\t\\t\\r\\n  \\t\\t\\tself._width=w;\\r\\n\\t\\t\\tself._height=h;\\r\\n\\t\\t\\tif(self.renderer){\\r\\n\\t  \\t\\t\\tvar precresol = self.resolution;// запоминаем предыдущее разрешение пикселей рендера\\r\\n\\t\\t\\t\\tself.renderer.view.style.width = self._width + \\'px\\';\\r\\n\\t\\t\\t\\tself.renderer.view.style.height = self._height + \\'px\\';\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tself.renderer.resolution = 1;// перед изменение размера в дефолт\\r\\n\\t\\t\\t\\tself.renderer.resize(self._width, self._height);\\r\\n\\t\\t\\t\\tself.renderer.resolution = precresol;// ставим обратно разрешение\\r\\n\\r\\n\\t\\t\\t}\\r\\n  \\t\\t\\tif (self.glaf) { \\r\\n  \\t\\t\\t\\tself.glaf.sizeWindow(w,h)\\r\\n  \\t\\t\\t}\\t\\t\\t\\r\\n  \\t\\t}\\r\\n\\r\\n  \\t\\t$.ajax({\\r\\n            url: \"resources/config.json\",\\r\\n            success: function function_name(data) {                         \\r\\n                if(typeof data === \"string\") {\\r\\n\\t\\t\\t\\t\\tvar conf = JSON.parse(data)\\r\\n\\t\\t\\t\\t\\tself.objectBase = conf;\\r\\n\\t\\t\\t\\t} else self.objectBase = data;\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tself.start();\\t\\t\\t\\r\\n                                 \\r\\n            },\\r\\n            error:function function_name(data) {\\r\\n                trace(\"Что то случилось с конфигом\")\\r\\n            }\\r\\n        });  \\r\\n\\r\\n\\r\\n        this.plusJSON=function(o){\\r\\n\\r\\n        \\tvar a=[];\\r\\n        \\tvar a0={array:[]};\\r\\n        \\ta0.array.push({title:\"a0_0\",id:0,colorBool:false});\\r\\n        \\ta0.array.push({title:\"a0_1\",id:1,colorBool:true});\\r\\n        \\ta0.array.push({title:\"a0_2\",id:0,colorBool:true});\\r\\n        \\ta0.array.push({title:\"a0_3\",id:1,colorBool:true});\\r\\n        \\ta0.array.push({title:\"a0_4\",id:0,colorBool:true});\\r\\n        \\ta.push(a0);\\r\\n        \\tvar a1={array:[]};\\r\\n        \\ta1.array.push({title:\"a1_0\",id:0});\\r\\n        \\ta1.array.push({title:\"a1_1\",id:1});       \\t\\r\\n        \\ta.push(a1);\\r\\n        \\tfor (var i = 0; i < a0.array.length; i++) {\\r\\n        \\t\\tvar r=1+Math.random()*5;\\r\\n        \\t\\ta0.array[i].array=[];\\r\\n        \\t\\tfor (var j = 0; j < r; j++) {\\r\\n        \\t\\t\\ta0.array[i].array.push({title:a0.array[i].title+\"_\"+j,id:Math.round(Math.random())});\\r\\n        \\t\\t}\\r\\n        \\t}\\r\\n        \\to.array=a;\\r\\n\\r\\n            //o.bd=[0,1]\\r\\n\\r\\n        \\t//trace(JSON.stringify(o,null,4))\\r\\n        \\t//trace(\">>>litel---\"+JSON.stringify(o))\\r\\n        }\\r\\n\\r\\n\\r\\n  \\t}\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\n\\n//# sourceURL=webpack:///./src/larvij/LMain.js_+_15_modules?')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('\\n// CONCATENATED MODULE: ./src/libMy/visi3D/MFoto3D.js\\n/*\\r\\n \\r\\n*/\\r\\nfunction MFoto3D() { // для фотографирования 3д\\r\\n    var self = this;\\r\\n\\r\\n    var SCREEN_WIDTH = 256;\\r\\n    var SCREEN_HEIGHT = 256;\\r\\n\\r\\n    var scene = new THREE.Scene();\\r\\n    // var camera = new THREE.PerspectiveCamera(54, SCREEN_WIDTH / SCREEN_HEIGHT, 0.01, 1000000);\\r\\n    var camera = new THREE.OrthographicCamera(SCREEN_WIDTH / -2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / -2, 0.001, 10000);\\r\\n    var clock = new THREE.Clock();\\r\\n    var renderer = new THREE.WebGLRenderer({\\r\\n        antialias: true,\\r\\n        alpha: true,\\r\\n        preserveDrawingBuffer: true\\r\\n    });\\r\\n    camera.position.set(200, 200, 200);\\r\\n    scene.add(camera);\\r\\n\\r\\n    // var ctx = renderer.context.canvas.getContext(\"webgl\");\\r\\n    \\r\\n    this.camera = camera;\\r\\n\\r\\n    this.fotoContainer = new THREE.Object3D();\\r\\n    scene.add(this.fotoContainer);\\r\\n\\r\\n    scene.background = new THREE.Color(0x0096ff);\\r\\n    renderer.setPixelRatio(window.devicePixelRatio);\\r\\n    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);\\r\\n\\r\\n    renderer.localClippingEnabled = true; //\\r\\n\\r\\n    var contentHTML = document.createElement(\\'div\\');\\r\\n    contentHTML.style.position = \\'absolute\\';\\r\\n    contentHTML.style.bottom = \\'0px\\';\\r\\n    contentHTML.style.left = \\'0px\\';\\r\\n    // contentHTML.style.zIndex = \\'150\\';\\r\\n    contentHTML.appendChild(renderer.domElement);\\r\\n    this.contentHTML = contentHTML;\\r\\n    this.canvas = renderer.domElement;\\r\\n    this.contentHTML = contentHTML;\\r\\n    // document.body.appendChild(contentHTML);\\r\\n\\r\\n    var ambientLight = new THREE.AmbientLight(\"#ffffff\", 1);\\r\\n    scene.add(ambientLight);\\r\\n    // var sunLight = new THREE.DirectionalLight(\\'rgb(255,255,255)\\', 0.9);\\r\\n    // scene.add(sunLight);\\r\\n\\r\\n    // helper debug\\r\\n    var gridHelper = new THREE.GridHelper(1000, 10);\\r\\n    var axesHelper = new THREE.AxesHelper(100);\\r\\n    var boxHelper = new THREE.BoxHelper(this.fotoContainer, 0xffff00);\\r\\n    scene.add(gridHelper);\\r\\n    scene.add(axesHelper);\\r\\n    scene.add(boxHelper);\\r\\n\\r\\n    var arrHelper = [axesHelper, gridHelper, boxHelper];\\r\\n\\r\\n    function animate() {\\r\\n        render();\\r\\n        boxHelper.setFromObject(self.fotoContainer);\\r\\n    }\\r\\n\\r\\n    function render() {\\r\\n        renderer.render(scene, camera);\\r\\n    }\\r\\n    this.render = render;\\r\\n    animate();\\r\\n\\r\\n\\r\\n    var box = new THREE.Box3();\\r\\n    var center = new THREE.Vector3();\\r\\n\\r\\n    this.box = box;\\r\\n    this.center = center;\\r\\n\\r\\n\\r\\n    this.setSize = function(width, height) { // размер рендера\\r\\n        SCREEN_WIDTH = width;\\r\\n        SCREEN_HEIGHT = height;\\r\\n        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);\\r\\n        camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\\r\\n        camera.updateProjectionMatrix();\\r\\n    };\\r\\n\\r\\n    this.addObjFoto = function(obj) {\\r\\n        // this.fotoContainer.children.length = 0;\\r\\n        // obj.position.set(0, 0, 0);\\r\\n        // obj.visible = true;\\r\\n        this.fotoContainer.add(obj);\\r\\n        boxHelper.setFromObject(this.fotoContainer);\\r\\n    };\\r\\n    this.removeObjFoto = function(obj) {\\r\\n        this.fotoContainer.remove(obj);\\r\\n    };\\r\\n\\r\\n\\r\\n    this.moveToObj = function(obj) {\\r\\n        box.setFromObject(obj || self.fotoContainer);\\r\\n        var w = (box.max.x - box.min.x);\\r\\n        var h = (box.max.z - box.min.z);\\r\\n        self.moveToRect(box.min.x, box.min.z, w, h);\\r\\n    };\\r\\n\\r\\n    this.moveToRect = function(x, y, w, h) { // здвинуть на рект\\r\\n        x += w / 2;\\r\\n        y += h / 2;\\r\\n        center.set(x, 0, y);\\r\\n\\r\\n        camera.position.set(center.x, 9000, center.z);\\r\\n        camera.lookAt(center);\\r\\n\\r\\n        orbitControls.target.set(center.x, center.y, center.z);\\r\\n\\r\\n        if (camera.type === \\'OrthographicCamera\\') {\\r\\n            var s = Math.max(h, w);\\r\\n            camera.zoom = 1;\\r\\n            camera.left = s / -2;\\r\\n            camera.right = s / 2;\\r\\n            camera.top = s / 2;\\r\\n            camera.bottom = s / -2;\\r\\n            camera.aspect = s / s;\\r\\n        }\\r\\n        camera.updateProjectionMatrix();\\r\\n        // render();\\r\\n    };\\r\\n\\r\\n    this.getFoto = function(imgWH) { /// получить b64\\r\\n        imgWH = imgWH || 1024;\\r\\n\\r\\n        for (var i = 0; i < arrHelper.length; i++) {\\r\\n            arrHelper[i].visible = false;\\r\\n        }\\r\\n        var prev = scene.background;\\r\\n        scene.background = null;\\r\\n        renderer.setSize(imgWH, imgWH);\\r\\n        render();\\r\\n        var imgData = renderer.domElement.toDataURL(\"image/png\");\\r\\n        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);\\r\\n        scene.background = prev;\\r\\n\\r\\n        for (var j = 0; j < arrHelper.length; j++) {\\r\\n            arrHelper[j].visible = true;\\r\\n        }\\r\\n        render();\\r\\n        return imgData;\\r\\n    };\\r\\n\\r\\n    this.getCanvas = function(imgWH) {\\r\\n        imgWH = imgWH || 1024;\\r\\n        for (var i = 0; i < arrHelper.length; i++) {\\r\\n            arrHelper[i].visible = false;\\r\\n        }\\r\\n        var prev = scene.background;\\r\\n        scene.background = null;\\r\\n\\r\\n        var wh = renderer.getSize();\\r\\n        if (wh.width != imgWH || wh.height != imgWH) {\\r\\n            renderer.setSize(imgWH, imgWH);\\r\\n        }\\r\\n        render();\\r\\n\\r\\n        // todo delete\\r\\n        // setTimeout(function() {\\r\\n        //     renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);\\r\\n        //     scene.background = prev;\\r\\n\\r\\n        //     for (var j = 0; j < arrHelper.length; j++) {\\r\\n        //         arrHelper[j].visible = true;\\r\\n        //     }\\r\\n        //     render();\\r\\n\\r\\n        // }, 1);\\r\\n\\r\\n        return renderer.domElement;\\r\\n    };\\r\\n\\r\\n\\r\\n    // дебаг управление todo delete\\r\\n    var orbitControls = new THREE.OrbitControls(camera, contentHTML);\\r\\n    orbitControls.enableKeys = false;\\r\\n    orbitControls.minDistance = 1;\\r\\n    orbitControls.minZoom = 1;\\r\\n    orbitControls.maxZoom = 1;\\r\\n    orbitControls.addEventListener(\\'change\\', function() {\\r\\n        animate();\\r\\n    });\\r\\n\\r\\n}\\n// CONCATENATED MODULE: ./src/libMy/visi3D/MShadowMeshContainer.js\\n/*\\r\\n        var s = 300;\\r\\n        smc = new MShadowMeshContainer();\\r\\n        smc.fotoPosition.set(0, 0);// def 0,0\\r\\n        smc.fotoWH = s;// def 150\\r\\n\\r\\n        var geo = new THREE.PlaneBufferGeometry();\\r\\n        geo.translate(0.5, -0.5, 0);\\r\\n        geo.rotateX(-Math.PI / 2);\\r\\n\\r\\n        // для тени\\r\\n        var m = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({\\r\\n            transparent: true,\\r\\n            map: smc.texturePlan\\r\\n        }));\\r\\n        m.scale.set(s, 1, s);\\r\\n        m.position.set(smc.fotoPosition.x, 0, smc.fotoPosition.y);\\r\\n        scene.add(m);\\r\\n\\r\\n        smc.upDate();// animate\\r\\n */\\r\\n\\r\\n\\r\\n\\r\\nfunction MShadowMeshContainer(_foto3D) {\\r\\n    var self = this;\\r\\n\\r\\n    var uuid = THREE.Math.generateUUID();\\r\\n\\r\\n    var normalVector = new THREE.Vector3(0, 1, 0);\\r\\n    var planeConstant = 0.01; // this value must be slightly higher than the groundMesh\\'s y position of 0.0\\r\\n    var groundPlane = new THREE.Plane(normalVector, planeConstant);\\r\\n    var lightPosition4D = new THREE.Vector4(0, 999, 0, 0.001);\\r\\n\\r\\n    var box = new THREE.Box3();\\r\\n    var foto3D = _foto3D || new MFoto3D();\\r\\n    this.foto3D = foto3D;\\r\\n\\r\\n    var tp = new THREE.Vector2(0, 0);\\r\\n    var twh = 100;\\r\\n\\r\\n    var imageBlur = new ImageBlur(); // \\r\\n    this.canvas = imageBlur.canvas;\\r\\n\\r\\n    this.isTime = false;\\r\\n\\r\\n    var texturePlan = new THREE.Texture(imageBlur.canvas); // текстура плана тени !!!!\\r\\n    this.texturePlan = texturePlan;\\r\\n\\r\\n    this.matPlan = new THREE.MeshPhongMaterial({\\r\\n        transparent: true,\\r\\n        side: THREE.DoubleSide,\\r\\n        // opacity: 0.7,\\r\\n        map: texturePlan\\r\\n    });\\r\\n\\r\\n    var canvasGG = new CanvasGG();\\r\\n    this.canvasGG = canvasGG;\\r\\n    // для текстуры тени\\r\\n\\r\\n    // \"arrColorStopTranspanent\": [0.15, 1],\\r\\n    // \"arrProcent\": [0.82, 1]\\r\\n    canvasGG.arrColorStopTranspanent[0] = 0.15;\\r\\n    canvasGG.arrProcent[0] = 0.82;\\r\\n    canvasGG.arrColorStopTranspanent[1] = 1;\\r\\n    canvasGG.arrProcent[1] = 1;\\r\\n    canvasGG.update();\\r\\n\\r\\n    var textureShadow = new THREE.Texture(canvasGG.canvas); // текстура обектов тени\\r\\n    textureShadow.needsUpdate = true; // important!\\r\\n    this.textureShadow = textureShadow;\\r\\n\\r\\n    this.content3d = new THREE.Object3D(); // в нем план тени\\r\\n    this.shadowContent3d = new THREE.Object3D(); // контейнер для теней ()\\r\\n    // this.content3d.add(this.shadowContent3d);\\r\\n\\r\\n    // foto3D.addObjFoto(self.shadowContent3d);\\r\\n\\r\\n    this.meshPlan = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1), this.matPlan); // сам пла масштабируется по scale\\r\\n    this.meshPlan.rotation.x = -Math.PI / 2;\\r\\n    this.content3d.add(this.meshPlan);\\r\\n\\r\\n    // дебагер точки света\\r\\n    var meshLight = new THREE.Mesh(new THREE.SphereBufferGeometry(10, 16, 16));\\r\\n    meshLight.position.set(lightPosition4D.x, lightPosition4D.y, lightPosition4D.z);\\r\\n\\r\\n    // if (window.visi3D && window.visi3D.objects && window.visi3D.sceneHelpers) {\\r\\n    //     visi3D.sceneHelpers.add(meshLight);\\r\\n    //     visi3D.objects.push(meshLight);\\r\\n    // }\\r\\n\\r\\n    // meshLight.addEventListener(\\'objectChange\\', function(e) {\\r\\n    //     lightPosition4D.x = meshLight.position.x;\\r\\n    //     lightPosition4D.y = meshLight.position.y;\\r\\n    //     lightPosition4D.z = meshLight.position.z;\\r\\n    //     self.upDate();\\r\\n    // });\\r\\n\\r\\n    this.arrShadowMesh = []; // обекты тени\\r\\n    this.arrObj = []; // 3д обекты по которым делаем тени\\r\\n\\r\\n    this._dunamic = true;\\r\\n    this.dirty = true; // если нужно полюбому сделать рендер\\r\\n\\r\\n    this._lightPosition4D = lightPosition4D; // позиция освещения\\r\\n\\r\\n    this._fotoPosition = new THREE.Vector2(0, 0); // позиция где делать фото тени\\r\\n    this._fotoWH = 150; // размер что фотать\\r\\n\\r\\n    this._imgWH = 512; // размер картинки\\r\\n    this._imgBlur = 1; // not used\\r\\n    this._imgAlpha = 1; // not used\\r\\n\\r\\n    this._offsetY = 0; // смещение 0 расчетов теней\\r\\n    this._scaleShadow = 1; // масштаб теней\\r\\n\\r\\n    this._isDinamFotoRect = false; // true - берет размер всех обектов, false - берет размеры \\r\\n\\r\\n    this._opacityMat = 1; // прозрачность материала тени\\r\\n\\r\\n\\r\\n    var clipPlanes = [\\r\\n        new THREE.Plane(new THREE.Vector3(0, -1, 0), 100),\\r\\n        new THREE.Plane(new THREE.Vector3(0, 1, 0), 0),\\r\\n    ];\\r\\n\\r\\n    this._shadowMaterial = new THREE.MeshBasicMaterial({ // материал тени\\r\\n        // color: 0x000000,\\r\\n        side: THREE.DoubleSide,\\r\\n        transparent: true,\\r\\n        opacity: this._opacityMat,\\r\\n        depthWrite: false,\\r\\n        map: textureShadow,\\r\\n\\r\\n        clippingPlanes: clipPlanes,\\r\\n        clipIntersection: false\\r\\n\\r\\n    });\\r\\n\\r\\n    this.arrDataSempl = []; // данные для шагов блюра\\r\\n    this.arrDataSempl.push(new DataSempl(0, 200, 3, 1));\\r\\n\\r\\n\\r\\n    // helpers\\r\\n    var helpers = new THREE.Group();\\r\\n    this.content3d.add(helpers);\\r\\n\\r\\n    var meshShad = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1), new THREE.MeshBasicMaterial({\\r\\n        side: THREE.DoubleSide,\\r\\n        map: textureShadow,\\r\\n        transparent: true,\\r\\n    }));\\r\\n    meshShad.scale.set(1, 30, 1);\\r\\n    meshShad.rotation.z = -Math.PI / 2;\\r\\n    helpers.add(meshShad);\\r\\n    helpers.visible = false;\\r\\n    this.helpers = helpers;\\r\\n\\r\\n    this.setConstMax = function(c) {\\r\\n        clipPlanes[0].constant = c;\\r\\n    };\\r\\n    this.setConstMin = function(c) {\\r\\n        clipPlanes[1].constant = -c;\\r\\n    };\\r\\n\\r\\n    this.addObj = function(object) {\\r\\n       \\r\\n        var index = self.arrObj.indexOf(object);\\r\\n        if (index != -1) return; // обект уже есть\\r\\n        object.updateMatrixWorld();\\r\\n\\r\\n        var sc = object.clone();\\r\\n        bridge(sc, object);\\r\\n        replaceMaterialMesh(sc);\\r\\n\\r\\n        self.arrShadowMesh.push(sc);\\r\\n        self.arrObj.push(object);\\r\\n        self.shadowContent3d.add(sc);\\r\\n        this.dirty = true;\\r\\n    };\\r\\n\\r\\n    this.removeObj = function(object) {\\r\\n        var index = self.arrObj.indexOf(object);\\r\\n        if (index == -1) return;\\r\\n        self.arrObj.splice(index, 1);\\r\\n        self.shadowContent3d.remove(self.arrShadowMesh[index]);\\r\\n        self.arrShadowMesh.splice(index, 1);\\r\\n        this.dirty = true;\\r\\n    };\\r\\n\\r\\n    this.clear = function() {\\r\\n        var len = 0;\\r\\n        while ((len = self.arrObj.length) > 0) {\\r\\n            self.removeObj(self.arrObj[len - 1]);\\r\\n            if (len === self.arrObj.length) {\\r\\n                throw new Error(\\'object not remove\\');\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n    this.intRend = 1;\\r\\n    this.intRendOk = 1;\\r\\n\\r\\n    // var tim = null;\\r\\n    this.upDate = function() {\\r\\n        if (!self.opacityMat) return;\\r\\n        if (self.dunamic) {\\r\\n            self.intRend = self.intRendOk;\\r\\n        }\\r\\n\\r\\n        if (self.intRend == self.intRendOk) {\\r\\n            // clearTimeout(tim);\\r\\n            // tim = setTimeout(self.render, 10);\\r\\n            if (self.dirty || isChangeObj()) {\\r\\n\\r\\n                self.render();\\r\\n            }\\r\\n        }\\r\\n        self.intRend++;\\r\\n    };\\r\\n\\r\\n    var offsetFotoDinamRect = 100;\\r\\n\\r\\n    this.render = function() {\\r\\n        if (self.isTime) console.time(\\'render \\' + uuid);\\r\\n\\r\\n        self.dirty = false;\\r\\n\\r\\n        updateShadowMatrixMesh();\\r\\n\\r\\n        // var par = self.shadowContent3d.parent;\\r\\n\\r\\n        foto3D.addObjFoto(self.shadowContent3d);\\r\\n\\r\\n        twh = self.fotoWH;\\r\\n        tp.x = self.fotoPosition.x;\\r\\n        tp.y = self.fotoPosition.y;\\r\\n\\r\\n        if (self.isDinamFotoRect) {\\r\\n            box.setFromObject(self.shadowContent3d);\\r\\n            tp.x = box.min.x;\\r\\n            tp.y = box.min.z;\\r\\n            twh = Math.max((box.max.x - box.min.x), (box.max.z - box.min.z));\\r\\n\\r\\n            tp.x -= offsetFotoDinamRect;\\r\\n            tp.y -= offsetFotoDinamRect;\\r\\n            twh += offsetFotoDinamRect * 2;\\r\\n        }\\r\\n\\r\\n        foto3D.moveToRect(tp.x, tp.y, twh, twh); // здвигаем \\r\\n\\r\\n        updateTexturePlan();\\r\\n\\r\\n        // foto3D.removeObjFoto(self.shadowContent3d);\\r\\n\\r\\n        self.meshPlan.scale.set(twh, twh, 1);\\r\\n        self.meshPlan.position.set(tp.x + twh / 2, 0, tp.y + twh / 2);\\r\\n\\r\\n        // if (par) par.add(self.shadowContent3d);\\r\\n\\r\\n        if (self.isTime) console.timeEnd(\\'render \\' + uuid);\\r\\n\\r\\n        if (self.onUpdate) self.onUpdate();\\r\\n    };\\r\\n\\r\\n    function isChangeObj() { // проверка изменился ли обекты\\r\\n        for (var i = 0; i < self.arrShadowMesh.length; i++) {\\r\\n\\r\\n            if (!self._isDinamFotoRect) {\\r\\n                if (!isInFotoRectMesh(self.arrShadowMesh[i])) {\\r\\n                    continue;\\r\\n                }\\r\\n            }\\r\\n            if (isChangeMesh(self.arrShadowMesh[i])) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function isInFotoRectMesh(shadowMesh) { // попадает ли обект в рект фото\\r\\n        var colisTarget = false;\\r\\n        var colisShadow = false;\\r\\n        var x = box.min.x;\\r\\n        var y = box.min.z;\\r\\n        var w = box.max.x - box.min.x;\\r\\n        var h = box.max.z - box.min.z;\\r\\n\\r\\n        box.setFromObject(shadowMesh.userData.targetObject);\\r\\n        x = box.min.x;\\r\\n        y = box.min.z;\\r\\n        w = box.max.x - box.min.x;\\r\\n        h = box.max.z - box.min.z;\\r\\n        colisTarget = isColRect(x, y, w, h, self.fotoPosition.x, self.fotoPosition.y, self.fotoWH, self.fotoWH);\\r\\n        box.setFromObject(shadowMesh);\\r\\n        x = box.min.x;\\r\\n        y = box.min.z;\\r\\n        w = box.max.x - box.min.x;\\r\\n        h = box.max.z - box.min.z;\\r\\n        colisShadow = isColRect(x, y, w, h, self.fotoPosition.x, self.fotoPosition.y, self.fotoWH, self.fotoWH);\\r\\n\\r\\n        if (!colisTarget && !colisShadow) { // оба обекта верхнего уровня за границой\\r\\n            return false;\\r\\n        }\\r\\n        //---\\r\\n        colisTarget = false;\\r\\n        colisShadow = false;\\r\\n        for (var i = 0; i < shadowMesh.children.length; i++) {\\r\\n            box.setFromObject(shadowMesh.children[i].userData.targetObject);\\r\\n            x = box.min.x;\\r\\n            y = box.min.z;\\r\\n            w = box.max.x - box.min.x;\\r\\n            h = box.max.z - box.min.z;\\r\\n            colisTarget = colisTarget || isColRect(x, y, w, h, self.fotoPosition.x, self.fotoPosition.y, self.fotoWH, self.fotoWH);\\r\\n            box.setFromObject(shadowMesh.children[i]);\\r\\n            x = box.min.x;\\r\\n            y = box.min.z;\\r\\n            w = box.max.x - box.min.x;\\r\\n            h = box.max.z - box.min.z;\\r\\n            colisShadow = colisShadow || isColRect(x, y, w, h, self.fotoPosition.x, self.fotoPosition.y, self.fotoWH, self.fotoWH);\\r\\n\\r\\n            if (colisTarget || colisShadow) { // какойто внутрений обект не за границой\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function isChangeMesh(shadowMesh) { // проверка изменился ли обект\\r\\n        if (!isEqualsTransform(shadowMesh, shadowMesh.userData.targetObject)) {\\r\\n            return true;\\r\\n        }\\r\\n        for (var i = 0; i < shadowMesh.children.length; i++) {\\r\\n            if (isChangeMesh(shadowMesh.children[i])) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function updateTexturePlan() { // обновить текстуру плана\\r\\n        var c = foto3D.getCanvas(self.imgWH);\\r\\n        imageBlur.setCanvas(c);\\r\\n        // foto3D.render();\\r\\n        if (self.arrDataSempl.length == 0) imageBlur.update();\\r\\n\\r\\n        for (var i = 0; i < self.arrDataSempl.length; i++) {\\r\\n            self.setConstMin(self.arrDataSempl[i].min * self._scaleShadow + (self._offsetY));\\r\\n            self.setConstMax(self.arrDataSempl[i].max * self._scaleShadow + (self._offsetY));\\r\\n\\r\\n            foto3D.render();\\r\\n\\r\\n            imageBlur._blur = self.arrDataSempl[i].blur + (self._scaleShadow > 1 ? self._scaleShadow : 0);\\r\\n            imageBlur._alpha = self.arrDataSempl[i].alpha;\\r\\n            imageBlur.update();\\r\\n        }\\r\\n\\r\\n        self.setConstMin(-999999);\\r\\n        self.setConstMax(999999);\\r\\n        texturePlan.needsUpdate = true;\\r\\n    }\\r\\n\\r\\n    function applyTransfornRec(obj) { // применить трансформацию обекта рекусивно\\r\\n        applyTransforn(obj, obj.userData.targetObject);\\r\\n        for (var i = 0; i < obj.children.length; i++) {\\r\\n            applyTransfornRec(obj.children[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateShadowMatrixMesh() { // пересчитать тени обектов\\r\\n        // return\\r\\n        lightPosition4D.w = 0.001; // more of a directional Light value\\r\\n        meshLight.position.set(lightPosition4D.x, lightPosition4D.y, lightPosition4D.z);\\r\\n\\r\\n        for (var i = 0; i < self.arrShadowMesh.length; i++) {\\r\\n            applyTransfornRec(self.arrShadowMesh[i]);\\r\\n        }\\r\\n\\r\\n        updateShadowUv();\\r\\n    }\\r\\n\\r\\n    var boundingBoxUv = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3(300, 300, 300));\\r\\n    this.boundingBoxUv = boundingBoxUv;\\r\\n    var position = new THREE.Vector3();\\r\\n\\r\\n    function corectUVShadow(shadowMesh) { // пересчет ув по высоте\\r\\n        if (shadowMesh.geometry.uuid === shadowMesh.userData.targetObject.geometry.uuid) {\\r\\n            shadowMesh.geometry = shadowMesh.userData.targetObject.geometry.clone();\\r\\n        }\\r\\n        // shadowMesh.geometry.computeBoundingBox();\\r\\n        var boundingBox = boundingBoxUv; // shadowMesh.geometry.boundingBox; //boundingBoxUv; // \\r\\n        var py = 0;\\r\\n\\r\\n        if (shadowMesh.geometry instanceof THREE.Geometry) {\\r\\n\\r\\n            var faces = shadowMesh.geometry.faces;\\r\\n            var vertices = shadowMesh.geometry.vertices;\\r\\n            var faceVertexUvs = shadowMesh.geometry.faceVertexUvs[0];\\r\\n            for (var i = 0; i < faces.length; i++) {\\r\\n\\r\\n                position.set(vertices[faces[i].a].x, vertices[faces[i].a].y, vertices[faces[i].a].z);\\r\\n                shadowMesh.localToWorld(position);\\r\\n                py = 1 - getProcent(position.y - (self._offsetY /*/ self._scaleShadow*/ ), boundingBox.min.y, boundingBox.min.y + boundingBox.max.y) / 100;\\r\\n                faceVertexUvs[i][0].set(py, py);\\r\\n\\r\\n                position.set(vertices[faces[i].b].x, vertices[faces[i].b].y, vertices[faces[i].b].z);\\r\\n                shadowMesh.localToWorld(position);\\r\\n                py = 1 - getProcent(position.y - (self._offsetY /*/ self._scaleShadow*/ ), boundingBox.min.y, boundingBox.min.y + boundingBox.max.y) / 100;\\r\\n                faceVertexUvs[i][1].set(py, py);\\r\\n\\r\\n                position.set(vertices[faces[i].c].x, vertices[faces[i].c].y, vertices[faces[i].c].z);\\r\\n                shadowMesh.localToWorld(position);\\r\\n                py = 1 - getProcent(position.y - (self._offsetY /*/ self._scaleShadow*/ ), boundingBox.min.y, boundingBox.min.y + boundingBox.max.y) / 100;\\r\\n                faceVertexUvs[i][2].set(py, py);\\r\\n            }\\r\\n\\r\\n            shadowMesh.geometry.uvsNeedUpdate = true;\\r\\n\\r\\n        } else {\\r\\n\\r\\n\\r\\n            var arrPosition = shadowMesh.geometry.attributes.position.array;\\r\\n\\r\\n\\r\\n            if (!shadowMesh.geometry.attributes.uv) { // если нет атрибута создаем новый\\r\\n                arrUvAttribut = new Float32Array((arrPosition.length / 3) * 2);\\r\\n                shadowMesh.geometry.addAttribute(\\'uv\\', new THREE.BufferAttribute(arrUvAttribut, 2));\\r\\n            }\\r\\n\\r\\n            var arrUv = shadowMesh.geometry.attributes.uv.array;\\r\\n            var itemSize = shadowMesh.geometry.attributes.uv.itemSize;\\r\\n\\r\\n            var arrIndex = shadowMesh.geometry.index.array;\\r\\n            var count = shadowMesh.geometry.index.count;\\r\\n\\r\\n            var indexUv = 0;\\r\\n            var indexInd = 0;\\r\\n\\r\\n            //----\\r\\n            for (var i = 0; i < count; i++) {\\r\\n                var ind = arrIndex[i];\\r\\n                var indP = (ind * 3);\\r\\n                var indUv = (ind * 2);\\r\\n\\r\\n                position.set(arrPosition[(indP)], arrPosition[(indP + 1)], arrPosition[(indP + 2)]);\\r\\n\\r\\n                shadowMesh.localToWorld(position);\\r\\n                // if(i%500==0)trace(\\'--=\\', \\'position.y\\', position.y);\\r\\n                // var px = 1 - getProcent(position.x, boundingBox.min.x, boundingBox.max.x) / 100;\\r\\n                py = 1 - getProcent(position.y - (self._offsetY /*/ self._scaleShadow*/ ), boundingBox.min.y, boundingBox.min.y + boundingBox.max.y * self._scaleShadow) / 100;\\r\\n                // var pz = 1 - getProcent(position.z, boundingBox.min.z, boundingBox.max.z) / 100;\\r\\n                // var ppx = 1 - calc.diffNum(0.5, px) / 0.5;\\r\\n                // var ppz = 1 - calc.diffNum(0.5, pz) / 0.5;\\r\\n                // var py = 1 - getProcent(arrPosition[(indP + 1)], boundingBox.min.y, boundingBox.max.y) / 100;\\r\\n                arrUv[indUv] = py; // * ppz * ppx; //(py*ppx *ppz/*+ (ppx + ppz)*0.1*/) // 3;\\r\\n                arrUv[indUv + 1] = py; // * ppz * ppx; //(py*ppx *ppz/*+ (ppx + ppz)*0.1*/) // 3;\\r\\n            }\\r\\n            shadowMesh.geometry.attributes.uv.needsUpdate = true;\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function findRecMesh(obj, arr) { //найти все мешы в обекте\\r\\n        if (obj.type == \\'Mesh\\') {\\r\\n            arr.push(obj);\\r\\n        }\\r\\n        for (var i = 0; i < obj.children.length; i++) {\\r\\n            if (obj.type == \\'Mesh\\') {\\r\\n                arr.push(obj.children[i]);\\r\\n            } else {\\r\\n                findRecMesh(obj.children[i], arr);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateUvMesh(obj) {\\r\\n        if (obj.type === \\'Mesh\\') {\\r\\n            var isUpdateUvMesh = false; // нужно ли пересчитывать ув меша \\r\\n            var wpos = obj.getWorldPosition(obj.position);\\r\\n            var wrot = obj.getWorldQuaternion(obj.quaternion);\\r\\n            var maxHeight = self.maxHeight;\\r\\n            wpos.y -= (self._offsetY /* / self._scaleShadow*/ );\\r\\n\\r\\n            if (!obj.userData.pos) { // когда первый раз зашли\\r\\n                isUpdateUvMesh = true;\\r\\n            } else if (obj.userData.pos.y != wpos.y) { // когда позиция по высоте поменылась\\r\\n                isUpdateUvMesh = true;\\r\\n            } else if (!obj.userData.rot.equals(wrot)) { // когда повернули \\r\\n                isUpdateUvMesh = true;\\r\\n            } else if (obj.userData.maxHeight !== maxHeight) { // когда поменялся конф высота\\r\\n                isUpdateUvMesh = true;\\r\\n            } else if (obj.userData.scaleShadow !== self._scaleShadow) { // когда поменялся конф высота\\r\\n                isUpdateUvMesh = true;\\r\\n            }\\r\\n\\r\\n            if (!self._isDinamFotoRect) { // оптимизация если обект за ректом его пересчитывать не нужно \\r\\n                box.setFromObject(obj);\\r\\n                if (!isColRect(box.min.x, box.min.z, box.max.x - box.min.x, box.max.z - box.min.z, self.fotoPosition.x, self.fotoPosition.y, self.fotoWH, self.fotoWH)) {\\r\\n                    isUpdateUvMesh = false;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (isUpdateUvMesh) {\\r\\n                corectUVShadow(obj);\\r\\n                obj.userData.pos = wpos;\\r\\n                obj.userData.rot = wrot;\\r\\n                obj.userData.maxHeight = maxHeight;\\r\\n                obj.userData.scaleShadow = self._scaleShadow;\\r\\n            }\\r\\n        }\\r\\n        for (var i = 0; i < obj.children.length; i++) {\\r\\n            updateUvMesh(obj.children[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateShadowUv() {\\r\\n\\r\\n        meshShad.scale.x = (self.boundingBoxUv.max.y || 1) * self._scaleShadow;\\r\\n        meshShad.position.y = (meshShad.scale.x / 2) + self.boundingBoxUv.min.y;\\r\\n\\r\\n        for (var i = 0; i < self.arrShadowMesh.length; i++) {\\r\\n\\r\\n            if (!self._isDinamFotoRect) {\\r\\n                box.setFromObject(self.arrShadowMesh[i]);\\r\\n                if (!isColRect(box.min.x, box.min.z, box.max.x - box.min.x, box.max.z - box.min.z, self.fotoPosition.x, self.fotoPosition.y, self.fotoWH, self.fotoWH)) {\\r\\n                    continue;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            updateUvMesh(self.arrShadowMesh[i]);\\r\\n\\r\\n        }\\r\\n    }\\r\\n    this.updateShadowUv = updateShadowUv;\\r\\n\\r\\n    this.updateShadowTexture = function() {\\r\\n        this.canvasGG.update();\\r\\n        this.textureShadow.needsUpdate = true;\\r\\n    };\\r\\n\\r\\n    this.setShadowColor = function(r, g, b) {\\r\\n        canvasGG.r = r;\\r\\n        canvasGG.g = g;\\r\\n        canvasGG.b = b;\\r\\n        self.updateShadowTexture();\\r\\n    };\\r\\n\\r\\n    this.getConfig = function() {\\r\\n        var o = {};\\r\\n        o.imgWH = self.imgWH;\\r\\n        o.fotoPosition = {\\r\\n            x: self._fotoPosition.x,\\r\\n            y: self._fotoPosition.y\\r\\n        };\\r\\n        o.fotoWH = self.fotoWH;\\r\\n        o.maxHeight = self.maxHeight;\\r\\n        o.isDinamFotoRect = self.isDinamFotoRect;\\r\\n        o.arrDataSempl = self.arrDataSempl;\\r\\n        o.opacityMat = self.opacityMat;\\r\\n        o.dunamic = self.dunamic;\\r\\n        o.canvasGG = {\\r\\n            arrColorStopTranspanent: self.canvasGG.arrColorStopTranspanent,\\r\\n            arrProcent: self.canvasGG.arrProcent,\\r\\n        };\\r\\n        return o;\\r\\n    };\\r\\n\\r\\n    this.setConfig = function(o) {\\r\\n        self.canvasGG.arrColorStopTranspanent = o.canvasGG.arrColorStopTranspanent;\\r\\n        self.canvasGG.arrProcent = o.canvasGG.arrProcent;\\r\\n        self.fotoPosition.x = o.fotoPosition.x;\\r\\n        self.fotoPosition.y = o.fotoPosition.y;\\r\\n        self.fotoWH = o.fotoWH;\\r\\n        self.isDinamFotoRect = o.isDinamFotoRect;\\r\\n        self.arrDataSempl = o.arrDataSempl;\\r\\n        self.opacityMat = o.opacityMat;\\r\\n        self.imgWH = o.imgWH;\\r\\n        self.dunamic = o.dunamic;\\r\\n        self.updateShadowTexture();\\r\\n        self.maxHeight = o.maxHeight;\\r\\n\\r\\n    };\\r\\n\\r\\n    var sss = {\\r\\n        \"imgWH\": 1024,\\r\\n        \"fotoPosition\": {\\r\\n            \"x\": 0,\\r\\n            \"y\": 0\\r\\n        },\\r\\n        \"fotoWH\": 150,\\r\\n        \"maxHeight\": 300,\\r\\n        \"isDinamFotoRect\": false,\\r\\n        \"arrDataSempl\": [{\\r\\n            \"min\": 0,\\r\\n            \"max\": 6,\\r\\n            \"blur\": 0.8,\\r\\n            \"alpha\": 0.25\\r\\n        }, {\\r\\n            \"min\": 4,\\r\\n            \"max\": 15,\\r\\n            \"blur\": 3,\\r\\n            \"alpha\": 0.64\\r\\n        }, {\\r\\n            \"min\": 10,\\r\\n            \"max\": 23,\\r\\n            \"blur\": 4,\\r\\n            \"alpha\": 0.5\\r\\n        }, {\\r\\n            \"min\": 15,\\r\\n            \"max\": 50,\\r\\n            \"blur\": 15,\\r\\n            \"alpha\": 1\\r\\n        }, {\\r\\n            \"min\": 20,\\r\\n            \"max\": 198.09,\\r\\n            \"blur\": 15,\\r\\n            \"alpha\": 0.7\\r\\n        }, {\\r\\n            \"min\": 0,\\r\\n            \"max\": 2,\\r\\n            \"blur\": 1.02,\\r\\n            \"alpha\": 1\\r\\n        }],\\r\\n        \"opacityMat\": 1,\\r\\n        \"dunamic\": true,\\r\\n        \"canvasGG\": {\\r\\n            \"arrColorStopTranspanent\": [0, 1, 0.25],\\r\\n            \"arrProcent\": [0.4, 1, 0.96]\\r\\n        }\\r\\n    };\\r\\n    this.sss = sss;\\r\\n    this.setConfig(sss);\\r\\n\\r\\n    function bridge(obj, obj1) { // установка связи\\r\\n        obj.userData.targetObject = obj1;\\r\\n        for (var i = 0; i < obj.children.length; i++) {\\r\\n            if (!obj1.children[i]) throw new Error(\\'обекты не одинаковы\\');\\r\\n            bridge(obj.children[i], obj1.children[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function replaceMaterialMesh(obj) { // замена материалов \\r\\n        var arr = [];\\r\\n        findRecMesh(obj, arr);\\r\\n        for (var i = 0; i < arr.length; i++) {\\r\\n            arr[i].material = self._shadowMaterial;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isEqualsTransform(obj, obj1) { // одинакова ли трансформация обектов\\r\\n        var isEqualsPos = false;\\r\\n        // if (self._scaleShadow !== 1) {\\r\\n        //     isEqualsPos = \\r\\n        //         (Math.abs((obj.position.x * self._scaleShadow) - obj1.position.x) < 1) &&\\r\\n        //         (Math.abs((obj.position.y * self._scaleShadow) - obj1.position.y) < 1) &&\\r\\n        //         (Math.abs((obj.position.z * self._scaleShadow) - obj1.position.z) < 1);\\r\\n\\r\\n        // } else {\\r\\n        isEqualsPos = obj.position.equals(obj1.position);\\r\\n        // }\\r\\n\\r\\n        if (isEqualsPos &&\\r\\n            obj.quaternion.equals(obj1.quaternion) &&\\r\\n            (obj.scale.equals(obj1.scale)\\r\\n                // obj.scale.x === obj1.scale.x &&\\r\\n                // obj.scale.z === obj1.scale.z\\r\\n            ) &&\\r\\n            obj.visible === obj1.visible) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function applyTransforn(obj, obj1) { // скопировать трансф обекта\\r\\n        obj.position.copy(obj1.position);\\r\\n        obj.quaternion.copy(obj1.quaternion);\\r\\n        obj.scale.copy(obj1.scale);\\r\\n        obj.visible = obj1.visible;\\r\\n\\r\\n        // if (self._scaleShadow !== 1) {\\r\\n        //     obj.position.x = obj1.position.x / self._scaleShadow;\\r\\n        //     obj.position.y = obj1.position.y / self._scaleShadow;\\r\\n        //     obj.position.z = obj1.position.z / self._scaleShadow;\\r\\n        // }\\r\\n\\r\\n        // obj.scale.set(1, 1, 1);// ignore scale object\\r\\n    }\\r\\n\\r\\n\\r\\n    // проверка на пересечение прямоугольников\\r\\n    function isColRect(x1, y1, w1, h1, x2, y2, w2, h2) {\\r\\n        return x1 < (x2 + w2) && y1 < (y2 + h2) && (x1 + w1) > x2 && (y1 + h1) > y2;\\r\\n    }\\r\\n\\r\\n    function getProcent(val, min, max, okrug) {\\r\\n        min = min != undefined ? min : 0;\\r\\n        max = max != undefined ? max : 100;\\r\\n        okrug = okrug || 100;\\r\\n        if (isNaN(parseFloat(val))) val = min;\\r\\n        if (val < min) val = min;\\r\\n        if (val > max) val = max;\\r\\n        val = Math.round(val * okrug) / okrug;\\r\\n        return (min < 0) ? (Math.abs(min) + val) * 100 / ((Math.abs(min) + Math.abs(max)) || 1) :\\r\\n            (Math.abs(min) - val) * 100 / ((Math.abs(min) - Math.abs(max)) || 1);\\r\\n    }\\r\\n\\r\\n    function roundNum(num, siz) {\\r\\n        siz = siz != undefined ? siz : 10000;\\r\\n        return Math.round((num * siz)) / siz;\\r\\n    }\\r\\n\\r\\n    this.getBase64 = function() {\\r\\n        self.render();\\r\\n        return imageBlur.canvas.toDataURL();\\r\\n    };\\r\\n\\r\\n    this.debug = false;\\r\\n}\\r\\n\\r\\nObject.defineProperties(MShadowMeshContainer.prototype, {\\r\\n\\r\\n    scaleShadow: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this._scaleShadow = value;\\r\\n            // this.content3d.scale.x = this.content3d.scale.z = value;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._scaleShadow;\\r\\n        }\\r\\n    },\\r\\n\\r\\n    debug: {\\r\\n        set: function(value) {\\r\\n            this.helpers.visible = value;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this.helpers.visible;\\r\\n        }\\r\\n    },\\r\\n    offsetY: {\\r\\n        set: function(value) {\\r\\n            this._offsetY = value;\\r\\n            this.dirty = true;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._offsetY;\\r\\n        }\\r\\n    },\\r\\n\\r\\n    maxHeight: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this.boundingBoxUv.max.y = value;\\r\\n            this.updateShadowUv();\\r\\n        },\\r\\n        get: function() {\\r\\n            return this.boundingBoxUv.max.y;\\r\\n        }\\r\\n    },\\r\\n\\r\\n    dunamic: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this._dunamic = value;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._dunamic;\\r\\n        }\\r\\n    },\\r\\n    fotoPosition: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this._fotoPosition = value;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._fotoPosition;\\r\\n        }\\r\\n    },\\r\\n    fotoWH: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this._fotoWH = value;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._fotoWH;\\r\\n        }\\r\\n    },\\r\\n    imgWH: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this._imgWH = value;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._imgWH;\\r\\n        }\\r\\n    },\\r\\n    imgBlur: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this._imgBlur = value;\\r\\n        },\\r\\n        get: function() {\\r\\n            this.dirty = true;\\r\\n            return this._imgBlur;\\r\\n        }\\r\\n    },\\r\\n    imgAlpha: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this._imgAlpha = value;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._imgAlpha;\\r\\n        }\\r\\n    },\\r\\n\\r\\n    isDinamFotoRect: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this._isDinamFotoRect = value;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._isDinamFotoRect;\\r\\n        }\\r\\n    },\\r\\n    opacityMat: {\\r\\n        set: function(value) {\\r\\n            this.dirty = true;\\r\\n            this._opacityMat = value;\\r\\n            this.matPlan.opacity = this._opacityMat;\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._opacityMat;\\r\\n        }\\r\\n    },\\r\\n\\r\\n    shadowMaterial: {\\r\\n        set: function(value) {\\r\\n            if (value !== this._shadowMaterial) {\\r\\n                this._shadowMaterial = value;\\r\\n                for (var i = 0; i < this.arrShadowMesh.length; i++) {\\r\\n                    if (this.arrShadowMesh[i] instanceof THREE.ShadowMesh) {\\r\\n                        this.arrShadowMesh[i].material = this._shadowMaterial;\\r\\n                    } else {\\r\\n                        for (var j = 0; j < this.arrShadowMesh[i].children.length; j++) {\\r\\n                            if (this.arrShadowMesh[i].children[j] instanceof THREE.ShadowMesh) {\\r\\n                                this.arrShadowMesh[i].children[j].material = this._shadowMaterial;\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._shadowMaterial;\\r\\n        }\\r\\n    },\\r\\n\\r\\n    lightPosition4D: {\\r\\n        set: function(value) {\\r\\n            this._lightPosition4D.set(value.x, value.y, value.z, 0.001);\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._lightPosition4D;\\r\\n        }\\r\\n    },\\r\\n\\r\\n});\\r\\n\\r\\n\\r\\nfunction DataSempl(min, max, blur, alpha) {\\r\\n    this.min = min || 0;\\r\\n    this.max = max || 1;\\r\\n    this.blur = blur || 0;\\r\\n    this.alpha = alpha || 1;\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nfunction ImageBlur() {\\r\\n    var self = this;\\r\\n\\r\\n    var canvas = document.createElement(\\'canvas\\');\\r\\n    this.canvas = canvas;\\r\\n    canvas.width = 256;\\r\\n    canvas.height = 256;\\r\\n    var context = canvas.getContext(\"2d\");\\r\\n    var img = new Image();\\r\\n    this.b64 = null;\\r\\n    this._blur = 0;\\r\\n    this._blur1 = 1;\\r\\n    this._alpha = 1;\\r\\n    this.image = new Image();\\r\\n\\r\\n    this.setBase64 = function(_b64, fun) {\\r\\n        this.b64 = _b64;\\r\\n        img = new Image();\\r\\n        img.onload = function() {\\r\\n            canvas.clearRect(0, 0, canvas.width, canvas.height);\\r\\n            canvas.width = img.width;\\r\\n            canvas.height = img.height;\\r\\n            self.update();\\r\\n            if (fun) fun(canvas.toDataURL());\\r\\n        };\\r\\n        img.src = _b64;\\r\\n    };\\r\\n\\r\\n    this.setCanvas = function(c) {\\r\\n        img = c;\\r\\n        canvas.width = c.width;\\r\\n        canvas.height = c.height;\\r\\n        // self.update();\\r\\n    };\\r\\n\\r\\n    this.update = function() {\\r\\n        // context.clearRect(0, 0, canvas.width, canvas.height);\\r\\n        // context.filter = \\'blur(\\' + self._blur1 + \\'px)\\';\\r\\n        // context.globalAlpha = 0.1;\\r\\n        // context.drawImage(img, 0, 0);\\r\\n        context.filter = \\'blur(\\' + self._blur + \\'px)\\';\\r\\n        context.globalAlpha = self._alpha;\\r\\n        context.drawImage(img, 0, 0);\\r\\n    };\\r\\n}\\r\\nObject.defineProperties(ImageBlur.prototype, {\\r\\n    blur: {\\r\\n        set: function(value) {\\r\\n            this._blur = value;\\r\\n            // this.update();\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._blur;\\r\\n        }\\r\\n    },\\r\\n    alpha: {\\r\\n        set: function(value) {\\r\\n            this._alpha = value;\\r\\n            // this.update();\\r\\n        },\\r\\n        get: function() {\\r\\n            return this._alpha;\\r\\n        }\\r\\n    },\\r\\n\\r\\n});\\r\\n\\r\\nfunction CanvasGG() {\\r\\n    var self = this;\\r\\n\\r\\n    var canvas = document.createElement(\\'canvas\\');\\r\\n    // document.body.appendChild(canvas);\\r\\n    // canvas.style.position = \\'fixed\\';\\r\\n    canvas.width = canvas.height = 256;\\r\\n    this.canvas = canvas;\\r\\n    var context = canvas.getContext(\"2d\");\\r\\n    this._blur = 0;\\r\\n    this._alpha = 1;\\r\\n\\r\\n    this.arrColorStopTranspanent = [0, 1]; //CSS Colors transpanent\\r\\n    this.arrProcent = [0, 1]; //0 ... 1\\r\\n\\r\\n    this.position = new THREE.Vector2(); //0 ... 1\\r\\n    this.position1 = new THREE.Vector2(1, 0); //0 ... 1\\r\\n\\r\\n    this.r = 0;\\r\\n    this.g = 0;\\r\\n    this.b = 0;\\r\\n\\r\\n    this.update = function() {\\r\\n        var w = canvas.width;\\r\\n        var h = canvas.height;\\r\\n\\r\\n        context.clearRect(0, 0, w, h);\\r\\n\\r\\n        context.rect(0, 0, w, h);\\r\\n        context.filter = \\'blur(\\' + self._blur + \\'px)\\';\\r\\n        context.globalAlpha = self._alpha;\\r\\n\\r\\n        var px = self.position.x * w;\\r\\n        var py = self.position.y * h;\\r\\n        var px1 = self.position1.x * w;\\r\\n        var py1 = self.position1.y * h;\\r\\n\\r\\n        var gradient = context.createLinearGradient(px, py, px1, py1);\\r\\n\\r\\n        for (var i = 0; i < self.arrColorStopTranspanent.length; i++) {\\r\\n            gradient.addColorStop(self.arrProcent[i], \\'rgba(\\' + self.r + \\',\\' + self.g + \\',\\' + self.b + \\',\\' + self.arrColorStopTranspanent[i] + \\')\\');\\r\\n        }\\r\\n\\r\\n        context.fillStyle = gradient;\\r\\n        context.fill();\\r\\n\\r\\n    };\\r\\n    this.update();\\r\\n}\\r\\nObject.defineProperties(CanvasGG.prototype, {\\r\\n    // blur: {\\r\\n    //     set: function(value) {\\r\\n    //         this._blur = value;\\r\\n    //         this.update();\\r\\n    //     },\\r\\n    //     get: function() {\\r\\n    //         return this._blur;\\r\\n    //     }\\r\\n    // },\\r\\n    // alpha: {\\r\\n    //     set: function(value) {\\r\\n    //         this._alpha = value;\\r\\n    //         this.update();\\r\\n    //     },\\r\\n    //     get: function() {\\r\\n    //         return this._alpha;\\r\\n    //     }\\r\\n    // },\\r\\n\\r\\n});\\n// CONCATENATED MODULE: ./src/libMy/visi3D/MSmc.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MSmc; });\\n\\r\\n\\r\\n\\r\\nfunction MSmc (_parent) {\\r\\n\\tthis.parent = _parent;\\r\\n\\tvar self = this;\\r\\n\\tthis._active = false;\\r\\n\\tthis._visible = true;\\r\\n\\r\\n\\tthis.WH = 512;\\r\\n\\r\\n\\tthis._wn = this.WH;\\r\\n\\tthis._obj3d = undefined;\\r\\n\\r\\n\\tthis.smc = undefined;\\r\\n\\r\\n\\r\\n\\tthis.init = function () {\\r\\n\\t\\tif (this.smc != undefined) return;\\r\\n\\t\\tthis.smc = new MShadowMeshContainer();\\r\\n\\t\\tthis.smc.fotoPosition.set(-this._wn / 2, -this._wn / 2);\\r\\n\\t\\tthis.smc.fotoWH = this._wn;\\r\\n\\t\\tthis.smc.content3d.rotation.x = -Math.PI / 2;\\r\\n\\t\\tthis.smc.content3d.position.y = -1;\\r\\n\\t\\tthis.smc.content3d.visible = this._visible;\\r\\n\\t\\tthis.dergObj();\\r\\n\\t};\\r\\n\\tthis.dergActiv = function () {\\r\\n\\r\\n\\t\\tif (this._active == true) {\\r\\n\\t\\t\\tif (this.smc.content3d.parent == null) this.parent.parent.groupObject.add(this.smc.content3d);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (this.smc.content3d.parent != null) this.parent.parent.groupObject.remove(this.smc.content3d);\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.render = function () {\\r\\n\\r\\n\\t\\tif (this.smc == undefined) return;\\r\\n\\t\\tif (this.smc.content3d.parent != null) {\\r\\n\\t\\t\\tthis.smc.upDate();\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.dergObj = function () {\\r\\n\\t\\tif (this.smc == undefined)\\treturn;\\r\\n\\t\\tif (this._obj3d != undefined) {\\r\\n\\t\\t\\tif (this.smc.arrObj[0] == this._obj3d) {\\r\\n\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tthis.smc.clear();\\r\\n\\t\\t\\t\\tthis.smc.addObj(this._obj3d);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.smc.clear();\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\r\\n}\\r\\nMSmc.prototype = {\\r\\n\\tset active (v) {\\r\\n\\t\\tif (this._active === v) return;\\r\\n\\t\\tthis._active = v;\\r\\n\\t\\tthis.init();\\r\\n\\t\\tthis.dergActiv();\\r\\n\\t},\\r\\n\\tget active () {\\r\\n\\t\\treturn this._active;\\r\\n\\t},\\r\\n\\tset visible (v) {\\r\\n\\t\\tif (this._visible === v) return;\\r\\n\\t\\tthis._visible = v;\\r\\n\\t\\tif (this.smc == undefined) return;\\r\\n\\t\\tthis.smc.content3d.visible = v;\\r\\n\\r\\n\\t},\\r\\n\\tget visible () {\\r\\n\\t\\treturn this._visible;\\r\\n\\t},\\r\\n\\tset obj3d (v) {\\r\\n\\t\\tif (this._obj3d === v) return;\\r\\n\\t\\tthis._obj3d = v;\\r\\n\\t\\tthis.dergObj();\\r\\n\\r\\n\\t},\\r\\n\\tget obj3d () {\\r\\n\\t\\treturn this._obj3d;\\r\\n\\t},\\r\\n\\tset wh (v) {\\r\\n\\t\\tif (this._wh === v) return;\\r\\n\\t\\tthis._wh = v;\\r\\n\\t\\tif (this.smc == undefined) return;\\r\\n\\r\\n\\t\\tthis.smc.fotoPosition.set(-this._wn / 2, -this._wn / 2);\\r\\n\\t\\tthis.smc.fotoWH = this._wn;\\r\\n\\t},\\r\\n\\tget wh () {\\r\\n\\t\\treturn this._wh;\\r\\n\\t}\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./src/libMy/visi3D/MSmc.js_+_2_modules?')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"\\n// EXTERNAL MODULE: ./src/libMy/visi3D/MSky.js\\nvar MSky = __webpack_require__(1);\\n\\n// EXTERNAL MODULE: ./src/libMy/visi3D/MSmc.js + 2 modules\\nvar MSmc = __webpack_require__(3);\\n\\n// CONCATENATED MODULE: ./src/libMy/visi3D/MFocus.js\\nfunction MFocus (visi3D) {\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tthis.visi3D = visi3D;\\r\\n\\r\\n\\tthis.box3 = new THREE.Box3();\\t// 3d bound\\r\\n\\tthis.rectScreen = new Rectangle();\\r\\n\\r\\n\\tthis.world = new Rectangle(0, 0, 100, 100); //\\r\\n\\r\\n\\tthis.targetObject = null; // если нужно по обекту подстраиватся THREE.Object3D || null тогда по arrPoint\\r\\n\\tthis.arrPoint = []; // точки 3d для расчета\\r\\n\\r\\n\\tthis.isMoveCam = false;\\r\\n\\tthis.isFromGeometry = false;// подстраивать по геометрии или по bounds\\r\\n\\r\\n\\tthis._offset = 0; // отступ границ\\r\\n\\tthis._active = true;\\r\\n\\tthis._debug = false;\\r\\n\\r\\n\\r\\n\\tvar offsetVector = new THREE.Vector2();\\r\\n\\tvar vec = new THREE.Vector2();\\r\\n\\tvar center3 = new THREE.Vector3();\\r\\n\\r\\n\\tthis.upDate = function () {\\r\\n\\t\\tif (!self.active) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tthis.updateBound3d();\\r\\n\\t\\tif (self.box3.isEmpty()) return;\\r\\n\\t\\t// console.time('zumeVisi3D');\\r\\n\\t\\tthis.visi3D.xVerh = center3.x;\\r\\n\\t\\tthis.visi3D.zVerh = center3.z;\\r\\n\\t\\tthis.visi3D.yVerh = -center3.y;\\r\\n\\t\\tself.zumeVisi3D();\\r\\n\\r\\n\\t\\tif (self.isMoveCam) {\\r\\n\\t\\t\\tdoZoom();\\r\\n\\t\\t\\tvar maxCountStep = 10;\\r\\n\\t\\t\\tvar countStep = 0;\\r\\n\\t\\t\\twhile ((offsetVector.length() > 2) && (++countStep < maxCountStep)) {\\r\\n\\t\\t\\t\\tthis.visi3D.position3d.moveCamXY(offsetVector);\\r\\n\\t\\t\\t\\tdoZoom();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t// console.timeEnd('zumeVisi3D');\\r\\n\\t\\tif (self.debugFocus) self.debugFocus.upDate();\\r\\n\\t};\\r\\n\\tfunction doZoom () {\\r\\n\\t\\tself.zumeVisi3D();\\r\\n\\t\\toffsetVector.set(self.world.x + self.world.width / 2, self.world.y + self.world.height / 2);\\r\\n\\t\\tvec.set(self.rectScreen.x + self.rectScreen.width / 2, self.rectScreen.y + self.rectScreen.height / 2);\\r\\n\\t\\toffsetVector.sub(vec).divideScalar(2);\\r\\n\\t}\\r\\n\\r\\n\\tthis.zumeVisi3D = function () {\\r\\n\\t\\tvar eps = 0.01;\\r\\n\\t\\tvar low = 0;\\r\\n\\t\\tvar high = 60000;\\r\\n\\r\\n\\t\\tvar mid;\\r\\n\\t\\tvar val;\\r\\n\\r\\n\\t\\tvar maxCountStep = 20;\\r\\n\\t\\tvar countStep = 0;\\r\\n\\r\\n\\t\\twhile (low < high) { // ищем бинарным поиском\\r\\n\\r\\n\\t\\t\\tif (++countStep > maxCountStep) break;\\r\\n\\r\\n\\t\\t\\tmid = (low + high) / 2;\\r\\n\\t\\t\\tval = mid;\\r\\n\\r\\n\\t\\t\\tself.visi3D.zume = val;\\r\\n\\r\\n\\t\\t\\tif (Math.abs(low - mid) < eps || Math.abs(high - mid) < eps || mid < eps) {\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tself.updateRectScreen();\\r\\n\\t\\t\\t\\tif (self.isZoomIn()) {\\r\\n\\t\\t\\t\\t\\thigh = mid;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tlow = mid + 1;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\t// пересчет 3д бокса\\r\\n\\tthis.updateBound3d = function () {\\r\\n\\t\\tself.box3.makeEmpty();\\r\\n\\t\\tif (self.targetObject) {\\r\\n\\t\\t\\t// console.time('bound')\\r\\n\\t\\t\\tself.box3.copy(self.getCompoundBoundingBox(self.targetObject));\\r\\n\\t\\t\\t// console.timeEnd('bound')\\r\\n\\t\\t\\t// console.time('from')\\r\\n\\t\\t\\t// self.box3.setFromObject(self.targetObject);\\r\\n\\t\\t\\t// console.timeEnd('from')\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tfor (var i = 0; i < self.arrPoint.length; i++) {\\r\\n\\t\\t\\t\\tself.box3.expandByPoint(self.arrPoint[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tself.box3.getCenter(center3);\\r\\n\\t};\\r\\n\\r\\n\\tthis.updateRectScreen = function () {\\r\\n\\r\\n\\t\\tthis.visi3D.camera.updateMatrixWorld();\\r\\n\\t\\tthis.visi3D.scene.updateMatrixWorld();\\r\\n\\r\\n\\t\\tif (self.targetObject && self.isFromGeometry) {\\r\\n\\t\\t\\tvar boxs = self.getBoxObject(self.targetObject);\\r\\n\\t\\t\\tself.box3.copy(boxs.box3);\\r\\n\\t\\t\\tself.box3.getCenter(center3);\\r\\n\\t\\t\\tself.setRectFromBox(self.rectScreen, boxs.box2);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tself.setRectFromBox(self.rectScreen, self.boxToScreen(self.box3));\\r\\n\\t\\t}\\r\\n\\t\\tself.updateWorldSize();\\r\\n\\t};\\r\\n\\r\\n\\tthis.setRectFromBox = function (r, b2) {\\r\\n\\t\\tr.x = b2.min.x;\\r\\n\\t\\tr.y = b2.min.y;\\r\\n\\t\\tr.width = (b2.max.x - b2.min.x);\\r\\n\\t\\tr.height = (b2.max.y - b2.min.y);\\r\\n\\t};\\r\\n\\r\\n\\tthis.getCompoundBoundingBox = (function () {\\r\\n\\t\\tvar box3 = new THREE.Box3();\\r\\n\\t\\tvar boundingBox = new THREE.Box3();\\r\\n\\t\\tfunction traverseBound (node) {\\r\\n\\t\\t\\tvar geometry = node.geometry;\\r\\n\\t\\t\\tif (geometry === undefined) return;\\r\\n\\t\\t\\tif (!geometry.boundingBox) geometry.computeBoundingBox();\\r\\n\\t\\t\\tboundingBox.copy(geometry.boundingBox);\\r\\n\\t\\t\\tboundingBox.applyMatrix4(node.matrixWorld);\\r\\n\\t\\t\\tbox3.union(boundingBox);\\r\\n\\t\\t}\\r\\n\\t\\treturn function (object) {\\r\\n\\t\\t\\tobject.updateMatrixWorld(true);\\r\\n\\t\\t\\tbox3.makeEmpty();\\r\\n\\t\\t\\tobject.traverseVisible(traverseBound);\\r\\n\\t\\t\\treturn box3;\\r\\n\\t\\t};\\r\\n\\t}());\\r\\n\\r\\n\\tthis.boxToScreen = (function () {\\r\\n\\t\\tvar b2 = new THREE.Box2();\\r\\n\\t\\tvar arrP = []; // крайние точки\\r\\n\\t\\tfor (var i = 0; i < 8; i++) {\\r\\n\\t\\t\\tarrP[i] = new THREE.Vector3();\\r\\n\\t\\t}\\r\\n\\t\\treturn function boxToScreen (b3) {\\r\\n\\t\\t\\tb2.makeEmpty();\\r\\n\\t\\t\\tarrP[0].set(b3.min.x, b3.min.y, b3.min.z);\\r\\n\\t\\t\\tarrP[1].set(b3.min.x, b3.max.y, b3.min.z);\\r\\n\\t\\t\\tarrP[2].set(b3.max.x, b3.min.y, b3.min.z);\\r\\n\\t\\t\\tarrP[3].set(b3.max.x, b3.max.y, b3.min.z);\\r\\n\\t\\t\\tarrP[4].set(b3.min.x, b3.min.y, b3.max.z);\\r\\n\\t\\t\\tarrP[5].set(b3.min.x, b3.max.y, b3.max.z);\\r\\n\\t\\t\\tarrP[6].set(b3.max.x, b3.min.y, b3.max.z);\\r\\n\\t\\t\\tarrP[7].set(b3.max.x, b3.max.y, b3.max.z);\\r\\n\\t\\t\\tfor (var i = 0; i < arrP.length; i++) {\\r\\n\\t\\t\\t\\tb2.expandByPoint(self.toScreenXY(arrP[i]));\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn b2;\\r\\n\\t\\t};\\r\\n\\t}());\\r\\n\\r\\n\\tthis.getBoxObject = (function () {\\r\\n\\t\\tvar box2 = new THREE.Box2();\\r\\n\\t\\tvar box3 = new THREE.Box3();\\r\\n\\t\\tvar res = {box2: box2, box3: box3};\\r\\n\\t\\tvar i, l;\\r\\n\\t\\tvar v1 = new THREE.Vector3();\\r\\n\\t\\tfunction traverseGeom (node) {\\r\\n\\t\\t\\tvar geometry = node.geometry;\\r\\n\\t\\t\\tif (geometry !== undefined) {\\r\\n\\t\\t\\t\\tif (geometry.isGeometry) {\\r\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\r\\n\\t\\t\\t\\t\\tfor (i = 0, l = vertices.length; i < l; i++) {\\r\\n\\t\\t\\t\\t\\t\\tv1.copy(vertices[ i ]).applyMatrix4(node.matrixWorld);\\r\\n\\t\\t\\t\\t\\t\\tbox3.expandByPoint(v1);\\r\\n\\t\\t\\t\\t\\t\\tbox2.expandByPoint(self.toScreenXY(v1));\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t} else if (geometry.isBufferGeometry) {\\r\\n\\t\\t\\t\\t\\tvar attribute = geometry.attributes.position;\\r\\n\\t\\t\\t\\t\\tif (attribute !== undefined) {\\r\\n\\t\\t\\t\\t\\t\\tfor (i = 0, l = attribute.count; i < l; i++) {\\r\\n\\t\\t\\t\\t\\t\\t\\tv1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\\r\\n\\t\\t\\t\\t\\t\\t\\tbox3.expandByPoint(v1);\\r\\n\\t\\t\\t\\t\\t\\t\\tbox2.expandByPoint(self.toScreenXY(v1));\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn function getBoxObject (object) {\\r\\n\\t\\t\\tobject.updateMatrixWorld(true);\\r\\n\\t\\t\\tbox2.makeEmpty();\\r\\n\\t\\t\\tbox3.makeEmpty();\\r\\n\\t\\t\\tobject.traverseVisible(traverseGeom);\\r\\n\\t\\t\\treturn res;\\r\\n\\t\\t};\\r\\n\\t}());\\r\\n\\r\\n\\tvar vectorScreen = new THREE.Vector2();\\r\\n\\tvar vector3 = new THREE.Vector3();\\r\\n\\tthis.toScreenXY = function (v3) { // 3d world vector to screen\\r\\n\\t\\tvector3.copy(v3);\\r\\n\\t\\tvector3.project(self.visi3D.camera);\\r\\n\\t\\tvectorScreen.x = Math.round((vector3.x + 1) * self.visi3D._width / 2);\\r\\n\\t\\tvectorScreen.y = Math.round((-vector3.y + 1) * self.visi3D._height / 2);\\r\\n\\t\\treturn vectorScreen;\\r\\n\\t};\\r\\n\\r\\n\\tthis.updateWorldSize = function () {\\r\\n\\t\\tself.world.x = self.offset;\\r\\n\\t\\tself.world.y = self.offset;\\r\\n\\t\\tself.world.width = this.visi3D._width - self.offset * 2;\\r\\n\\t\\tself.world.height = this.visi3D._height - self.offset * 2;\\r\\n\\t};\\r\\n\\r\\n\\tthis.isZoomIn = function () {\\r\\n\\t\\treturn (self.rectScreen.x > self.world.x && self.rectScreen.x + self.rectScreen.width < self.world.x + self.world.width &&\\r\\n\\t\\t\\tself.rectScreen.y > self.world.y && self.rectScreen.y + self.rectScreen.height < self.world.y + self.world.height);\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\r\\nMFocus.prototype = {\\r\\n\\tset offset (v) {\\r\\n\\t\\tthis._offset = v || 0;\\r\\n\\t},\\r\\n\\tget offset () {\\r\\n\\t\\treturn this._offset;\\r\\n\\t},\\r\\n\\r\\n\\tset debug (v) {\\r\\n\\t\\tthis._debug = v;\\r\\n\\t\\tif (v && !this.debugFocus) {\\r\\n\\t\\t\\tthis.debugFocus = new MFocusDebug(this);\\r\\n\\t\\t}\\r\\n\\t\\tif (this.debugFocus) this.debugFocus.active = v;\\r\\n\\t},\\r\\n\\tget debug () {\\r\\n\\t\\treturn this._debug;\\r\\n\\t},\\r\\n\\r\\n\\tset active (v) {\\r\\n\\t\\tthis._active = v;\\r\\n\\t\\tif (!v) this.debug = false;\\r\\n\\t},\\r\\n\\tget active () {\\r\\n\\t\\treturn this._active;\\r\\n\\t}\\r\\n};\\r\\n\\r\\nfunction MFocusDebug (mFocus) {\\r\\n\\tvar self = this;\\r\\n\\tthis.mFocus = mFocus;\\r\\n\\tvar content3d = visi3D.scene;\\r\\n\\tvar content2d = main.stage;\\r\\n\\r\\n\\tvar boxHelper = new BoxHelper(1, materialAlphaRed);\\r\\n\\tcontent3d.add(boxHelper);\\r\\n\\r\\n\\tvar graphics = new PIXI.Graphics();\\r\\n\\tgraphics.hitArea = new PIXI.Rectangle(0, 0, 0, 0);\\r\\n\\tcontent2d.addChild(graphics);\\r\\n\\tself.active = false;\\r\\n\\tboxHelper.visible = graphics.visible = self.active;\\r\\n\\tthis.upDate = function () {\\r\\n\\t\\tboxHelper.visible = graphics.visible = self.active;\\r\\n\\t\\tif (!self.active) return;\\r\\n\\t\\tgraphics.clear();\\r\\n\\t\\tgraphics.position.set(visi3D._x, visi3D._y);\\r\\n\\t\\tgraphics.lineStyle(1, 0, 1);\\r\\n\\t\\tgraphics.drawRect(mFocus.world.x, mFocus.world.y, mFocus.world.width, mFocus.world.height);\\r\\n\\t\\tgraphics.lineStyle(1, 0xff0000, 1);\\r\\n\\t\\tgraphics.drawRect(mFocus.rectScreen.x, mFocus.rectScreen.y, mFocus.rectScreen.width, mFocus.rectScreen.height);\\r\\n\\r\\n\\t\\tboxHelper.width = mFocus.box3.max.x - mFocus.box3.min.x;\\r\\n\\t\\tboxHelper.depth = mFocus.box3.max.y - mFocus.box3.min.y;\\r\\n\\t\\tboxHelper.height = mFocus.box3.max.z - mFocus.box3.min.z;\\r\\n\\t\\tmFocus.box3.getCenter(boxHelper.position);\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\n// CONCATENATED MODULE: ./src/libMy/visi3D/MUtility.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return MUtility; });\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nfunction MUtility (_parent) {\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tthis.parent = _parent;\\r\\n\\r\\n\\tthis._debug = false;\\r\\n\\r\\n\\tthis.debugInit = false;\\r\\n\\tthis.shadowHelper = undefined;\\r\\n\\tthis.spotLightHelper = undefined;\\r\\n\\tthis.gridHelper = undefined;\\r\\n\\r\\n\\tthis.FIXATION = false;\\r\\n\\tthis.ROTATION_X = 0;\\r\\n\\tthis.ROTATION_Z = 0;\\r\\n\\tthis.DISTANCE = this.parent.DISTANCE;\\r\\n\\tthis.CUB_HEIGHT = this.parent.CUB_HEIGHT;\\r\\n\\tthis.CUB_WIDTH = this.parent.CUB_WIDTH;\\r\\n\\tthis.SKY_X = 0;\\r\\n\\tthis.SKY_Y = 0;\\r\\n\\tthis.SKY_Z = 0;\\r\\n\\r\\n\\tthis._fixation = this.FIXATION;\\r\\n\\tthis._rotationX = this.ROTATION_X;\\r\\n\\tthis._rotationZ = this.ROTATION_Z;\\r\\n\\tthis._distance = this.DISTANCE;\\r\\n\\tthis._cubHeight = this.CUB_HEIGHT;\\r\\n\\tthis._cubWidth = this.CUB_WIDTH;\\r\\n\\r\\n\\t// задний фон\\r\\n\\tthis.sky = new MSky[\\\"a\\\" /* default */](this);\\r\\n\\tthis.smc = new MSmc[\\\"a\\\" /* default */](this);\\r\\n\\tthis.focus = new MFocus(this.parent);\\r\\n\\r\\n\\tthis.funDebug = function () {\\r\\n\\r\\n\\t\\tif (this.debugInit != true) {\\r\\n\\t\\t\\tthis.debugInit = true;\\r\\n\\t\\t\\tthis.plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(1000, 1000).rotateX(-Math.PI), new THREE.MeshLambertMaterial({color: new THREE.Color(0xacacac)}));\\r\\n\\t\\t\\tthis.plane.castShadow = this.plane.receiveShadow = true;\\r\\n\\r\\n\\t\\t\\tthis.gridHelper = new THREE.GridHelper(1000, 10);\\r\\n\\t\\t\\tthis.gridHelper.rotation.x = -Math.PI / 2;\\r\\n\\t\\t\\tthis.shadowHelper = new THREE.CameraHelper(this.parent.sunLight.shadow.camera);\\r\\n\\t\\t\\tif (this.parent.sunLight) this.spotLightHelper = new THREE.DirectionalLightHelper(this.parent.sunLight);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (this._debug == true) {\\r\\n\\r\\n\\t\\t\\tif (this.gridHelper.parent == null) this.parent.groupObject.add(this.gridHelper);\\r\\n\\t\\t\\tif (this.plane.parent == null) this.parent.groupObject.add(this.plane);\\r\\n\\t\\t\\tif (this.shadowHelper.parent == null) this.parent.scene.add(this.shadowHelper);\\r\\n\\r\\n\\r\\n\\t\\t\\tif (this.parent.sunLight) {\\r\\n\\t\\t\\t\\tif (this.parent.sunLight.parent != null) {\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tif (this.spotLightHelper.parent != null) this.parent.scene.remove(this.spotLightHelper);\\r\\n\\t\\t\\t\\t\\tif (this.shadowHelper.parent != null) this.parent.scene.remove(this.shadowHelper);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif (this.gridHelper.parent != null) this.parent.groupObject.remove(this.gridHelper);\\r\\n\\t\\t\\tif (this.plane.parent != null) this.parent.groupObject.remove(this.plane);\\r\\n\\t\\t\\tif (this.shadowHelper.parent != null) this.parent.scene.remove(this.shadowHelper);\\r\\n\\t\\t\\tif (this.parent.sunLight) {\\r\\n\\t\\t\\t\\tif (this.spotLightHelper.parent != null) this.parent.scene.remove(this.spotLightHelper);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.render = function () {\\r\\n\\t\\tif (this._debug == true) {\\r\\n\\t\\t\\tif (this.spotLightHelper != undefined) this.spotLightHelper.update();\\r\\n\\t\\t}\\r\\n\\t\\tthis.smc.render();\\r\\n\\t\\tthis.sky.render();\\r\\n\\t\\tthis.focus.upDate();\\r\\n\\t\\tthis.dragSunLight();\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tvar d = 0;\\r\\n\\tthis.dragSunLight = function () {\\r\\n\\t\\tif (this.parent.sunLight == undefined) return;\\r\\n\\t\\tif (this.parent.sunLight.parent == null) return;\\r\\n\\r\\n\\t\\tif (self._fixation === true) {\\r\\n\\t\\t\\td = this._distance + this._cubHeight * 2;\\r\\n\\t\\t\\tself.parent.sunLight.position.set(0, d, 0);// занулили\\r\\n\\t\\t\\tself.parent.sunLight.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), self._rotationX);\\r\\n\\t\\t\\tself.parent.sunLight.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), self._rotationZ - self.parent._rotationZ);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\td = this._distance + this._cubHeight;\\r\\n\\t\\t\\tthis.parent.sunLight.position.set(0, d, 0);// занулили\\r\\n\\t\\t\\tthis.parent.sunLight.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), this._rotationX);\\r\\n\\t\\t\\tthis.parent.sunLight.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), this._rotationZ);\\r\\n\\r\\n\\t\\t\\tif (this.parent.staticShadow) {\\r\\n\\t\\t\\t\\tmoveSunToCam();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tvar shadowPrintPos = new THREE.Vector3();\\r\\n\\tthis.distanceUpdateShadow = 500; // на каком растоянии будет постоянно обновляться тень\\r\\n\\tfunction moveSunToCam () {\\r\\n\\r\\n\\t\\tvar camPos = new THREE.Vector3(self.parent.xVerh, self.parent.yVerh, self.parent.zVerh);\\r\\n\\t\\tself.parent.sunLight.position.add(camPos);\\r\\n\\t\\tself.parent.sunLight.target.position.copy(camPos);\\r\\n\\r\\n\\t\\tif (shadowPrintPos.distanceTo(camPos) > self.distanceUpdateShadow) {\\r\\n\\t\\t\\tshadowPrintPos.copy(camPos);\\r\\n\\t\\t\\tself.parent.shadowNeedsUpdate = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tthis.dragSunLight2 = function () {\\r\\n\\t\\tif (this.parent.sunLight == undefined) return;\\r\\n\\t\\tif (this.parent.sunLight.parent == null) return;\\r\\n\\t\\tif (this._fixation === true) {\\r\\n\\t\\t} else {\\r\\n\\t\\t\\td = this._distance + this._cubHeight * 2;\\r\\n\\t\\t\\tthis.parent.sunLight.position.set(0, d, 0);// занулили\\r\\n\\t\\t\\tthis.parent.sunLight.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), this._rotationX);\\r\\n\\t\\t\\tthis.parent.sunLight.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), this._rotationZ);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.dragSunLight3 = function () {\\r\\n\\t\\tif (this.parent.sunLight) {\\r\\n\\t\\t\\tthis.parent.sunLight.shadow.camera.near\\t= 0 + this._cubHeight;// this._distance;\\r\\n\\t\\t\\tthis.parent.sunLight.shadow.camera.far = this._cubHeight * 2 + this._cubHeight; // +this._distance ;\\r\\n\\t\\t\\tthis.parent.sunLight.shadow.camera.updateProjectionMatrix();\\r\\n\\t\\t\\tif (this.shadowHelper) this.shadowHelper.update();\\r\\n\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.sunActiv=function(value){\\r\\n\\t\\tthis.parent.objShadow(this.parent.group, value);\\r\\n\\t\\tif (value == true) {\\r\\n\\t\\t\\tif (this.parent.sunLight.parent == undefined){\\r\\n\\t\\t\\t\\tthis.parent.scene.add(this.parent.sunLight);\\r\\n\\t\\t\\t\\tthis.parent.scene.add(self.parent.sunLight.target)\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (this.parent.sunLight.parent != undefined){\\r\\n\\t\\t\\t\\tthis.parent.scene.remove(this.parent.sunLight);\\r\\n\\t\\t\\t\\tthis.parent.scene.remove(self.parent.sunLight.target)\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tthis.funDebug();\\r\\n\\t}\\r\\n\\tthis.ambientActiv=function(value){\\r\\n\\t\\tif (value == true) {\\r\\n\\t\\t\\tif (this.parent.ambientLight.parent == undefined)this.parent.scene.add(this.parent.ambientLight);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (this.parent.ambientLight.parent != undefined)this.parent.scene.remove(this.parent.ambientLight);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nMUtility.prototype = {\\r\\n\\tset debug (v) {\\r\\n\\r\\n\\t\\tif (this._debug === v) return;\\r\\n\\t\\tthis._debug = v;\\r\\n\\t\\tthis.funDebug();\\r\\n\\t},\\r\\n\\tget debug () {\\r\\n\\t\\treturn this._debug;\\r\\n\\t},\\r\\n\\r\\n\\tset rotationX (v) {\\r\\n\\t\\tif (this._rotationX === v) return;\\r\\n\\t\\tthis._rotationX = v;\\r\\n\\t\\tif (this.spotLightHelper != undefined) {\\r\\n\\t\\t\\tthis.parent.sunLight.shadow.camera.updateProjectionMatrix();\\r\\n\\t\\t\\tthis.spotLightHelper.update();\\r\\n\\t\\t}\\r\\n\\t\\tthis.dragSunLight2();\\r\\n\\t},\\r\\n\\tget rotationX () {\\r\\n\\t\\treturn this._rotationX;\\r\\n\\t},\\r\\n\\r\\n\\tset rotationZ (v) {\\r\\n\\t\\tif (this._rotationZ === v) return;\\r\\n\\t\\tthis._rotationZ = v;\\r\\n\\t\\tthis.sky.shadRotZ = v;\\r\\n\\t\\tif (this.spotLightHelper != undefined) this.spotLightHelper.update();\\r\\n\\t\\tthis.dragSunLight2();\\r\\n\\t},\\r\\n\\tget rotationZ () {\\r\\n\\t\\treturn this._rotationZ;\\r\\n\\t},\\r\\n\\r\\n\\tset fixation (v) {\\r\\n\\t\\tif (this._fixation === v) return;\\r\\n\\t\\tthis._fixation = v;\\r\\n\\t\\tthis.dragSunLight2();\\r\\n\\t},\\r\\n\\tget fixation () {\\r\\n\\t\\treturn this._fixation;\\r\\n\\t},\\r\\n\\r\\n\\tset distance (v) {\\r\\n\\t\\tif (this._distance === v) return;\\r\\n\\t\\tthis._distance = v;\\r\\n\\t\\tthis.dragSunLight3();\\r\\n\\t\\tthis.dragSunLight2();\\r\\n\\t},\\r\\n\\tget distance () {\\r\\n\\t\\treturn this._distance;\\r\\n\\t},\\r\\n\\r\\n\\tset cubHeight (v) {\\r\\n\\t\\tif (this._cubHeight === v) return;\\r\\n\\t\\tthis._cubHeight = v;\\r\\n\\r\\n\\t\\tthis.dragSunLight3();\\r\\n\\t\\tthis.dragSunLight2();\\r\\n\\t},\\r\\n\\tget cubHeight () {\\r\\n\\t\\treturn this._cubHeight;\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\tset cubWidth (v) {\\r\\n\\t\\tif (this._cubWidth === v) return;\\r\\n\\t\\tthis._cubWidth = v;\\r\\n\\r\\n\\t\\tif (this.parent.sunLight) {\\r\\n\\t\\t\\tthis.parent.sunLight.shadow.camera.right = this._cubWidth;\\r\\n\\t\\t\\tthis.parent.sunLight.shadow.camera.left = -this._cubWidth;\\r\\n\\t\\t\\tthis.parent.sunLight.shadow.camera.top\\t= this._cubWidth;\\r\\n\\t\\t\\tthis.parent.sunLight.shadow.camera.bottom = -this._cubWidth;\\r\\n\\t\\t\\tthis.parent.sunLight.shadow.camera.updateProjectionMatrix();\\r\\n\\t\\t\\tif (this.shadowHelper) this.shadowHelper.update();\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget cubWidth () {\\r\\n\\t\\treturn this._cubWidth;\\r\\n\\t}\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./src/libMy/visi3D/MUtility.js_+_1_modules?\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return MEffectArray; });\\n\\r\\nfunction MEffectArray (_visi3D, _startArray) {\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tthis.visi3D = _visi3D;\\r\\n\\tthis._startArray = [];// _startArray;\\r\\n\\r\\n\\tthis._width = _visi3D._width;\\r\\n\\tthis._height = _visi3D._height;\\r\\n\\r\\n\\tthis.scene = this.visi3D.scene;\\r\\n\\tthis.camera = this.visi3D.camera;\\r\\n\\tthis.renderer = this.visi3D.renderer;\\r\\n\\r\\n\\tthis.composer = new THREE.EffectComposer(this.renderer);\\r\\n\\r\\n\\tthis.RENDER_PASS = false;\\r\\n\\r\\n\\tthis.OUTLINE_PASS = false;\\r\\n\\tthis.OUTLINE_COLOR = '#0000ff';\\r\\n\\tthis.OUTLINE_COLOR1 = '#ff0000';\\r\\n\\tthis.STRJSON = '{\\\"edgeGlow\\\":0,\\\"usePatternTexture\\\":false,\\\"edgeThickness\\\":1,\\\"edgeStrength\\\":3,\\\"downSampleRatio\\\":2,\\\"pulsePeriod\\\":0}';\\r\\n\\tthis.SAOJSON = '{\\\"saoBlur\\\":true,\\\"output\\\":0,\\\"saoBias\\\":0,\\\"saoBlurDepthCutoff\\\":0,\\\"saoBlurRadius\\\":8,\\\"saoBlurStdDev\\\":4,\\\"saoIntensity\\\":0.18,\\\"saoKernelRadius\\\":100,\\\"saoMinResolution\\\":0,\\\"saoScale\\\":11.58}';\\r\\n\\r\\n\\tthis.TAA_PASS = false;\\r\\n\\tthis.SAMPLE_LEVEL = 0;\\r\\n\\r\\n\\tthis.STEREO_PASS = false;\\r\\n\\r\\n\\tthis.SHADER_PASS = false;\\r\\n\\tthis.SAO_PASS = false;\\r\\n\\tthis.SSAO_PASS = false;\\r\\n\\r\\n\\r\\n\\tthis._renderPass = this.RENDER_PASS;\\r\\n\\tthis._outlinePass = this.OUTLINE_PASS;\\r\\n\\tthis._outlineColor = this.OUTLINE_COLOR;\\r\\n\\tthis._outlineColor1 = this.OUTLINE_COLOR1;\\r\\n\\tthis._strJSON = this.STRJSON;\\r\\n\\r\\n\\tthis._taaPass = this.TAA_PASS;\\r\\n\\tthis._sampleLevel = this.SAMPLE_LEVEL;\\r\\n\\r\\n\\r\\n\\tthis._stereoPass = this.STEREO_PASS;\\r\\n\\r\\n\\r\\n\\tthis._shaderPass = this.SHADER_PASS;\\r\\n\\tthis._saoPass = this.SAO_PASS;\\r\\n\\tthis._saoJSON = this.SAOJSON;\\r\\n\\r\\n\\tthis.jsonCheck = function (_text) {\\r\\n\\t  \\tif (_text == undefined) return false;\\r\\n\\t  \\tif (typeof _text !== 'string') return false;\\r\\n\\t\\tif (_text.indexOf('\\\":') == -1) return false;\\r\\n\\t\\tif (_text.indexOf('}') == -1) return false;\\r\\n\\t  \\tif (_text === 'null') return false;\\r\\n\\r\\n\\t  \\ttry {\\r\\n\\t   \\t\\tJSON.parse(_text);\\r\\n\\t  \\t} catch (e) {\\r\\n\\t   \\t\\treturn false;\\r\\n\\t \\t}\\r\\n\\t  \\treturn true;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.setObjInObj = function (_o, _str) {\\r\\n\\t\\tif (this.jsonCheck(_str) == false) return;\\r\\n\\t\\tvar _o1 = JSON.parse(_str);\\r\\n\\t\\tvar t;\\r\\n\\r\\n\\t\\tfor (var s1 in _o1) {\\r\\n\\t\\t\\tfor (var s in _o) {\\r\\n\\t\\t\\t\\tif (s == s1) {\\r\\n\\t\\t\\t\\t\\tt = typeof _o1[s];\\r\\n\\t\\t\\t\\t\\tif (t == 'object') {\\r\\n\\t\\t\\t\\t\\t\\tthis.setObjInObj(_o[s], _o1[s]);\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t_o[s] = _o1[s];\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.array = [];\\r\\n\\tthis.object = {};\\r\\n\\r\\n\\tthis.init = function () {\\r\\n\\r\\n\\t\\tif (this.array.length != 0) return;\\r\\n\\r\\n\\t\\tvar sah = 0;\\r\\n\\t\\t// RenderPass Нх нужно не знаю но нужно, наверно проверить FIXE  js/postprocessing/TAARenderPass.js\\r\\n\\t\\tthis.array[sah] = new EffectScene(new THREE.RenderPass(this.scene, this.camera));\\r\\n\\t\\tthis.array[sah].type = 'RenderPass';\\r\\n\\t\\t// this.composer.addPass(this.array[sah].effect);\\r\\n\\t\\tsah++;\\r\\n\\r\\n\\r\\n\\t\\tthis.array[sah] = new EffectScene(new THREE.OutlinePass(new THREE.Vector2(this._width, this._height), this.scene, this.camera));\\r\\n\\t\\tthis.array[sah].type = 'OutlinePass';\\r\\n\\r\\n\\r\\n\\t\\tthis.array[sah].effect.visibleEdgeColor = new THREE.Color(this._outlineColor);\\r\\n\\t\\tthis.array[sah].effect.hiddenEdgeColor = new THREE.Color(this._outlineColor1);\\r\\n\\r\\n\\r\\n\\t\\tsah++;\\r\\n\\r\\n\\r\\n\\t\\tthis.array[sah] = new EffectScene(new THREE.TAARenderPass(this.scene, this.camera));\\r\\n\\t\\tthis.array[sah].type = 'TAARenderPass';\\r\\n\\r\\n\\t\\t/* sah++;\\r\\n\\r\\n\\t\\t// Сглаживание\\r\\n\\t\\tthis.array[sah] = new EffectScene(new THREE.StereoEffect(THREE.FXAAShader));\\r\\n\\t\\tthis.array[sah].type = 'StereoEffect';\\r\\n\\r\\n\\r\\n\\t\\t*/\\r\\n\\r\\n\\r\\n\\t\\tsah++;\\r\\n\\r\\n\\t\\t// Сглаживание\\r\\n\\t\\tthis.array[sah] = new EffectScene(new THREE.ShaderPass(THREE.FXAAShader));\\r\\n\\t\\tthis.array[sah].type = 'ShaderPass';\\r\\n\\r\\n\\t\\t// this.composer.addPass(this.array[sah].effect);\\r\\n\\r\\n\\r\\n\\t\\tthis.array[sah].effect.uniforms['resolution'].value.set(1 / this._width, 1 / this._height);\\r\\n\\t\\tthis.array[sah].sizeWindow = function (_w, _h) {\\r\\n\\t\\t\\tthis.effect.uniforms['resolution'].value.set(1 / _w, 1 / _h);\\r\\n\\t\\t};\\r\\n\\r\\n\\r\\n\\t\\tsah++;\\r\\n\\t\\t// this.array[sah].effect.renderToScreen = false/*this._bSao ? false : true*/;\\r\\n\\t\\t// composer.addPass(effectFXAA);\\r\\n\\r\\n\\t\\t// SAO  тенюхи на кружочках\\r\\n\\t\\tvar prevFar = this.camera.far;\\r\\n\\t\\tvar prevNear = this.camera.near;\\r\\n\\t\\tthis.camera.far = 10;\\r\\n\\t\\tthis.camera.near = 3;\\r\\n\\t\\tthis.array[sah] = new EffectScene(new THREE.SAOPass(this.scene, this.camera, true, true));\\r\\n\\t\\t// this.array[sah].effect.renderToScreen = true;\\r\\n\\t\\tthis.array[sah].type = 'SAOPass';\\r\\n\\t\\tthis.camera.far = prevFar;\\r\\n\\t\\tthis.camera.near = prevNear;\\r\\n\\r\\n\\t\\t// var s = '{\\\"saoBlur\\\":true,\\\"output\\\":0,\\\"saoBias\\\":0,\\\"saoBlurDepthCutoff\\\":0,\\\"saoBlurRadius\\\":8,\\\"saoBlurStdDev\\\":4,\\\"saoIntensity\\\":0.18,\\\"saoKernelRadius\\\":100,\\\"saoMinResolution\\\":0,\\\"saoScale\\\":11.58}';\\r\\n\\r\\n\\r\\n\\t\\tsah++;/**/\\r\\n\\r\\n\\t\\t/* var prevFar = this.camera.far;\\r\\n\\t\\tvar prevNear = this.camera.near;\\r\\n\\t\\tthis.camera.far = 10;\\r\\n\\t\\tthis.camera.near = 3;\\r\\n\\t\\tthis.array[sah] = new EffectScene(new THREE.SAOPass(this.scene, this.camera, true, true));\\r\\n\\t\\t// this.array[sah].effect.renderToScreen = true;\\r\\n\\t\\tthis.array[sah].type = 'SSAOPass';\\r\\n\\t\\tthis.camera.far = prevFar;\\r\\n\\t\\tthis.camera.near = prevNear;\\r\\n\\r\\n\\r\\n\\t\\tsah++; */\\r\\n\\r\\n\\r\\n\\t\\tfor (var i = 0; i < this.array.length; i++) {\\r\\n\\t\\t\\tthis.object[this.array[i].type] = this.array[i];\\r\\n\\t\\t}\\r\\n\\t\\tvar rr;\\r\\n\\r\\n\\r\\n\\t\\t// this.dragOutline()\\r\\n\\t\\tthis.setObjInObj(this.object['SAOPass'].effect.params, this._saoJSON);\\r\\n\\t\\tthis.setObjInObj(this.object['OutlinePass'].effect, this._strJSON);\\r\\n\\t\\tthis.sizeWindow(this._width, this._height);\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tvar p = -1;\\r\\n\\tthis.setValue = function (_key, _key1, _param) {\\r\\n\\t\\tif (_key == 'outline') {\\r\\n\\t\\t\\tif (this.object['OutlinePass'].activ == true) this.object['OutlinePass'].effect.selectedObjects = _param;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.drawRender = function () {\\r\\n\\t\\tthis.clear();\\r\\n\\t\\tif (this._renderPass == true) {\\r\\n\\t\\t\\tthis.object['RenderPass'].activ = true;\\r\\n\\t\\t\\tthis.clear(true);\\r\\n\\t\\t\\tthis.object['RenderPass'].effect.renderToScreen = true;\\r\\n\\t\\t\\tthis.composer.addPass(this.object['RenderPass'].effect);\\r\\n\\t\\t}\\r\\n\\t\\tif (this._outlinePass == true) {\\r\\n\\t\\t\\tthis.object['OutlinePass'].activ = true;\\r\\n\\t\\t\\t// this.clear(true)\\r\\n\\t\\t\\t// this.object['OutlinePass'].effect.renderToScreen = true;\\r\\n\\t\\t\\tthis.composer.addPass(this.object['OutlinePass'].effect);\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tif (this._taaPass == true) {\\r\\n\\t\\t\\tthis.object['TAARenderPass'].activ = true;\\r\\n\\t\\t\\tthis.clear(true);\\r\\n\\t\\t\\tthis.object['TAARenderPass'].effect.renderToScreen = true;\\r\\n\\t\\t\\tthis.composer.addPass(this.object['TAARenderPass'].effect);\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tif (this._shaderPass == true) {\\r\\n\\t\\t\\tthis.object['ShaderPass'].activ = true;\\r\\n\\t\\t\\tthis.clear(true);\\r\\n\\t\\t\\tthis.object['ShaderPass'].effect.renderToScreen = true;\\r\\n\\t\\t\\tthis.composer.addPass(this.object['ShaderPass'].effect);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (this._saoPass == true) {\\r\\n\\t\\t\\tthis.object['SAOPass'].activ = true;\\r\\n\\t\\t\\tthis.clear(true);\\r\\n\\t\\t\\tthis.object['SAOPass'].effect.renderToScreen = true;\\r\\n\\t\\t\\tthis.composer.addPass(this.object['SAOPass'].effect);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (this._ssaoPass == true) {\\r\\n\\t\\t\\tthis.object['SSAOPass'].activ = true;\\r\\n\\t\\t\\tthis.clear(true);\\r\\n\\t\\t\\tthis.object['SSAOPass'].effect.renderToScreen = true;\\r\\n\\t\\t\\tthis.composer.addPass(this.object['SSAOPass'].effect);\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.redrag = function () {\\r\\n\\r\\n\\t\\tvar a = [];\\r\\n\\t\\tfor (var i = 1; i < self.array.length; i++) {\\r\\n\\t\\t\\tif (self.array[i].activ == true) {\\r\\n\\t\\t\\t\\ta.push(self.array[i].type);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tthis.startArray = a;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.setArrayMash = function (_tip, _array) {\\r\\n\\t\\t// if (this.array.length == 0) return;\\r\\n\\t\\t/* if (_tip == 'OutlinePass') {\\r\\n\\t\\t\\tthis.object[_tip].effect.selectedObjects = _array;\\r\\n\\t\\t} */\\r\\n\\t};\\r\\n\\r\\n\\tvar b = true;\\r\\n\\tthis.render = function () {\\r\\n\\t\\tb = false;\\r\\n\\t\\tif (this.array.length == 0) return;\\r\\n\\t\\tfor (var i = 0; i < this.array.length; i++) {\\r\\n\\t\\t\\tif (this.array[i]._activ != false) {\\r\\n\\t\\t\\t\\tthis.array[i].render();\\r\\n\\t\\t\\t\\tb = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (b == true) this.composer.render();\\r\\n\\r\\n\\t\\treturn b;\\r\\n\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.sizeWindow = function (_width, _height) {\\r\\n\\t\\tthis._width = _width;\\r\\n\\t\\tthis._height = _height;\\r\\n\\t\\tif (this.array.length == 0) return;\\r\\n\\t\\tthis.composer.setSize(this._width, this._height);\\r\\n\\t\\tfor (var i = 0; i < this.array.length; i++) {\\r\\n\\t\\t\\tif (this.array[i].sizeWindow) this.array[i].sizeWindow(_width, _height);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\tthis.clear = function (b) {\\r\\n\\t\\tif (b == undefined) this.composer.passes.length = 0;\\r\\n\\t\\tfor (var i = 0; i < this.array.length; i++) {\\r\\n\\t\\t\\tif (b == undefined) this.array[i].activ = false;\\r\\n\\t\\t\\tthis.array[i].effect.renderToScreen = false;\\r\\n\\t\\t\\tthis.array[i].effect.unbiased = false;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\nMEffectArray.prototype = {\\r\\n\\tset activ (v) {\\r\\n\\t\\tif (this._activ != v) {\\r\\n\\t\\t\\tthis._activ = v;\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget activ () {\\r\\n\\t\\treturn this._activ;\\r\\n\\t},\\r\\n\\tset startArray (v) {\\r\\n\\t\\tthis._startArray = v;\\r\\n\\t},\\r\\n\\tget startArray () {\\r\\n\\t\\treturn this._startArray;\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\tset renderPass (v) {\\r\\n\\t\\tif (this._renderPass != v) {\\r\\n\\t\\t\\tthis._renderPass = v;\\r\\n\\t\\t\\tthis.drawRender();\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget renderPass () {\\r\\n\\t\\treturn this._renderPass;\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\tset outlinePass (v) {\\r\\n\\t\\tif (this._outlinePass != v) {\\r\\n\\t\\t\\tthis._outlinePass = v;\\r\\n\\t\\t\\tthis.drawRender();\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget outlinePass () {\\r\\n\\t\\treturn this._outlinePass;\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\tset outlineColor (v) {\\r\\n\\t\\tif (this._outlineColor != v) {\\r\\n\\t\\t\\tthis._outlineColor = v;\\r\\n\\t\\t\\tthis.object['OutlinePass'].effect.visibleEdgeColor = new THREE.Color(this._outlineColor);\\r\\n\\t\\t\\ttrace(this._outlineColor, '   ', this.object['OutlinePass'].effect.visibleEdgeColor);\\r\\n\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget outlineColor () {\\r\\n\\t\\treturn this._outlineColor;\\r\\n\\t},\\r\\n\\r\\n\\tset outlineColor1 (v) {\\r\\n\\t\\tif (this._outlineColor1 != v) {\\r\\n\\t\\t\\tthis._outlineColor1 = v;\\r\\n\\t\\t\\tthis.object['OutlinePass'].effect.hiddenEdgeColor = new THREE.Color(this._outlineColor1);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget outlineColor1 () {\\r\\n\\t\\treturn this._outlineColor1;\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\tset strJSON (v) {\\r\\n\\t\\tif (this._strJSON != v) {\\r\\n\\t\\t\\tthis._strJSON = v;\\r\\n\\t\\t\\tthis.setObjInObj(this.object['OutlinePass'].effect, this._strJSON);\\r\\n\\t\\t\\t// this.dragOutline();\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget strJSON () {\\r\\n\\t\\treturn this._strJSON;\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\tset taaPass (v) {\\r\\n\\t\\tif (this._taaPass != v) {\\r\\n\\t\\t\\tthis._taaPass = v;\\r\\n\\t\\t\\tthis.drawRender();\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget taaPass () {\\r\\n\\t\\treturn this._taaPass;\\r\\n\\t},\\r\\n\\r\\n\\tset sampleLevel (v) {\\r\\n\\t\\tif (this._sampleLevel != v) {\\r\\n\\t\\t\\tthis._sampleLevel = v;\\r\\n\\t\\t\\tthis.object['TAARenderPass'].effect.sampleLevel = this._sampleLevel;\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget sampleLevel () {\\r\\n\\t\\treturn this._sampleLevel;\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\tset shaderPass (v) {\\r\\n\\t\\tif (this._shaderPass != v) {\\r\\n\\t\\t\\tthis._shaderPass = v;\\r\\n\\t\\t\\tthis.drawRender();\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget shaderPass () {\\r\\n\\t\\treturn this._shaderPass;\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\tset saoPass (v) {\\r\\n\\t\\tif (this._saoPass != v) {\\r\\n\\t\\t\\tthis._saoPass = v;\\r\\n\\t\\t\\tthis.drawRender();\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget saoPass () {\\r\\n\\t\\treturn this._saoPass;\\r\\n\\t},\\r\\n\\r\\n\\r\\n\\tset saoJSON (v) {\\r\\n\\t\\tif (this._saoJSON != v) {\\r\\n\\t\\t\\tthis._saoJSON = v;\\r\\n\\t\\t\\tthis.setObjInObj(this.object['SAOPass'].effect.params, this._saoJSON);\\r\\n\\t\\t\\t// this.dragOutline();\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget saoJSON () {\\r\\n\\t\\treturn this._saoJSON;\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nfunction EffectScene (_effect) {\\r\\n\\tvar self = this;\\r\\n\\tthis.type = 'null';\\r\\n\\tthis.effect = _effect;\\r\\n\\r\\n\\tthis._activ = false;\\r\\n\\tthis.render = function () {\\r\\n\\r\\n\\t};\\r\\n}\\r\\n\\r\\nEffectScene.prototype = {\\r\\n\\tset activ (v) {\\r\\n\\t\\tif (this._activ != v) {\\r\\n\\t\\t\\tthis._activ = v;\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tget activ () {\\r\\n\\t\\treturn this._activ;\\r\\n\\t}\\r\\n\\r\\n\\r\\n};\\r\\n\\r\\n\\r\\n/**\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @authod mrdoob / http://mrdoob.com/\\r\\n * @authod arodic / http://aleksandarrodic.com/\\r\\n * @authod fonserbc / http://fonserbc.github.io/\\r\\n*/\\r\\n\\r\\nTHREE.StereoEffect = function (renderer) {\\r\\n\\r\\n\\tvar _stereo = new THREE.StereoCamera();\\r\\n\\t_stereo.aspect = 0.5;\\r\\n\\r\\n\\tthis.setSize = function (width, height) {\\r\\n\\r\\n\\t\\trenderer.setSize(width, height);\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.render = function (scene, camera) {\\r\\n\\r\\n\\t\\tscene.updateMatrixWorld();\\r\\n\\r\\n\\t\\tif (camera.parent === null) camera.updateMatrixWorld();\\r\\n\\r\\n\\t\\t_stereo.update(camera);\\r\\n\\r\\n\\t\\tvar size = renderer.getSize();\\r\\n\\r\\n\\t\\trenderer.setScissorTest(true);\\r\\n\\t\\trenderer.clear();\\r\\n\\r\\n\\t\\trenderer.setScissor(0, 0, size.width / 2, size.height);\\r\\n\\t\\trenderer.setViewport(0, 0, size.width / 2, size.height);\\r\\n\\t\\trenderer.render(scene, _stereo.cameraL);\\r\\n\\r\\n\\t\\trenderer.setScissor(size.width / 2, 0, size.width / 2, size.height);\\r\\n\\t\\trenderer.setViewport(size.width / 2, 0, size.width / 2, size.height);\\r\\n\\t\\trenderer.render(scene, _stereo.cameraR);\\r\\n\\r\\n\\t\\trenderer.setScissorTest(false);\\r\\n\\r\\n\\t};\\r\\n\\r\\n};\\r\\n/**\\r\\n * Created by tpowellmeto on 29/10/2015.\\r\\n *\\r\\n * peppers ghost effect based on http://www.instructables.com/id/Reflective-Prism/?ALLSTEPS\\r\\n */\\r\\nTHREE.PeppersGhostEffect = function (renderer) {\\r\\n\\r\\n\\tvar scope = this;\\r\\n\\r\\n\\tscope.cameraDistance = 15;\\r\\n\\tscope.reflectFromAbove = false;\\r\\n\\r\\n\\t// Internals\\r\\n\\tvar _halfWidth, _width, _height;\\r\\n\\r\\n\\tvar _cameraF = new THREE.PerspectiveCamera(); // front\\r\\n\\tvar _cameraB = new THREE.PerspectiveCamera(); // back\\r\\n\\tvar _cameraL = new THREE.PerspectiveCamera(); // left\\r\\n\\tvar _cameraR = new THREE.PerspectiveCamera(); // right\\r\\n\\r\\n\\tvar _position = new THREE.Vector3();\\r\\n\\tvar _quaternion = new THREE.Quaternion();\\r\\n\\tvar _scale = new THREE.Vector3();\\r\\n\\r\\n\\t// Initialization\\r\\n\\trenderer.autoClear = false;\\r\\n\\r\\n\\tthis.setSize = function (width, height) {\\r\\n\\r\\n\\t\\t_halfWidth = width / 2;\\r\\n\\t\\tif (width < height) {\\r\\n\\r\\n\\t\\t\\t_width = width / 3;\\r\\n\\t\\t\\t_height = width / 3;\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t_width = height / 3;\\r\\n\\t\\t\\t_height = height / 3;\\r\\n\\r\\n\\t\\t}\\r\\n\\t\\trenderer.setSize(width, height);\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.render = function (scene, camera) {\\r\\n\\r\\n\\t\\tscene.updateMatrixWorld();\\r\\n\\r\\n\\t\\tif (camera.parent === null) camera.updateMatrixWorld();\\r\\n\\r\\n\\t\\tcamera.matrixWorld.decompose(_position, _quaternion, _scale);\\r\\n\\r\\n\\t\\t// front\\r\\n\\t\\t_cameraF.position.copy(_position);\\r\\n\\t\\t_cameraF.quaternion.copy(_quaternion);\\r\\n\\t\\t_cameraF.translateZ(scope.cameraDistance);\\r\\n\\t\\t_cameraF.lookAt(scene.position);\\r\\n\\r\\n\\t\\t// back\\r\\n\\t\\t_cameraB.position.copy(_position);\\r\\n\\t\\t_cameraB.quaternion.copy(_quaternion);\\r\\n\\t\\t_cameraB.translateZ(-(scope.cameraDistance));\\r\\n\\t\\t_cameraB.lookAt(scene.position);\\r\\n\\t\\t_cameraB.rotation.z += 180 * (Math.PI / 180);\\r\\n\\r\\n\\t\\t// left\\r\\n\\t\\t_cameraL.position.copy(_position);\\r\\n\\t\\t_cameraL.quaternion.copy(_quaternion);\\r\\n\\t\\t_cameraL.translateX(-(scope.cameraDistance));\\r\\n\\t\\t_cameraL.lookAt(scene.position);\\r\\n\\t\\t_cameraL.rotation.x += 90 * (Math.PI / 180);\\r\\n\\r\\n\\t\\t// right\\r\\n\\t\\t_cameraR.position.copy(_position);\\r\\n\\t\\t_cameraR.quaternion.copy(_quaternion);\\r\\n\\t\\t_cameraR.translateX(scope.cameraDistance);\\r\\n\\t\\t_cameraR.lookAt(scene.position);\\r\\n\\t\\t_cameraR.rotation.x += 90 * (Math.PI / 180);\\r\\n\\r\\n\\r\\n\\t\\trenderer.clear();\\r\\n\\t\\trenderer.setScissorTest(true);\\r\\n\\r\\n\\t\\trenderer.setScissor(_halfWidth - (_width / 2), (_height * 2), _width, _height);\\r\\n\\t\\trenderer.setViewport(_halfWidth - (_width / 2), (_height * 2), _width, _height);\\r\\n\\r\\n\\t\\tif (scope.reflectFromAbove) {\\r\\n\\r\\n\\t\\t\\trenderer.render(scene, _cameraB);\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\trenderer.render(scene, _cameraF);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderer.setScissor(_halfWidth - (_width / 2), 0, _width, _height);\\r\\n\\t\\trenderer.setViewport(_halfWidth - (_width / 2), 0, _width, _height);\\r\\n\\r\\n\\t\\tif (scope.reflectFromAbove) {\\r\\n\\r\\n\\t\\t\\trenderer.render(scene, _cameraF);\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\trenderer.render(scene, _cameraB);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderer.setScissor(_halfWidth - (_width / 2) - _width, _height, _width, _height);\\r\\n\\t\\trenderer.setViewport(_halfWidth - (_width / 2) - _width, _height, _width, _height);\\r\\n\\r\\n\\t\\tif (scope.reflectFromAbove) {\\r\\n\\r\\n\\t\\t\\trenderer.render(scene, _cameraR);\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\trenderer.render(scene, _cameraL);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderer.setScissor(_halfWidth + (_width / 2), _height, _width, _height);\\r\\n\\t\\trenderer.setViewport(_halfWidth + (_width / 2), _height, _width, _height);\\r\\n\\r\\n\\t\\tif (scope.reflectFromAbove) {\\r\\n\\r\\n\\t\\t\\trenderer.render(scene, _cameraL);\\r\\n\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\trenderer.render(scene, _cameraR);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderer.setScissorTest(false);\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n};\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author marklundin / http://mark-lundin.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n */\\r\\nTHREE.ParallaxBarrierEffect = function (renderer) {\\r\\n\\r\\n\\tvar _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\\r\\n\\r\\n\\tvar _scene = new THREE.Scene();\\r\\n\\r\\n\\tvar _stereo = new THREE.StereoCamera();\\r\\n\\r\\n\\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\\r\\n\\r\\n\\tvar _renderTargetL = new THREE.WebGLRenderTarget(512, 512, _params);\\r\\n\\tvar _renderTargetR = new THREE.WebGLRenderTarget(512, 512, _params);\\r\\n\\r\\n\\tvar _material = new THREE.ShaderMaterial({\\r\\n\\r\\n\\t\\tuniforms: {\\r\\n\\r\\n\\t\\t\\t'mapLeft': { type: 't', value: _renderTargetL.texture },\\r\\n\\t\\t\\t'mapRight': { type: 't', value: _renderTargetR.texture }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tvertexShader: [\\r\\n\\r\\n\\t\\t\\t'varying vec2 vUv;',\\r\\n\\r\\n\\t\\t\\t'void main() {',\\r\\n\\r\\n\\t\\t\\t'\\tvUv = vec2( uv.x, uv.y );',\\r\\n\\t\\t\\t'\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\\r\\n\\r\\n\\t\\t\\t'}'\\r\\n\\r\\n\\t\\t].join('\\\\n'),\\r\\n\\r\\n\\t\\tfragmentShader: [\\r\\n\\r\\n\\t\\t\\t'uniform sampler2D mapLeft;',\\r\\n\\t\\t\\t'uniform sampler2D mapRight;',\\r\\n\\t\\t\\t'varying vec2 vUv;',\\r\\n\\r\\n\\t\\t\\t'void main() {',\\r\\n\\r\\n\\t\\t\\t'\\tvec2 uv = vUv;',\\r\\n\\r\\n\\t\\t\\t'\\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {',\\r\\n\\r\\n\\t\\t\\t'\\t\\tgl_FragColor = texture2D( mapLeft, uv );',\\r\\n\\r\\n\\t\\t\\t'\\t} else {',\\r\\n\\r\\n\\t\\t\\t'\\t\\tgl_FragColor = texture2D( mapRight, uv );',\\r\\n\\r\\n\\t\\t\\t'\\t}',\\r\\n\\r\\n\\t\\t\\t'}'\\r\\n\\r\\n\\t\\t].join('\\\\n')\\r\\n\\r\\n\\t});\\r\\n\\r\\n\\tvar mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _material);\\r\\n\\t_scene.add(mesh);\\r\\n\\r\\n\\tthis.setSize = function (width, height) {\\r\\n\\r\\n\\t\\trenderer.setSize(width, height);\\r\\n\\r\\n\\t\\tvar pixelRatio = renderer.getPixelRatio();\\r\\n\\r\\n\\t\\t_renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\\r\\n\\t\\t_renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.render = function (scene, camera) {\\r\\n\\r\\n\\t\\tscene.updateMatrixWorld();\\r\\n\\r\\n\\t\\tif (camera.parent === null) camera.updateMatrixWorld();\\r\\n\\r\\n\\t\\t_stereo.update(camera);\\r\\n\\r\\n\\t\\trenderer.render(scene, _stereo.cameraL, _renderTargetL, true);\\r\\n\\t\\trenderer.render(scene, _stereo.cameraR, _renderTargetR, true);\\r\\n\\t\\trenderer.render(_scene, _camera);\\r\\n\\r\\n\\t};\\r\\n\\r\\n};\\r\\n/**\\r\\n * @author mrdoob / http://mrdoob.com/\\r\\n * @author marklundin / http://mark-lundin.com/\\r\\n * @author alteredq / http://alteredqualia.com/\\r\\n * @author tschw\\r\\n */\\r\\nTHREE.AnaglyphEffect = function (renderer, width, height) {\\r\\n\\r\\n\\t// Matrices generated with angler.js https://github.com/tschw/angler.js/\\r\\n\\t// (in column-major element order, as accepted by WebGL)\\r\\n\\r\\n\\tthis.colorMatrixLeft = new THREE.Matrix3().fromArray([\\r\\n\\r\\n\\t\\t1.0671679973602295, \\t-0.0016435992438346148,\\t\\t 0.0001777536963345483, // r out\\r\\n\\t\\t-0.028107794001698494,\\t-0.00019593400065787137,\\t-0.0002875397040043026, // g out\\r\\n\\t\\t-0.04279090091586113,\\t 0.000015809757314855233,\\t-0.00024287120322696865 // b out\\r\\n\\r\\n\\t]);\\r\\n\\r\\n\\t//\\t\\tred\\t\\t\\t\\t\\t\\tgreen \\t\\t\\t\\t\\t\\tblue  \\t\\t\\t\\t\\t\\tin\\r\\n\\r\\n\\tthis.colorMatrixRight = new THREE.Matrix3().fromArray([\\r\\n\\r\\n\\t\\t-0.0355340838432312,\\t-0.06440307199954987,\\t\\t 0.018319187685847282,\\t// r out\\r\\n\\t\\t-0.10269022732973099,\\t 0.8079727292060852,\\t\\t-0.04835830628871918,\\t// g out\\r\\n\\t\\t0.0001224992738571018,\\t-0.009558862075209618,\\t\\t 0.567823588848114\\t\\t// b out\\r\\n\\r\\n\\t]);\\r\\n\\r\\n\\tvar _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\\r\\n\\r\\n\\tvar _scene = new THREE.Scene();\\r\\n\\r\\n\\tvar _stereo = new THREE.StereoCamera();\\r\\n\\r\\n\\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\\r\\n\\r\\n\\tif (width === undefined) width = 512;\\r\\n\\tif (height === undefined) height = 512;\\r\\n\\r\\n\\tvar _renderTargetL = new THREE.WebGLRenderTarget(width, height, _params);\\r\\n\\tvar _renderTargetR = new THREE.WebGLRenderTarget(width, height, _params);\\r\\n\\r\\n\\tvar _material = new THREE.ShaderMaterial({\\r\\n\\r\\n\\t\\tuniforms: {\\r\\n\\r\\n\\t\\t\\t'mapLeft': { type: 't', value: _renderTargetL.texture },\\r\\n\\t\\t\\t'mapRight': { type: 't', value: _renderTargetR.texture },\\r\\n\\r\\n\\t\\t\\t'colorMatrixLeft': { type: 'm3', value: this.colorMatrixLeft },\\r\\n\\t\\t\\t'colorMatrixRight': { type: 'm3', value: this.colorMatrixRight }\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tvertexShader: [\\r\\n\\r\\n\\t\\t\\t'varying vec2 vUv;',\\r\\n\\r\\n\\t\\t\\t'void main() {',\\r\\n\\r\\n\\t\\t\\t'\\tvUv = vec2( uv.x, uv.y );',\\r\\n\\t\\t\\t'\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\\r\\n\\r\\n\\t\\t\\t'}'\\r\\n\\r\\n\\t\\t].join('\\\\n'),\\r\\n\\r\\n\\t\\tfragmentShader: [\\r\\n\\r\\n\\t\\t\\t'uniform sampler2D mapLeft;',\\r\\n\\t\\t\\t'uniform sampler2D mapRight;',\\r\\n\\t\\t\\t'varying vec2 vUv;',\\r\\n\\r\\n\\t\\t\\t'uniform mat3 colorMatrixLeft;',\\r\\n\\t\\t\\t'uniform mat3 colorMatrixRight;',\\r\\n\\r\\n\\t\\t\\t// These functions implement sRGB linearization and gamma correction\\r\\n\\r\\n\\t\\t\\t'float lin( float c ) {',\\r\\n\\t\\t\\t'\\treturn c <= 0.04045 ? c * 0.0773993808 :',\\r\\n\\t\\t\\t'\\t\\t\\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );',\\r\\n\\t\\t\\t'}',\\r\\n\\r\\n\\t\\t\\t'vec4 lin( vec4 c ) {',\\r\\n\\t\\t\\t'\\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );',\\r\\n\\t\\t\\t'}',\\r\\n\\r\\n\\t\\t\\t'float dev( float c ) {',\\r\\n\\t\\t\\t'\\treturn c <= 0.0031308 ? c * 12.92',\\r\\n\\t\\t\\t'\\t\\t\\t: pow( c, 0.41666 ) * 1.055 - 0.055;',\\r\\n\\t\\t\\t'}',\\r\\n\\r\\n\\r\\n\\t\\t\\t'void main() {',\\r\\n\\r\\n\\t\\t\\t'\\tvec2 uv = vUv;',\\r\\n\\r\\n\\t\\t\\t'\\tvec4 colorL = lin( texture2D( mapLeft, uv ) );',\\r\\n\\t\\t\\t'\\tvec4 colorR = lin( texture2D( mapRight, uv ) );',\\r\\n\\r\\n\\t\\t\\t'\\tvec3 color = clamp(',\\r\\n\\t\\t\\t'\\t\\t\\tcolorMatrixLeft * colorL.rgb +',\\r\\n\\t\\t\\t'\\t\\t\\tcolorMatrixRight * colorR.rgb, 0., 1. );',\\r\\n\\r\\n\\t\\t\\t'\\tgl_FragColor = vec4(',\\r\\n\\t\\t\\t'\\t\\t\\tdev( color.r ), dev( color.g ), dev( color.b ),',\\r\\n\\t\\t\\t'\\t\\t\\tmax( colorL.a, colorR.a ) );',\\r\\n\\r\\n\\t\\t\\t'}'\\r\\n\\r\\n\\t\\t].join('\\\\n')\\r\\n\\r\\n\\t});\\r\\n\\r\\n\\tvar mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _material);\\r\\n\\t_scene.add(mesh);\\r\\n\\r\\n\\tthis.setSize = function (width, height) {\\r\\n\\r\\n\\t\\trenderer.setSize(width, height);\\r\\n\\r\\n\\t\\tvar pixelRatio = renderer.getPixelRatio();\\r\\n\\r\\n\\t\\t_renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\\r\\n\\t\\t_renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.render = function (scene, camera) {\\r\\n\\r\\n\\t\\tscene.updateMatrixWorld();\\r\\n\\r\\n\\t\\tif (camera.parent === null) camera.updateMatrixWorld();\\r\\n\\r\\n\\t\\t_stereo.update(camera);\\r\\n\\r\\n\\t\\trenderer.render(scene, _stereo.cameraL, _renderTargetL, true);\\r\\n\\t\\trenderer.render(scene, _stereo.cameraR, _renderTargetR, true);\\r\\n\\t\\trenderer.render(_scene, _camera);\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.dispose = function () {\\r\\n\\r\\n\\t\\tif (_renderTargetL) _renderTargetL.dispose();\\r\\n\\t\\tif (_renderTargetR) _renderTargetR.dispose();\\r\\n\\r\\n\\t};\\r\\n\\r\\n};\\r\\n\\r\\n\\r\\n/*\\r\\n * @author zz85 / https://github.com/zz85\\r\\n *\\r\\n * Ascii generation is based on http://www.nihilogic.dk/labs/jsascii/\\r\\n * Maybe more about this later with a blog post at http://lab4games.net/zz85/blog\\r\\n *\\r\\n * 16 April 2012 - @blurspline\\r\\n */\\r\\n\\r\\nTHREE.AsciiEffect = function (renderer, charSet, options) {\\r\\n\\r\\n\\t// its fun to create one your own!\\r\\n\\r\\n\\tcharSet = (charSet === undefined) ? ' .:-=+*#%@' : charSet;\\r\\n\\r\\n\\t// ' .,:;=|iI+hHOE#`$';\\r\\n\\t// darker bolder character set from https://github.com/saw/Canvas-ASCII-Art/\\r\\n\\t// ' .\\\\'`^\\\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$'.split('');\\r\\n\\r\\n\\tif (!options) options = {};\\r\\n\\r\\n\\t// Some ASCII settings\\r\\n\\r\\n\\tvar bResolution = !options[ 'resolution' ] ? 0.15 : options[ 'resolution' ]; // Higher for more details\\r\\n\\tvar iScale = !options[ 'scale' ] ? 1 : options[ 'scale' ];\\r\\n\\tvar bColor = !options[ 'color' ] ? false : options[ 'color' ]; // nice but slows down rendering!\\r\\n\\tvar bAlpha = !options[ 'alpha' ] ? false : options[ 'alpha' ]; // Transparency\\r\\n\\tvar bBlock = !options[ 'block' ] ? false : options[ 'block' ]; // blocked characters. like good O dos\\r\\n\\tvar bInvert = !options[ 'invert' ] ? false : options[ 'invert' ]; // black is white, white is black\\r\\n\\r\\n\\tvar strResolution = 'low';\\r\\n\\r\\n\\tvar width, height;\\r\\n\\r\\n\\tvar domElement = document.createElement('div');\\r\\n\\tdomElement.style.cursor = 'default';\\r\\n\\r\\n\\tvar oAscii = document.createElement('table');\\r\\n\\tdomElement.appendChild(oAscii);\\r\\n\\r\\n\\tvar iWidth, iHeight;\\r\\n\\tvar oImg;\\r\\n\\r\\n\\tthis.setSize = function (w, h) {\\r\\n\\r\\n\\t\\twidth = w;\\r\\n\\t\\theight = h;\\r\\n\\r\\n\\t\\trenderer.setSize(w, h);\\r\\n\\r\\n\\t\\tinitAsciiSize();\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.render = function (scene, camera) {\\r\\n\\r\\n\\t\\trenderer.render(scene, camera);\\r\\n\\t\\tasciifyImage(renderer, oAscii);\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.domElement = domElement;\\r\\n\\r\\n\\r\\n\\t// Throw in ascii library from http://www.nihilogic.dk/labs/jsascii/jsascii.js\\r\\n\\r\\n\\t/*\\r\\n\\t* jsAscii 0.1\\r\\n\\t* Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/\\r\\n\\t* MIT License [http://www.nihilogic.dk/licenses/mit-license.txt]\\r\\n\\t*/\\r\\n\\r\\n\\tfunction initAsciiSize () {\\r\\n\\r\\n\\t\\tiWidth = Math.round(width * fResolution);\\r\\n\\t\\tiHeight = Math.round(height * fResolution);\\r\\n\\r\\n\\t\\toCanvas.width = iWidth;\\r\\n\\t\\toCanvas.height = iHeight;\\r\\n\\t\\t// oCanvas.style.display = \\\"none\\\";\\r\\n\\t\\t// oCanvas.style.width = iWidth;\\r\\n\\t\\t// oCanvas.style.height = iHeight;\\r\\n\\r\\n\\t\\toImg = renderer.domElement;\\r\\n\\r\\n\\t\\tif (oImg.style.backgroundColor) {\\r\\n\\r\\n\\t\\t\\toAscii.rows[ 0 ].cells[ 0 ].style.backgroundColor = oImg.style.backgroundColor;\\r\\n\\t\\t\\toAscii.rows[ 0 ].cells[ 0 ].style.color = oImg.style.color;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\toAscii.cellSpacing = 0;\\r\\n\\t\\toAscii.cellPadding = 0;\\r\\n\\r\\n\\t\\tvar oStyle = oAscii.style;\\r\\n\\t\\toStyle.display = 'inline';\\r\\n\\t\\toStyle.width = Math.round(iWidth / fResolution * iScale) + 'px';\\r\\n\\t\\toStyle.height = Math.round(iHeight / fResolution * iScale) + 'px';\\r\\n\\t\\toStyle.whiteSpace = 'pre';\\r\\n\\t\\toStyle.margin = '0px';\\r\\n\\t\\toStyle.padding = '0px';\\r\\n\\t\\toStyle.letterSpacing = fLetterSpacing + 'px';\\r\\n\\t\\toStyle.fontFamily = strFont;\\r\\n\\t\\toStyle.fontSize = fFontSize + 'px';\\r\\n\\t\\toStyle.lineHeight = fLineHeight + 'px';\\r\\n\\t\\toStyle.textAlign = 'left';\\r\\n\\t\\toStyle.textDecoration = 'none';\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tvar aDefaultCharList = (' .,:;i1tfLCG08@').split('');\\r\\n\\tvar aDefaultColorCharList = (' CGO08@').split('');\\r\\n\\tvar strFont = 'courier new, monospace';\\r\\n\\r\\n\\tvar oCanvasImg = renderer.domElement;\\r\\n\\r\\n\\tvar oCanvas = document.createElement('canvas');\\r\\n\\tif (!oCanvas.getContext) {\\r\\n\\r\\n\\t\\treturn;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar oCtx = oCanvas.getContext('2d');\\r\\n\\tif (!oCtx.getImageData) {\\r\\n\\r\\n\\t\\treturn;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tvar aCharList = (bColor ? aDefaultColorCharList : aDefaultCharList);\\r\\n\\r\\n\\tif (charSet) aCharList = charSet;\\r\\n\\r\\n\\tvar fResolution = 0.5;\\r\\n\\r\\n\\tswitch (strResolution) {\\r\\n\\r\\n\\t\\tcase 'low' : \\tfResolution = 0.25; break;\\r\\n\\t\\tcase 'medium' : fResolution = 0.5; break;\\r\\n\\t\\tcase 'high' : \\tfResolution = 1; break;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif (bResolution) fResolution = bResolution;\\r\\n\\r\\n\\t// Setup dom\\r\\n\\r\\n\\tvar fFontSize = (2 / fResolution) * iScale;\\r\\n\\tvar fLineHeight = (2 / fResolution) * iScale;\\r\\n\\r\\n\\t// adjust letter-spacing for all combinations of scale and resolution to get it to fit the image width.\\r\\n\\r\\n\\tvar fLetterSpacing = 0;\\r\\n\\r\\n\\tif (strResolution == 'low') {\\r\\n\\r\\n\\t\\tswitch (iScale) {\\r\\n\\t\\t\\tcase 1 : fLetterSpacing = -1; break;\\r\\n\\t\\t\\tcase 2 :\\r\\n\\t\\t\\tcase 3 : fLetterSpacing = -2.1; break;\\r\\n\\t\\t\\tcase 4 : fLetterSpacing = -3.1; break;\\r\\n\\t\\t\\tcase 5 : fLetterSpacing = -4.15; break;\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif (strResolution == 'medium') {\\r\\n\\r\\n\\t\\tswitch (iScale) {\\r\\n\\t\\t\\tcase 1 : fLetterSpacing = 0; break;\\r\\n\\t\\t\\tcase 2 : fLetterSpacing = -1; break;\\r\\n\\t\\t\\tcase 3 : fLetterSpacing = -1.04; break;\\r\\n\\t\\t\\tcase 4 :\\r\\n\\t\\t\\tcase 5 : fLetterSpacing = -2.1; break;\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tif (strResolution == 'high') {\\r\\n\\r\\n\\t\\tswitch (iScale) {\\r\\n\\t\\t\\tcase 1 :\\r\\n\\t\\t\\tcase 2 : fLetterSpacing = 0; break;\\r\\n\\t\\t\\tcase 3 :\\r\\n\\t\\t\\tcase 4 :\\r\\n\\t\\t\\tcase 5 : fLetterSpacing = -1; break;\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t// can't get a span or div to flow like an img element, but a table works?\\r\\n\\r\\n\\r\\n\\t// convert img element to ascii\\r\\n\\r\\n\\tfunction asciifyImage (canvasRenderer, oAscii) {\\r\\n\\r\\n\\t\\toCtx.clearRect(0, 0, iWidth, iHeight);\\r\\n\\t\\toCtx.drawImage(oCanvasImg, 0, 0, iWidth, iHeight);\\r\\n\\t\\tvar oImgData = oCtx.getImageData(0, 0, iWidth, iHeight).data;\\r\\n\\r\\n\\t\\t// Coloring loop starts now\\r\\n\\t\\tvar strChars = '';\\r\\n\\r\\n\\t\\t// console.time('rendering');\\r\\n\\r\\n\\t\\tfor (var y = 0; y < iHeight; y += 2) {\\r\\n\\r\\n\\t\\t\\tfor (var x = 0; x < iWidth; x++) {\\r\\n\\r\\n\\t\\t\\t\\tvar iOffset = (y * iWidth + x) * 4;\\r\\n\\r\\n\\t\\t\\t\\tvar iRed = oImgData[ iOffset ];\\r\\n\\t\\t\\t\\tvar iGreen = oImgData[ iOffset + 1 ];\\r\\n\\t\\t\\t\\tvar iBlue = oImgData[ iOffset + 2 ];\\r\\n\\t\\t\\t\\tvar iAlpha = oImgData[ iOffset + 3 ];\\r\\n\\t\\t\\t\\tvar iCharIdx;\\r\\n\\r\\n\\t\\t\\t\\tvar fBrightness;\\r\\n\\r\\n\\t\\t\\t\\tfBrightness = (0.3 * iRed + 0.59 * iGreen + 0.11 * iBlue) / 255;\\r\\n\\t\\t\\t\\t// fBrightness = (0.3*iRed + 0.5*iGreen + 0.3*iBlue) / 255;\\r\\n\\r\\n\\t\\t\\t\\tif (iAlpha == 0) {\\r\\n\\r\\n\\t\\t\\t\\t\\t// should calculate alpha instead, but quick hack :)\\r\\n\\t\\t\\t\\t\\t// fBrightness *= (iAlpha / 255);\\r\\n\\t\\t\\t\\t\\tfBrightness = 1;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tiCharIdx = Math.floor((1 - fBrightness) * (aCharList.length - 1));\\r\\n\\r\\n\\t\\t\\t\\tif (bInvert) {\\r\\n\\r\\n\\t\\t\\t\\t\\tiCharIdx = aCharList.length - iCharIdx - 1;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// good for debugging\\r\\n\\t\\t\\t\\t// fBrightness = Math.floor(fBrightness * 10);\\r\\n\\t\\t\\t\\t// strThisChar = fBrightness;\\r\\n\\r\\n\\t\\t\\t\\tvar strThisChar = aCharList[ iCharIdx ];\\r\\n\\r\\n\\t\\t\\t\\tif (strThisChar === undefined || strThisChar == ' ') { strThisChar = '&nbsp;'; }\\r\\n\\r\\n\\t\\t\\t\\tif (bColor) {\\r\\n\\r\\n\\t\\t\\t\\t\\tstrChars += \\\"<span style='\\\" +\\r\\n\\t\\t\\t\\t\\t\\t'color:rgb(' + iRed + ',' + iGreen + ',' + iBlue + ');' +\\r\\n\\t\\t\\t\\t\\t\\t(bBlock ? 'background-color:rgb(' + iRed + ',' + iGreen + ',' + iBlue + ');' : '') +\\r\\n\\t\\t\\t\\t\\t\\t(bAlpha ? 'opacity:' + (iAlpha / 255) + ';' : '') +\\r\\n\\t\\t\\t\\t\\t\\t\\\"'>\\\" + strThisChar + '</span>';\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tstrChars += strThisChar;\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tstrChars += '<br/>';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\toAscii.innerHTML = '<tr><td>' + strChars + '</td></tr>';\\r\\n\\r\\n\\t\\t// console.timeEnd('rendering');\\r\\n\\r\\n\\t\\t// return oAscii;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// end modified asciifyImage block\\r\\n\\r\\n};\\r\\n\\r\\n\\r\\n/**\\r\\n*\\r\\n* Supersample Anti-Aliasing Render Pass\\r\\n*\\r\\n* @author bhouston / http://clara.io/\\r\\n*\\r\\n* This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\\r\\n*\\r\\n* References: https://en.wikipedia.org/wiki/Supersampling\\r\\n*\\r\\n*/\\r\\n\\r\\nTHREE.SSAARenderPass = function (scene, camera, clearColor, clearAlpha) {\\r\\n\\r\\n\\tTHREE.Pass.call(this);\\r\\n\\r\\n\\tthis.scene = scene;\\r\\n\\tthis.camera = camera;\\r\\n\\r\\n\\tthis.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\\r\\n\\tthis.unbiased = true;\\r\\n\\r\\n\\t// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\\r\\n\\tthis.clearColor = (clearColor !== undefined) ? clearColor : 0x000000;\\r\\n\\tthis.clearAlpha = (clearAlpha !== undefined) ? clearAlpha : 0;\\r\\n\\r\\n\\tif (THREE.CopyShader === undefined) console.error('THREE.SSAARenderPass relies on THREE.CopyShader');\\r\\n\\r\\n\\tvar copyShader = THREE.CopyShader;\\r\\n\\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\\r\\n\\r\\n\\tthis.copyMaterial = new THREE.ShaderMaterial({\\r\\n\\t\\tuniforms: this.copyUniforms,\\r\\n\\t\\tvertexShader: copyShader.vertexShader,\\r\\n\\t\\tfragmentShader: copyShader.fragmentShader,\\r\\n\\t\\tpremultipliedAlpha: true,\\r\\n\\t\\ttransparent: true,\\r\\n\\t\\tblending: THREE.AdditiveBlending,\\r\\n\\t\\tdepthTest: false,\\r\\n\\t\\tdepthWrite: false\\r\\n\\t});\\r\\n\\r\\n\\tthis.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\\r\\n\\tthis.scene2\\t= new THREE.Scene();\\r\\n\\tthis.quad2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.copyMaterial);\\r\\n\\tthis.quad2.frustumCulled = false; // Avoid getting clipped\\r\\n\\tthis.scene2.add(this.quad2);\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.SSAARenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\\r\\n\\r\\n\\tconstructor: THREE.SSAARenderPass,\\r\\n\\r\\n\\tdispose: function () {\\r\\n\\r\\n\\t\\tif (this.sampleRenderTarget) {\\r\\n\\r\\n\\t\\t\\tthis.sampleRenderTarget.dispose();\\r\\n\\t\\t\\tthis.sampleRenderTarget = null;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\tsetSize: function (width, height) {\\r\\n\\r\\n\\t\\tif (this.sampleRenderTarget)\\tthis.sampleRenderTarget.setSize(width, height);\\r\\n\\r\\n\\t},\\r\\n\\r\\n\\trender: function (renderer, writeBuffer, readBuffer) {\\r\\n\\r\\n\\t\\tif (!this.sampleRenderTarget) {\\r\\n\\r\\n\\t\\t\\tthis.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });\\r\\n\\t\\t\\tthis.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar jitterOffsets = THREE.SSAARenderPass.JitterVectors[ Math.max(0, Math.min(this.sampleLevel, 5)) ];\\r\\n\\r\\n\\t\\tvar autoClear = renderer.autoClear;\\r\\n\\t\\trenderer.autoClear = false;\\r\\n\\r\\n\\t\\tvar oldClearColor = renderer.getClearColor().getHex();\\r\\n\\t\\tvar oldClearAlpha = renderer.getClearAlpha();\\r\\n\\r\\n\\t\\tvar baseSampleWeight = 1.0 / jitterOffsets.length;\\r\\n\\t\\tvar roundingRange = 1 / 32;\\r\\n\\t\\tthis.copyUniforms[ 'tDiffuse' ].value = this.sampleRenderTarget.texture;\\r\\n\\r\\n\\t\\tvar width = readBuffer.width; var height = readBuffer.height;\\r\\n\\r\\n\\t\\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\\r\\n\\t\\tfor (var i = 0; i < jitterOffsets.length; i++) {\\r\\n\\r\\n\\t\\t\\tvar jitterOffset = jitterOffsets[ i ];\\r\\n\\r\\n\\t\\t\\tif (this.camera.setViewOffset) {\\r\\n\\r\\n\\t\\t\\t\\tthis.camera.setViewOffset(width, height,\\r\\n\\t\\t\\t\\t\\tjitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\\r\\n\\t\\t\\t\\t\\twidth, height);\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar sampleWeight = baseSampleWeight;\\r\\n\\r\\n\\t\\t\\tif (this.unbiased) {\\r\\n\\r\\n\\t\\t\\t\\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\\r\\n\\t\\t\\t\\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\\r\\n\\t\\t\\t\\t// across a range of values whose rounding errors cancel each other out.\\r\\n\\r\\n\\t\\t\\t\\tvar uniformCenteredDistribution = (-0.5 + (i + 0.5) / jitterOffsets.length);\\r\\n\\t\\t\\t\\tsampleWeight += roundingRange * uniformCenteredDistribution;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.copyUniforms[ 'opacity' ].value = sampleWeight;\\r\\n\\t\\t\\trenderer.setClearColor(this.clearColor, this.clearAlpha);\\r\\n\\t\\t\\trenderer.render(this.scene, this.camera, this.sampleRenderTarget, true);\\r\\n\\r\\n\\t\\t\\tif (i === 0) {\\r\\n\\r\\n\\t\\t\\t\\trenderer.setClearColor(0x000000, 0.0);\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\trenderer.render(this.scene2, this.camera2, this.renderToScreen ? null : writeBuffer, (i === 0));\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (this.camera.clearViewOffset) this.camera.clearViewOffset();\\r\\n\\r\\n\\t\\trenderer.autoClear = autoClear;\\r\\n\\t\\trenderer.setClearColor(oldClearColor, oldClearAlpha);\\r\\n\\r\\n\\t}\\r\\n\\r\\n});\\r\\n\\r\\n\\r\\n// These jitter vectors are specified in integers because it is easier.\\r\\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\\r\\n// before being used, thus these integers need to be scaled by 1/16.\\r\\n//\\r\\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\\r\\nTHREE.SSAARenderPass.JitterVectors = [\\r\\n\\t[\\r\\n\\t\\t[ 0, 0 ]\\r\\n\\t],\\r\\n\\t[\\r\\n\\t\\t[ 4, 4 ], [ -4, -4 ]\\r\\n\\t],\\r\\n\\t[\\r\\n\\t\\t[ -2, -6 ], [ 6, -2 ], [ -6, 2 ], [ 2, 6 ]\\r\\n\\t],\\r\\n\\t[\\r\\n\\t\\t[ 1, -3 ], [ -1, 3 ], [ 5, 1 ], [ -3, -5 ],\\r\\n\\t\\t[ -5, 5 ], [ -7, -1 ], [ 3, 7 ], [ 7, -7 ]\\r\\n\\t],\\r\\n\\t[\\r\\n\\t\\t[ 1, 1 ], [ -1, -3 ], [ -3, 2 ], [ 4, -1 ],\\r\\n\\t\\t[ -5, -2 ], [ 2, 5 ], [ 5, 3 ], [ 3, -5 ],\\r\\n\\t\\t[ -2, 6 ], [ 0, -7 ], [ -4, -6 ], [ -6, 4 ],\\r\\n\\t\\t[ -8, 0 ], [ 7, -4 ], [ 6, 7 ], [ -7, -8 ]\\r\\n\\t],\\r\\n\\t[\\r\\n\\t\\t[ -4, -7 ], [ -7, -5 ], [ -3, -5 ], [ -5, -4 ],\\r\\n\\t\\t[ -1, -4 ], [ -2, -2 ], [ -6, -1 ], [ -4, 0 ],\\r\\n\\t\\t[ -7, 1 ], [ -1, 2 ], [ -6, 3 ], [ -3, 3 ],\\r\\n\\t\\t[ -7, 6 ], [ -3, 6 ], [ -5, 7 ], [ -1, 7 ],\\r\\n\\t\\t[ 5, -7 ], [ 1, -6 ], [ 6, -5 ], [ 4, -4 ],\\r\\n\\t\\t[ 2, -3 ], [ 7, -2 ], [ 1, -1 ], [ 4, -1 ],\\r\\n\\t\\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\\r\\n\\t\\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\\r\\n\\t]\\r\\n];\\r\\n\\r\\n/**\\r\\n *\\r\\n * Temporal Anti-Aliasing Render Pass\\r\\n *\\r\\n * @author bhouston / http://clara.io/\\r\\n *\\r\\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\\r\\n *\\r\\n * References:\\r\\n *\\r\\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\\r\\n *\\r\\n */\\r\\n\\r\\nTHREE.TAARenderPass = function (scene, camera, params) {\\r\\n\\r\\n\\tif (THREE.SSAARenderPass === undefined) {\\r\\n\\r\\n\\t\\tconsole.error('THREE.TAARenderPass relies on THREE.SSAARenderPass');\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tTHREE.SSAARenderPass.call(this, scene, camera, params);\\r\\n\\r\\n\\tthis.sampleLevel = 0;\\r\\n\\tthis.accumulate = false;\\r\\n\\r\\n};\\r\\n\\r\\nTHREE.TAARenderPass.JitterVectors = THREE.SSAARenderPass.JitterVectors;\\r\\n\\r\\nTHREE.TAARenderPass.prototype = Object.assign(Object.create(THREE.SSAARenderPass.prototype), {\\r\\n\\r\\n\\tconstructor: THREE.TAARenderPass,\\r\\n\\r\\n\\trender: function (renderer, writeBuffer, readBuffer, delta) {\\r\\n\\r\\n\\t\\tif (!this.accumulate) {\\r\\n\\r\\n\\t\\t\\tTHREE.SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta);\\r\\n\\r\\n\\t\\t\\tthis.accumulateIndex = -1;\\r\\n\\t\\t\\treturn;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar jitterOffsets = THREE.TAARenderPass.JitterVectors[ 5 ];\\r\\n\\r\\n\\t\\tif (!this.sampleRenderTarget) {\\r\\n\\r\\n\\t\\t\\tthis.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\\r\\n\\t\\t\\tthis.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!this.holdRenderTarget) {\\r\\n\\r\\n\\t\\t\\tthis.holdRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\\r\\n\\t\\t\\tthis.holdRenderTarget.texture.name = 'TAARenderPass.hold';\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (this.accumulate && this.accumulateIndex === -1) {\\r\\n\\r\\n\\t\\t\\tTHREE.SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, delta);\\r\\n\\r\\n\\t\\t\\tthis.accumulateIndex = 0;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar autoClear = renderer.autoClear;\\r\\n\\t\\trenderer.autoClear = false;\\r\\n\\r\\n\\t\\tvar sampleWeight = 1.0 / (jitterOffsets.length);\\r\\n\\r\\n\\t\\tif (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\\r\\n\\r\\n\\t\\t\\tthis.copyUniforms[ 'opacity' ].value = sampleWeight;\\r\\n\\t\\t\\tthis.copyUniforms[ 'tDiffuse' ].value = writeBuffer.texture;\\r\\n\\r\\n\\t\\t\\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\\r\\n\\t\\t\\tvar numSamplesPerFrame = Math.pow(2, this.sampleLevel);\\r\\n\\t\\t\\tfor (var i = 0; i < numSamplesPerFrame; i++) {\\r\\n\\r\\n\\t\\t\\t\\tvar j = this.accumulateIndex;\\r\\n\\t\\t\\t\\tvar jitterOffset = jitterOffsets[ j ];\\r\\n\\r\\n\\t\\t\\t\\tif (this.camera.setViewOffset) {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.camera.setViewOffset(readBuffer.width, readBuffer.height,\\r\\n\\t\\t\\t\\t\\t\\tjitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\\r\\n\\t\\t\\t\\t\\t\\treadBuffer.width, readBuffer.height);\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\trenderer.render(this.scene, this.camera, writeBuffer, true);\\r\\n\\t\\t\\t\\trenderer.render(this.scene2, this.camera2, this.sampleRenderTarget, (this.accumulateIndex === 0));\\r\\n\\r\\n\\t\\t\\t\\tthis.accumulateIndex++;\\r\\n\\r\\n\\t\\t\\t\\tif (this.accumulateIndex >= jitterOffsets.length) break;\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (this.camera.clearViewOffset) this.camera.clearViewOffset();\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar accumulationWeight = this.accumulateIndex * sampleWeight;\\r\\n\\r\\n\\t\\tif (accumulationWeight > 0) {\\r\\n\\r\\n\\t\\t\\tthis.copyUniforms[ 'opacity' ].value = 1.0;\\r\\n\\t\\t\\tthis.copyUniforms[ 'tDiffuse' ].value = this.sampleRenderTarget.texture;\\r\\n\\t\\t\\trenderer.render(this.scene2, this.camera2, writeBuffer, true);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (accumulationWeight < 1.0) {\\r\\n\\r\\n\\t\\t\\tthis.copyUniforms[ 'opacity' ].value = 1.0 - accumulationWeight;\\r\\n\\t\\t\\tthis.copyUniforms[ 'tDiffuse' ].value = this.holdRenderTarget.texture;\\r\\n\\t\\t\\trenderer.render(this.scene2, this.camera2, writeBuffer, (accumulationWeight === 0));\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trenderer.autoClear = autoClear;\\r\\n\\r\\n\\t}\\r\\n\\r\\n});\\r\\n\\n\\n//# sourceURL=webpack:///./src/libMy/visi3D/MEffectArray.js?\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return MPosition3d; });\\n/* harmony import */ var _MUtility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\\n/* harmony import */ var _MSky_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\\n/* harmony import */ var _MSmc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);\\n\\r\\n\\r\\n\\r\\n\\r\\nfunction MPosition3d (_parent, _content2d) {\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tthis.parent = _parent;\\r\\n\\tthis.content2d = _content2d;\\r\\n\\tthis.drag = true;\\r\\n\\tthis.zdvigX = 0;\\r\\n\\tthis.sPixi = undefined;\\r\\n\\r\\n\\tthis.pause = false;\\r\\n\\tthis.minMaxX = new THREE.Vector2(0, 2.5);\\r\\n\\r\\n\\tthis.zume = new THREE.Vector3(1, 30, 10);\\r\\n\\r\\n\\tthis.point = new THREE.Vector2(0, 0);\\r\\n\\tthis.point1 = new THREE.Vector2(0, 0);\\r\\n\\tthis.b = 0;\\r\\n\\r\\n\\tthis.minZum = 0;\\r\\n\\tthis.maxZum = 5000;\\r\\n\\tthis.powerZum = 5;\\r\\n\\r\\n\\tthis.distMinMaxBox = 500;\\r\\n\\r\\n\\r\\n\\tthis.isDragPan = _parent._isDragPan;\\r\\n\\tthis.isRotateScene = false;\\r\\n\\r\\n\\tvar sceneRotationY = 0;\\r\\n\\r\\n\\r\\n\\tthis.getStage = function (c) {\\r\\n\\t\\tif (c.parent == undefined) return c;\\r\\n\\t\\telse return this.getStage(c.parent);\\r\\n\\t\\treturn null;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.stageMoveNew = function (e) {\\r\\n\\r\\n\\t\\tif (self.pause == true) return;\\r\\n\\t\\tif (self.drag == false) return;\\r\\n\\r\\n\\t\\tif (e.data && self.isDragPan && isMovePan) {\\r\\n\\t\\t\\thandleMouseMovePan(e.data.originalEvent);\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\ttrace(e)\\r\\n\\r\\n\\t\\tif (e.data && self.isRotateScene && e.data.originalEvent.shiftKey) {\\r\\n\\t\\t\\tself.parent.scene.rotation.y = sceneRotationY + (pl102.global.x - self.point1.x) * 0.01;\\r\\n\\t\\t\\tself.parent.intRend = 1;\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tself.parent.rotationX = self.point.y - (pl102.global.y - self.point1.y) * 0.01;\\r\\n\\t\\t\\tif (self.minMaxX.x > self.parent.rotationX) self.parent.rotationX = self.minMaxX.x;\\r\\n\\t\\t\\tif (self.minMaxX.y < self.parent.rotationX) self.parent.rotationX = self.minMaxX.y;\\r\\n\\t\\t\\tself.parent.rotationZ = self.point.x + (pl102.global.x - self.point1.x) * 0.01;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.stageUpNew = function (e) {\\r\\n\\r\\n\\t\\tif (pl102.isMouseEvents) {\\r\\n\\t\\t\\tself.sPixi.off('mouseup', self.stageUpNew);\\r\\n\\t\\t\\tself.sPixi.off('mousemove', self.stageMoveNew);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (pl102.isTouchEvents) {\\r\\n\\t\\t\\tself.sPixi.off('touchend', self.stageUpNew);\\r\\n\\t\\t\\tself.sPixi.off('touchmove', self.stageMoveNew);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.mouseUpp = function (e) {\\r\\n\\t\\tself.parent.intRend = 1;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// if (pl102.isMouseEvents) {\\r\\n\\t// \\tself.sPixi.on('mouseup', self.mouseUpp);\\r\\n\\t// }\\r\\n\\r\\n\\t// if (pl102.isTouchEvents) {\\r\\n\\t// \\tself.sPixi.on('touchend', self.mouseUpp);\\r\\n\\t// }\\r\\n\\r\\n\\tvar isMovePan = false;\\r\\n\\r\\n\\tthis.mouseDown = function (e) {\\r\\n\\r\\n\\t\\tif (self.pause == true) return;\\r\\n\\t\\tif (self.drag == false) return;\\r\\n\\r\\n\\t\\tisMovePan = false;\\r\\n\\t\\tif (self.isDragPan && e && e.data.originalEvent.button === 1) {\\r\\n\\t\\t\\tisMovePan = true;\\r\\n\\t\\t\\thandleMouseDownPan(e.data.originalEvent);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tself.point.y = self.parent.rotationX;\\r\\n\\t\\tself.point.x = self.parent.rotationZ;\\r\\n\\t\\tif (self.isRotateScene) {\\r\\n\\t\\t\\tsceneRotationY = self.parent.scene.rotation.y;\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tself.point1.x = pl102.global.x;\\r\\n\\t\\tself.point1.y = pl102.global.y;\\r\\n\\r\\n\\t\\t// self.parent.tween.stop();\\r\\n\\r\\n\\t\\t// stage.addEventListener(\\\"stagemousemove\\\", self.stageMoveNew);\\r\\n\\t\\t// stage.addEventListener(\\\"stagemouseup\\\", self.stageUpNew);\\r\\n\\t\\t// window.document.addEventListener('mousemove',    self.stageMoveNew, true);\\r\\n\\t\\t// window.document.addEventListener('mouseup',    self.stageUpNew, true);\\r\\n\\t\\tif (pl102.isMouseEvents) {\\r\\n\\t\\t\\tself.sPixi.off('mouseup', self.stageUpNew);\\r\\n\\t\\t\\tself.sPixi.off('mousemove', self.stageMoveNew);\\r\\n\\t\\t\\tself.sPixi.on('mouseup', self.stageUpNew);\\r\\n\\t\\t\\tself.sPixi.on('mousemove', self.stageMoveNew);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (pl102.isTouchEvents) {\\r\\n\\t\\t\\tself.sPixi.off('touchend', self.stageUpNew);\\r\\n\\t\\t\\tself.sPixi.off('touchmove', self.stageMoveNew);\\r\\n\\t\\t\\tself.sPixi.on('touchend', self.stageUpNew);\\r\\n\\t\\t\\tself.sPixi.on('touchmove', self.stageMoveNew);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\t// self.sPixi.on('mousedown', self.mouseDown);\\r\\n\\t// main.contentCurs.addEventListener( 'mousedown', this.mouseDown); /// TODO убрал это\\r\\n\\t// contentHTML.addEventListener('mousedown',    this.mouseDown, true);\\r\\n\\r\\n\\t// self.parent.parent.parent.stage.addEventListener( 'mousedown', this.mouseDown);\\r\\n\\tvar www;\\r\\n\\tthis.mousewheel = function (e) {\\r\\n\\r\\n\\t\\tif (self.pause == true) return;\\r\\n\\t\\tif (self.drag == false) return;\\r\\n\\r\\n\\r\\n\\t\\twww = self.parent._zume + (-e.delta) * self.powerZum;\\r\\n\\t\\tif (www < self.minZum) www = self.minZum;\\r\\n\\t\\tif (www > self.maxZum) www = self.maxZum;\\r\\n\\t\\tself.parent.zume = www;\\r\\n\\t\\tself.parent.intRend = 1;\\r\\n\\t};\\r\\n\\r\\n\\tif (this.content2d != undefined) {\\r\\n\\t\\tthis.sPixi = this.getStage(this.content2d);\\r\\n\\t\\tthis.sPixi.interactive = true;\\r\\n\\r\\n\\t\\tif (pl102.devas == false) {\\r\\n\\t\\t\\t_content2d.on('mousedown', this.mouseDown);\\r\\n\\t\\t\\tpl102Wheel.on(_content2d, 'mousewheel', this.mousewheel);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t_content2d.on('touchstart', this.mouseDown);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tvar panOffset = new THREE.Vector3();\\r\\n\\tvar panStart = new THREE.Vector2();\\r\\n\\tvar panEnd = new THREE.Vector2();\\r\\n\\tvar panDelta = new THREE.Vector2();\\r\\n\\r\\n\\tfunction handleMouseDownPan (event) {\\r\\n\\t\\tpanStart.set(event.clientX, event.clientY);\\r\\n\\t}\\r\\n\\r\\n\\tfunction handleMouseMovePan (event) {\\r\\n\\t\\tpanEnd.set(event.clientX, event.clientY);\\r\\n\\t\\tpanDelta.subVectors(panEnd, panStart);\\r\\n\\t\\tself.moveCamXY(panDelta);\\r\\n\\t\\tpanStart.copy(panEnd);\\r\\n\\t}\\r\\n\\tvar panLeft = (function () {\\r\\n\\t\\tvar v = new THREE.Vector3();\\r\\n\\t\\treturn function panLeft (distance, objectMatrix) {\\r\\n\\t\\t\\tv.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\\r\\n\\t\\t\\tv.multiplyScalar(-distance);\\r\\n\\t\\t\\tpanOffset.add(v);\\r\\n\\t\\t};\\r\\n\\t}());\\r\\n\\r\\n\\tvar panUp = (function () {\\r\\n\\t\\tvar v = new THREE.Vector3();\\r\\n\\t\\treturn function panUp (distance, objectMatrix) {\\r\\n\\t\\t\\tv.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix\\r\\n\\t\\t\\tv.multiplyScalar(distance);\\r\\n\\t\\t\\tpanOffset.add(v);\\r\\n\\t\\t};\\r\\n\\t}());\\r\\n\\tvar pan = (function () {\\r\\n\\t\\treturn function pan (deltaX, deltaY) {\\r\\n\\t\\t\\tvar element = self.parent.renderer.domElement;\\r\\n\\t\\t\\tif (self.parent.camera.isPerspectiveCamera) {\\r\\n\\t\\t\\t\\tvar targetDistance = Math.max(self.parent.zume, 10);\\r\\n\\t\\t\\t\\ttargetDistance *= Math.tan((self.parent.camera.fov / 2) * Math.PI / 180.0);\\r\\n\\t\\t\\t\\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\\r\\n\\t\\t\\t\\tpanLeft(2 * deltaX * targetDistance / element.clientHeight, self.parent.camera.matrixWorld);\\r\\n\\t\\t\\t\\tpanUp(2 * deltaY * targetDistance / element.clientHeight, self.parent.camera.matrixWorld);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tconsole.warn('WARNING: camera neither perspective.');\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\t}());\\r\\n\\r\\n\\tthis.moveCamXY = function (v) {\\r\\n\\t\\tpanOffset.set(0, 0, 0);\\r\\n\\t\\tself.parent.camera.updateMatrixWorld();\\r\\n\\t\\tself.parent.scene.updateMatrixWorld();\\r\\n\\t\\tif (arguments.length > 1) {\\r\\n\\t\\t\\tv = {\\r\\n\\t\\t\\t\\tx: arguments[0],\\r\\n\\t\\t\\t\\ty: arguments[1]\\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\t\\tpan((v.x || 0), (v.y || 0));\\r\\n\\t\\tself.parent.xVerh += panOffset.x;\\r\\n\\t\\tself.parent.yVerh += -panOffset.y;\\r\\n\\t\\tself.parent.zVerh += panOffset.z;\\r\\n\\r\\n\\t\\tself.parent.xVerh = Math.max(Math.min(self.parent.xVerh, self.distMinMaxBox), -self.distMinMaxBox);\\r\\n\\t\\tself.parent.zVerh = Math.max(Math.min(self.parent.zVerh, self.distMinMaxBox), -self.distMinMaxBox);\\r\\n\\t\\tself.parent.yVerh = Math.max(Math.min(self.parent.yVerh, self.distMinMaxBox), -self.distMinMaxBox);\\r\\n\\t\\tpanOffset.set(0, 0, 0);\\r\\n\\t};\\r\\n\\r\\n}\\r\\n\\n\\n//# sourceURL=webpack:///./src/libMy/visi3D/MPosition3d.js?\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"\\n// CONCATENATED MODULE: ./src/libMy/visi3D/MEventSob.js\\n\\r\\n// 'евент диспатча'\\r\\n\\r\\nfunction MEventSob () {\\r\\n\\r\\n\\tthis.event = undefined;\\r\\n\\r\\n\\tthis.arrSobName = ['up', 'down', \\t'move',\\t'out', \\t'over', 'wheel'];\\r\\n\\tthis.arrSob = [[], [], [], [], [], []];\\r\\n\\r\\n\\tthis.pozSob = undefined;\\r\\n\\r\\n\\tthis.dispatcherEvent = function (tipSob, event) {\\r\\n\\t\\tfor (var i = 0; i < this.arrSobName.length; i++) {\\r\\n\\t\\t\\tif (this.arrSobName[i] == tipSob) {\\r\\n\\r\\n\\t\\t\\t\\tif (event) event.type = tipSob;\\r\\n\\t\\t\\t\\tfor (var j = 0; j < this.arrSob[i].length; j++) {\\r\\n\\t\\t\\t\\t\\tthis.arrSob[i][j](event);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.removeEvent = function (str, fun) {\\r\\n\\t\\tfor (var i = 0; i < this.arrSobName.length; i++) {\\r\\n\\t\\t\\tif (this.arrSobName[i] == str) {\\r\\n\\t\\t\\t\\tfor (var j = 0; j < this.arrSob[i].length; j++) {\\r\\n\\t\\t\\t\\t\\tif (this.arrSob[i][j] == fun) {\\r\\n\\t\\t\\t\\t\\t\\tthis.arrSob[i].splice(j, 1);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.addEvent = function (str, fun) {\\r\\n\\r\\n\\t\\tfor (var i = 0; i < this.arrSobName.length; i++) {\\r\\n\\t\\t\\tif (this.arrSobName[i] == str) {\\r\\n\\t\\t\\t\\tthis.arrSob[i].push(fun);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n}\\r\\n\\n// CONCATENATED MODULE: ./src/libMy/visi3D/MEvent3D.js\\n// то что возврощаеться от событий\\r\\nfunction MEvent3D () {\\r\\n\\tthis.target = undefined;\\r\\n\\tthis.face = undefined;\\r\\n\\tthis.point = undefined;\\r\\n\\tthis.faceIndex = undefined;\\r\\n\\tthis.type = undefined;\\r\\n\\tthis.uv = undefined;\\r\\n\\tthis.originalEvent = undefined;\\r\\n\\tthis.copy = function () {\\r\\n\\t\\tvar r = new Event3D();\\r\\n\\t\\tr.target = this.target;\\r\\n\\t\\tr.face = this.face;\\r\\n\\t\\tr.point = this.point;\\r\\n\\t\\tr.faceIndex = this.faceIndex;\\r\\n\\t\\tr.type = this.type;\\r\\n\\t\\tr.uv = this.uv;\\r\\n\\t\\tr.originalEvent = this.originalEvent;\\r\\n\\t\\treturn r;\\r\\n\\t};\\r\\n}\\r\\n\\n// CONCATENATED MODULE: ./src/libMy/visi3D/MEvent3DArr.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return MEvent3DArr; });\\n\\r\\n\\r\\n\\r\\n\\r\\nfunction MEvent3DArr (par, camera, contentHTML, stage) {\\r\\n\\tthis.parent = par;\\r\\n\\tvar self = this;\\r\\n\\tthis.camera = camera;\\r\\n\\tthis.raycaster = new THREE.Raycaster();\\r\\n\\tthis.intersects;\\r\\n\\r\\n\\tthis.point = new THREE.Vector2(0, 0);\\r\\n\\tthis.pointWH = new THREE.Vector2(0, 0);\\r\\n\\tthis.arrChild = [];\\r\\n\\r\\n\\tthis.uuid = 'nullMy';\\r\\n\\tthis.obj3d;\\r\\n\\r\\n\\tthis.eventSob = new MEventSob();\\r\\n\\tthis.event3D = new MEvent3D();\\r\\n\\r\\n\\tthis.xzNull = 'xzNull';\\r\\n\\tthis.poiskName = 'xzPoisk';\\r\\n\\tthis.tokoName = 'null';\\r\\n\\r\\n\\tthis._activ = true;\\r\\n\\r\\n\\tthis.rect = {x: 0, y: 0, width: 100, height: 100};\\r\\n\\r\\n\\tthis.setRect = function (x, y, w, h) {\\r\\n\\t\\tthis.rect.x = x;\\r\\n\\t\\tthis.rect.y = y;\\r\\n\\t\\tthis.rect.width = w;\\r\\n\\t\\tthis.rect.height = h;\\r\\n\\t};\\r\\n\\r\\n\\tthis.removeChild = function (child) {\\r\\n\\t\\tfor (var i = 0; i < this.arrChild.length; i++) {\\r\\n\\t\\t\\tif (child.uuid == this.arrChild[i].uuid) {\\r\\n\\t\\t\\t\\tthis.arrChild.splice(i, 1);\\r\\n\\t\\t\\t\\ti = i - 1;\\r\\n\\t\\t\\t\\tif (i < 0)i = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.addChild = function (child) {\\r\\n\\t\\tthis.arrChild.push(child);\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tvar cameraPosition;\\r\\n\\tthis.boolNum = -1;\\r\\n\\tthis.boolNumOld = -1;\\r\\n\\tthis.event;\\r\\n\\tthis.mouseRay = function () {\\r\\n\\r\\n\\t\\tif (this._activ == false) return;\\r\\n\\r\\n\\t\\tthis.rayPusk();\\r\\n\\r\\n\\t\\tthis.boolNum = this.getGoodParam();\\r\\n\\r\\n\\t\\tif (this.boolNum == -1) {\\r\\n\\t\\t\\tif (this.uuid != 'nullMy') {\\r\\n\\t\\t\\t\\tthis.eventSob.dispatcherEvent('out', this.event3D);\\r\\n\\t\\t\\t\\tthis.uuid = 'nullMy';\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\tif (this.uuid != 'nullMy') { // обьект есть\\r\\n\\r\\n\\t\\t\\t\\tif (this.uuid != this.intersects[this.boolNum].object.uuid) { // это новый обьект\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.eventSob.dispatcherEvent('out', this.event3D);\\r\\n\\t\\t\\t\\t\\tthis.uuid = this.intersects[this.boolNum].object.uuid;\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.event3D.target = this.intersects[this.boolNum].object;\\r\\n\\t\\t\\t\\t\\tthis.event3D.face = this.intersects[this.boolNum].face;\\r\\n\\t\\t\\t\\t\\tthis.event3D.point = this.intersects[this.boolNum].point;\\r\\n\\t\\t\\t\\t\\tthis.event3D.faceIndex = this.intersects[this.boolNum].faceIndex;\\r\\n\\t\\t\\t\\t\\tthis.event3D.uv = this.intersects[this.boolNum].uv;\\r\\n\\t\\t\\t\\t\\tthis.event3D.originalEvent = self.event;\\r\\n\\t\\t\\t\\t\\tthis.eventSob.dispatcherEvent('over', this.event3D);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\t\\tthis.event3D.face = this.intersects[this.boolNum].face;\\r\\n\\t\\t\\t\\t\\tthis.event3D.point = this.intersects[this.boolNum].point;\\r\\n\\t\\t\\t\\t\\tthis.event3D.faceIndex = this.intersects[this.boolNum].faceIndex;\\r\\n\\t\\t\\t\\t\\tthis.event3D.uv = this.intersects[this.boolNum].uv;\\r\\n\\t\\t\\t\\t\\tthis.event3D.originalEvent = self.event;\\r\\n\\t\\t\\t\\t\\tthis.eventSob.dispatcherEvent('move', this.event3D);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tthis.uuid = this.intersects[this.boolNum].object.uuid;\\r\\n\\t\\t\\t\\tthis.event3D.target = this.intersects[this.boolNum].object;\\r\\n\\t\\t\\t\\tthis.event3D.face = this.intersects[this.boolNum].face;\\r\\n\\t\\t\\t\\tthis.event3D.point = this.intersects[this.boolNum].point;\\r\\n\\t\\t\\t\\tthis.event3D.faceIndex = this.intersects[this.boolNum].faceIndex;\\r\\n\\t\\t\\t\\tthis.event3D.uv = this.intersects[this.boolNum].uv;\\r\\n\\t\\t\\t\\tthis.event3D.originalEvent = self.event;\\r\\n\\t\\t\\t\\tthis.eventSob.dispatcherEvent('over', this.event3D);\\r\\n\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tthis.boolNumOld = this.boolNum;\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.getPosition = function (s) {\\r\\n\\t\\tvar str = this.poiskName;\\r\\n\\r\\n\\t\\tif (s != undefined) {\\r\\n\\t\\t\\tthis.poiskName = s;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.poiskName = 'xzPoisk';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.restartPoint();\\r\\n\\r\\n\\t\\tthis.rayPusk();\\r\\n\\r\\n\\r\\n\\t\\tthis.poiskName = str;\\r\\n\\t\\tif (this.intersects.length != 0) {\\r\\n\\t\\t\\t// var t =this.getGoodParam()\\r\\n\\t\\t\\tvar t = this.intersects.length - 1;\\r\\n\\t\\t\\tif (t == -1)t = 0;\\r\\n\\t\\t\\treturn this.intersects[t];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn null;\\r\\n\\t};\\r\\n\\r\\n\\tvar e3D = new MEvent3D();\\r\\n\\t// Относительно имени возврощает евент\\r\\n\\tthis.getNameEvent = function (str) {\\r\\n\\t\\tthis.restartPoint();\\r\\n\\t\\tthis.rayPusk();\\r\\n\\r\\n\\t\\tif (this.intersects.length != 0) {\\r\\n\\t\\t\\tfor (var i = 0; i < this.intersects.length; i++) {\\r\\n\\t\\t\\t\\tif (this.intersects[i].object.parent != undefined) {\\r\\n\\t\\t\\t\\t\\tif (this.intersects[i].object.name == str) {\\r\\n\\t\\t\\t\\t\\t\\te3D.target = this.intersects[this.boolNum].object;\\r\\n\\t\\t\\t\\t\\t\\te3D.face = this.intersects[this.boolNum].face;\\r\\n\\t\\t\\t\\t\\t\\te3D.point = this.intersects[this.boolNum].point;\\r\\n\\t\\t\\t\\t\\t\\te3D.faceIndex = this.intersects[this.boolNum].faceIndex;\\r\\n\\t\\t\\t\\t\\t\\te3D.uv = this.intersects[this.boolNum].uv;\\r\\n\\t\\t\\t\\t\\t\\te3D.originalEvent = self.event;\\r\\n\\t\\t\\t\\t\\t\\treturn e3D;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn null;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.testVisiParam = function (_obj3d) {\\r\\n\\t\\tif (_obj3d.visible == false) return false;\\r\\n\\t\\tif (_obj3d.parent != undefined) {\\r\\n\\t\\t\\treturn this.testVisiParam(_obj3d.parent);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (_obj3d.type == 'Scene') return true;\\r\\n\\t\\t\\telse return false;\\r\\n\\t\\t}\\r\\n\\t\\treturn true;\\r\\n\\t};\\r\\n\\r\\n\\tthis.getGoodParam = function () {\\r\\n\\r\\n\\t\\tif (this.intersects.length != 0) {\\r\\n\\t\\t\\tvar i;\\r\\n\\r\\n\\t\\t\\tfor (i = 0; i < this.intersects.length; i++) {\\r\\n\\t\\t\\t\\tif (this.testVisiParam(this.intersects[i].object) != false) {\\r\\n\\t\\t\\t\\t\\tif (this.intersects[i].object.notActiv != undefined) {\\r\\n\\t\\t\\t\\t\\t\\tthis.intersects.splice(i, 1);\\r\\n\\t\\t\\t\\t\\t\\ti = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (this.intersects.length == 0) return -1;\\r\\n\\r\\n\\t\\t\\tfor (i = 0; i < this.intersects.length; i++) {\\r\\n\\t\\t\\t\\tif (this.testVisiParam(this.intersects[i].object) != false) {\\r\\n\\t\\t\\t\\t\\tif (this.intersects[i].object.name == this.poiskName) {\\r\\n\\t\\t\\t\\t\\t\\treturn i;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tfor (i = 0; i < this.intersects.length; i++) {\\r\\n\\t\\t\\t\\tif (this.testVisiParam(this.intersects[i].object) != false) {\\r\\n\\t\\t\\t\\t\\tif (this.intersects[i].object.name != this.xzNull) {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\treturn i;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn -1;\\r\\n\\t};\\r\\n\\t// пускаем лучь\\r\\n\\tthis.rayPusk = function () {\\r\\n\\t\\tcameraPosition = new THREE.Vector3();\\r\\n\\r\\n\\t\\tcameraPosition.setFromMatrixPosition(this.camera.matrixWorld); // world position\\r\\n\\t\\tthis.raycaster.ray.origin.copy(cameraPosition);\\r\\n\\r\\n\\t\\tthis.raycaster.ray.direction.set(this.point.x, this.point.y, 0.5).unproject(this.camera).sub(cameraPosition).normalize();\\r\\n\\t\\tthis.intersects = this.raycaster.intersectObjects(this.arrChild, true);\\r\\n\\r\\n\\t};\\r\\n\\r\\n\\tthis.naCont = false;\\r\\n\\r\\n\\tthis.mousemove = function (e) {\\r\\n\\t\\tif (self.naCont == false) return;\\r\\n\\r\\n\\t\\tif (e.data != undefined)self.event = e.data.originalEvent;\\r\\n\\t\\telse self.event = e;\\r\\n\\t\\tif (self._activ == false) return;\\r\\n\\t\\t// self.event.preventDefault();\\r\\n\\r\\n\\t\\tself.restartPoint(e);\\r\\n\\r\\n\\r\\n\\t\\tself.mouseRay();\\r\\n\\t\\tif (self.intersects.length) {\\r\\n\\t\\t\\tself.event.preventDefault();\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.zdvigX = 0;\\r\\n\\tthis.scale = 1;\\r\\n\\tthis.pV = new THREE.Vector2(0, 0);\\r\\n\\tthis.restartPoint = function (e) {\\r\\n\\t\\tself.pV.x = pl102.global.x;\\r\\n\\t\\tself.pV.y = pl102.global.y;\\r\\n\\r\\n\\t\\tif (self.isRect(self.pV) == true) {\\r\\n\\t\\t\\tself.point.x = -((this.rect.x - self.pV.x) / this.rect.width) * 2 - 1;\\r\\n\\t\\t\\tself.point.y = -(-((this.rect.y - self.pV.y) / this.rect.height) * 2 - 1);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (self.point.x != 99999) {\\r\\n\\t\\t\\t\\tself.point.x = 99999;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.isRect = function (point) {\\r\\n\\t\\tif ((point.x >= this.rect.x) && (point.x <= this.rect.x + this.rect.width)) {\\r\\n\\t\\t\\tif ((point.y >= this.rect.y) && (point.y <= this.rect.y + this.rect.height)) {\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t};\\r\\n\\r\\n\\tthis.mouseup = function (e) {\\r\\n\\t\\tif (e.data != undefined)self.event = e.data.originalEvent;\\r\\n\\t\\telse self.event = e;\\r\\n\\r\\n\\t\\tif (self._activ == false) return;\\r\\n\\t\\tif (self.boolNumOld == -1) {\\r\\n\\t\\t\\tself.eventSob.dispatcherEvent('up', null);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tself.event3D.originalEvent = self.event;\\r\\n\\t\\t\\tself.eventSob.dispatcherEvent('up', self.event3D);\\r\\n\\t\\t}\\r\\n\\t\\tif (self.intersects.length) {\\r\\n\\t\\t\\tself.event.preventDefault();\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.mousedown = function (e) {\\r\\n\\t\\tif (e.data != undefined)self.event = e.data.originalEvent;\\r\\n\\t\\telse self.event = e;\\r\\n\\r\\n\\t\\tself.restartPoint(e);\\r\\n\\t\\tif (self._activ == false) return;\\r\\n\\t\\tif (self.boolNumOld == -1) {\\r\\n\\t\\t\\tself.eventSob.dispatcherEvent('down', null);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tself.event3D.originalEvent = self.event;\\r\\n\\t\\t\\tself.eventSob.dispatcherEvent('down', self.event3D);\\r\\n\\t\\t}\\r\\n\\t\\tif (self.intersects.length) {\\r\\n\\t\\t\\tself.event.preventDefault();\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.mouseout = function (e) {\\r\\n\\t\\tself.naCont = false;\\r\\n\\r\\n\\t\\tself.restartPoint(e);\\r\\n\\t\\tself.point.x = 99999;\\r\\n\\t\\tself.mouseRay();\\r\\n\\t};\\r\\n\\tthis.mouseover = function (e) {\\r\\n\\t\\tself.naCont = true;\\r\\n\\r\\n\\t\\tself.restartPoint(e);\\r\\n\\t\\tself.mouseRay();\\r\\n\\t};\\r\\n\\r\\n\\tthis.mousewheel = function (e) {\\r\\n\\t\\tif (e.data != undefined)self.event = e.data.originalEvent;\\r\\n\\t\\telse self.event = e;\\r\\n\\r\\n\\t\\tself.restartPoint(e);\\r\\n\\t\\tif (self._activ == false) return;\\r\\n\\t\\tif (self.boolNumOld == -1) {\\r\\n\\t\\t\\tself.eventSob.dispatcherEvent('down', null);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tself.event3D.originalEvent = self.event;\\r\\n\\t\\t\\tself.eventSob.dispatcherEvent('wheel', e);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tthis.addDragEvent = function (cont) {\\r\\n\\t\\tcont.on('mousemove', self.mousemove);\\r\\n\\t\\tcont.on('mouseup', self.mouseup);\\r\\n\\t\\tcont.on('mousedown', self.mousedown);\\r\\n\\t\\tcont.on('mouseout', self.mouseout);\\r\\n\\t\\tcont.on('mouseover', self.mouseover);\\r\\n\\t\\tpl102Wheel.on(cont, 'mousewheel', self.mousewheel);\\r\\n\\t};\\r\\n\\r\\n\\tthis.removeDragEvent = function (cont) {\\r\\n\\t\\tcont.off('mousemove', self.mousemove);\\r\\n\\t\\tcont.off('mouseup', self.mouseup);\\r\\n\\t\\tcont.off('mousedown', self.mousedown);\\r\\n\\t\\tcont.off('mouseout', self.mouseout);\\r\\n\\t\\tcont.off('mouseover', self.mouseover);\\r\\n\\t\\tpl102Wheel.off(cont, 'mousewheel', self.mousewheel);\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tthis.sizeWindow = function (_width, _height) {\\r\\n\\t\\tthis.pointWH.x = _width;\\r\\n\\t\\tthis.pointWH.y = _height;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nMEvent3DArr.prototype = {\\r\\n\\tset activ (v) {\\r\\n\\t\\tif (this._activ == v) return;\\r\\n\\t\\tthis._activ = v;\\r\\n\\t},\\r\\n\\tget activ () {\\r\\n\\t\\treturn this._activ;\\r\\n\\t}\\r\\n};\\r\\n\\n\\n//# sourceURL=webpack:///./src/libMy/visi3D/MEvent3DArr.js_+_2_modules?\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('__webpack_require__.r(__webpack_exports__);\\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _larvij_LMain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LMain\", function() { return _larvij_LMain_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"]; });\\n\\n\\r\\nglobal.LMain = _larvij_LMain_js__WEBPACK_IMPORTED_MODULE_0__[/* LMain */ \"a\"];\\r\\n\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9)))\\n\\n//# sourceURL=webpack:///./src/index.js?')},function(module,exports){eval('var g;\\n\\n// This works in non-strict mode\\ng = (function() {\\n\\treturn this;\\n})();\\n\\ntry {\\n\\t// This works if eval is allowed (see CSP)\\n\\tg = g || new Function(\"return this\")();\\n} catch (e) {\\n\\t// This works if the window reference is available\\n\\tif (typeof window === \"object\") g = window;\\n}\\n\\n// g can still be undefined, but nothing to do about it...\\n// We return undefined, instead of nothing here, so it\\'s\\n// easier to handle this case. if(!global) { ...}\\n\\nmodule.exports = g;\\n\\n\\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')}]);","extractedComments":[]}